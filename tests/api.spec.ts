/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Fireblocks  } from '../client/client';
import { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";
import { convertToFireblocksResponse, FireblocksResponse} from "../response/fireblocksResponse";
import { FireblocksError } from "../error/fireblocksError";

const mockedResponse: AxiosResponse = {
    data: 'Mocked data',
    status: 200,
    statusText: 'OK',
    headers: {},
    config: {} as AxiosRequestConfig as any,
};

let mockAxios: any;

jest.mock("../network/axiosManager", () => {
    mockAxios = {
        request: jest.fn((config: AxiosRequestConfig) => {
            return Promise.resolve(mockedResponse);
        }), // Mocking the request method to return the mocked response
        defaults: jest.fn()
    };
    return {
    AxiosManager: jest.fn().mockReturnValue({
        axios: mockAxios
    })
}
});


describe("Api Tests", () => {
    let fireblocks: Fireblocks;

    beforeEach(() => {
        fireblocks = new Fireblocks({
            apiKey: "my-api-key",
            basePath: "http://mock-server",
            secretKey: "secretKey"
        });
    });

    afterEach(() => {
        jest.clearAllMocks();
    });

    describe('Api Request test', () => {

        it('Should include basePath as url in final request', async () => {
            await fireblocks.blockchainsAssets.getSupportedAssets();
            expect(mockAxios.request).toHaveBeenCalledTimes(1);
            expect(mockAxios.request).toHaveBeenCalledWith(expect.objectContaining({url: "http://mock-server/supported_assets"}));
        });

        it('Should include baseOptions headers in final request', async () => {
            fireblocks = new Fireblocks({
                apiKey: "my-api-key",
                basePath: "http://mock-server",
                secretKey: "secretKey",
                additionalOptions: {
                    baseOptions: {
                        headers: {
                            "X-My-Header": "my-header-value"
                        } as any
                    }
                }
            });
            await fireblocks.blockchainsAssets.getSupportedAssets();
            expect(mockAxios.request).toHaveBeenCalledTimes(1);
            expect(mockAxios.request).toHaveBeenCalledWith(expect.objectContaining({headers: {"X-My-Header": "my-header-value"}}));
        });

        it('Should return fireblocks response when response is axios response', async () => {
            const res = await fireblocks.blockchainsAssets.getSupportedAssets();
            expect(mockAxios.request).toHaveBeenCalledTimes(1);
            expect(res).toEqual(convertToFireblocksResponse(mockedResponse));
        });

        it('Should return fireblocks error when error is axios error', async () => {
            mockAxios.request.mockImplementation(() => {
                return Promise.reject(new AxiosError(
                    "Mocked error message 1",
                    "BAD_REQUEST",
                    {} as AxiosRequestConfig as any,
                    { url: "http://localhost:8080" },
                    {
                        data: {message: 'Mocked error message 2'},
                        status: 400,
                        statusText: "BAD_REQUEST",
                        headers: {"X-My-Header": "my-header-value"},
                        config: {} as AxiosRequestConfig as any,
                    }
                ));
            });
             const expectedResponse = new FireblocksResponse(
                    {message: 'Mocked error message 2'},
                    400,
                    {"X-My-Header": "my-header-value"}
                );
             const expectedError = new FireblocksError(
                "Mocked error message 1",
                expectedResponse,
                { url: "http://localhost:8080" }
             );
            await expect(fireblocks.blockchainsAssets.getSupportedAssets()).rejects.toThrowError(expectedError as any);
        });

        it('Should not return fireblocks error when error is not axios error', async () => {
            mockAxios.request.mockImplementation(() => {
                return Promise.reject(new Error("Mocked error message"));
            });
            await expect(fireblocks.blockchainsAssets.getSupportedAssets()).rejects.toThrowError("Mocked error message");
        });
    });

});
