/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

    import { CreateConnectionRequest } from '../model/createConnectionRequest';
    import { CreateConnectionResponse } from '../model/createConnectionResponse';
    import { GetConnectionsFilterParameter } from '../model/getConnectionsFilterParameter';
    import { GetConnectionsResponse } from '../model/getConnectionsResponse';
    import { RespondToConnectionRequest } from '../model/respondToConnectionRequest';
import {HttpClient} from '../utils/http-client';
import {Configuration, ConfigurationParameters} from '../utils/types/configuration';
import {ObjectSerializer} from "../model/models";
import { AxiosRequestConfig, AxiosResponse } from 'axios';


    export class Web3ConnectionsApi {
        private  configuration: Configuration;
        private  httpClient: HttpClient;

        constructor(private configurationParameters:ConfigurationParameters = {}) {
            this.configuration = new Configuration(configurationParameters)
            this.httpClient = new HttpClient(this.configuration);
        }

            /**
            * Initiate a new Web3 connection.  * Note: After this succeeds, make a request to `PUT /v1/connections/wc/{id}` (below) to approve or reject the new Web3 connection.
                * @summary Create a new Web3 connection.
                * @param createConnectionRequest 
            */
        public async createWCConnection (createConnectionRequest: CreateConnectionRequest, ) : Promise<CreateConnectionResponse> {
                const path = this.configuration.basePath + '/connections/wc';
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'createConnectionRequest' is not null or undefined
                        if (createConnectionRequest === null || createConnectionRequest === undefined) {
                        throw new Error('Required parameter createConnectionRequest was null or undefined when calling createWCConnection.');
                        }


                    if (typeof createConnectionRequest === 'object') {
                        for( const [key,value] of Object.entries(createConnectionRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['CreateConnectionRequest'] = ObjectSerializer.serialize(createConnectionRequest, "CreateConnectionRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<CreateConnectionResponse>(requestOptions);
        }
            /**
            * Remove a Web3 connection
                * @summary Remove an existing Web3 connection.
                * @param id The ID of the existing Web3 connection to remove.
            */
        public async deleteWCConnection (id: string, ) : Promise<any> {
                const path = this.configuration.basePath + '/connections/wc/{id}'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'id' is not null or undefined
                        if (id === null || id === undefined) {
                        throw new Error('Required parameter id was null or undefined when calling deleteWCConnection.');
                        }


                    if (typeof id === 'object') {
                        for( const [key,value] of Object.entries(id)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['id'] = ObjectSerializer.serialize(id, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'DELETE',
                    url: path,
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Get open Web3 connections.
                * @summary List all open Web3 connections.
                * @param order List order; ascending or descending.
                * @param filter Parsed filter object
                * @param sort Property to sort Web3 connections by.
                * @param pageSize Amount of results to return in the next page.
                * @param next Cursor to the next page
            */
        public async getConnections (order?: 'ASC' | 'DESC', filter?: GetConnectionsFilterParameter, sort?: 'id' | 'userId' | 'vaultAccountId' | 'createdAt' | 'feeLevel' | 'appUrl' | 'appName', pageSize?: number, next?: string, ) : Promise<GetConnectionsResponse> {
                const path = this.configuration.basePath + '/connections';
                let params: any = {};
                let headers: any = {}

                    if (typeof order === 'object') {
                        for( const [key,value] of Object.entries(order)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['order'] = ObjectSerializer.serialize(order, "'ASC' | 'DESC'");
                    }

                    if (typeof filter === 'object') {
                        for( const [key,value] of Object.entries(filter)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['filter'] = ObjectSerializer.serialize(filter, "GetConnectionsFilterParameter");
                    }

                    if (typeof sort === 'object') {
                        for( const [key,value] of Object.entries(sort)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['sort'] = ObjectSerializer.serialize(sort, "'id' | 'userId' | 'vaultAccountId' | 'createdAt' | 'feeLevel' | 'appUrl' | 'appName'");
                    }

                    if (typeof pageSize === 'object') {
                        for( const [key,value] of Object.entries(pageSize)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
                    }

                    if (typeof next === 'object') {
                        for( const [key,value] of Object.entries(next)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['next'] = ObjectSerializer.serialize(next, "string");
                    }
                    if (order !== undefined) {
                        params['order'] = ObjectSerializer.serialize(order, "'ASC' | 'DESC'");
                    }
                    if (filter !== undefined) {
                        params['filter'] = ObjectSerializer.serialize(filter, "GetConnectionsFilterParameter");
                    }
                    if (sort !== undefined) {
                        params['sort'] = ObjectSerializer.serialize(sort, "'id' | 'userId' | 'vaultAccountId' | 'createdAt' | 'feeLevel' | 'appUrl' | 'appName'");
                    }
                    if (pageSize !== undefined) {
                        params['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
                    }
                    if (next !== undefined) {
                        params['next'] = ObjectSerializer.serialize(next, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<GetConnectionsResponse>(requestOptions);
        }
            /**
            * Submit a response to *approve* or *reject* an initiated Web3 connection. * Note: This call is used to complete your `POST /v1/connections/wc/` request.  After this succeeds, your new Web3 connection is created and functioning.
                * @summary Respond to a pending Web3 connection request.
                * @param id The ID of the initiated Web3 connection to approve.
                * @param respondToConnectionRequest 
            */
        public async updateWCConnection (id: string, respondToConnectionRequest: RespondToConnectionRequest, ) : Promise<any> {
                const path = this.configuration.basePath + '/connections/wc/{id}'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'id' is not null or undefined
                        if (id === null || id === undefined) {
                        throw new Error('Required parameter id was null or undefined when calling updateWCConnection.');
                        }


                    if (typeof id === 'object') {
                        for( const [key,value] of Object.entries(id)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['id'] = ObjectSerializer.serialize(id, "string");
                    }
                        // verify required parameter 'respondToConnectionRequest' is not null or undefined
                        if (respondToConnectionRequest === null || respondToConnectionRequest === undefined) {
                        throw new Error('Required parameter respondToConnectionRequest was null or undefined when calling updateWCConnection.');
                        }


                    if (typeof respondToConnectionRequest === 'object') {
                        for( const [key,value] of Object.entries(respondToConnectionRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['RespondToConnectionRequest'] = ObjectSerializer.serialize(respondToConnectionRequest, "RespondToConnectionRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'PUT',
                    url: path,
                        data: params
                };
                return this.httpClient.request<any>(requestOptions);
        }
        }
