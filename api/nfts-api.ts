/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import { convertToFireblocksResponse } from "../response/fireblocksResponse";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import { assertParamExistsAndNotEmpty } from '../utils/validation_utils';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { GetNFTsResponse } from '../models';
// @ts-ignore
import { GetOwnershipTokensResponse } from '../models';
// @ts-ignore
import { ListOwnedCollectionsResponse } from '../models';
// @ts-ignore
import { ListOwnedTokensResponse } from '../models';
// @ts-ignore
import { TokenResponse } from '../models';
// @ts-ignore
import { UpdateTokenOwnershipStatusDto } from '../models';
// @ts-ignore
import { UpdateTokensOwnershipSpamRequest } from '../models';
// @ts-ignore
import { UpdateTokensOwnershipStatusRequest } from '../models';
/**
 * NFTsApi - axios parameter creator
 * @export
 */
export const NFTsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the requested token data. 
         * @summary List token data by ID
         * @param {string} id NFT ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFT: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getNFT', 'id', id)
            const localVarPath = `/nfts/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the requested tokens data. 
         * @summary List tokens by IDs
         * @param {string} ids A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<GetNFTsSortEnum>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {GetNFTsOrderEnum} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFTs: async (ids: string, pageCursor?: string, pageSize?: number, sort?: Array<GetNFTsSortEnum>, order?: GetNFTsOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getNFTs', 'ids', ids)
            const localVarPath = `/nfts/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all tokens and their data in your workspace. 
         * @summary List all owned tokens (paginated)
         * @param {GetOwnershipTokensBlockchainDescriptorEnum} [blockchainDescriptor] Blockchain descriptor filter
         * @param {string} [vaultAccountIds] A comma separated list of Vault Account IDs. Up to 100 are allowed in a single request.  This field will be ignored when walletType&#x3D;END_USER_WALLET or ncwId is provided.
         * @param {string} [ncwId] Tenant\&#39;s Non-Custodial Wallet ID
         * @param {string} [ncwAccountIds] A comma separated list of Non-Custodial account IDs. Up to 100 are allowed in a single request. This field will be ignored when walletType&#x3D;VAULT_ACCOUNT or ncwId is not provided.
         * @param {GetOwnershipTokensWalletTypeEnum} [walletType] Wallet type, it can be &#x60;VAULT_ACCOUNT&#x60; or &#x60;END_USER_WALLET&#x60;
         * @param {string} [ids] A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
         * @param {string} [collectionIds] A comma separated list of collection IDs. Up to 100 are allowed in a single request.
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<GetOwnershipTokensSortEnum>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {GetOwnershipTokensOrderEnum} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {GetOwnershipTokensStatusEnum} [status] Token ownership status
         * @param {string} [search] Search owned tokens and their collections. Possible criteria for search:  token name and id within the contract/collection, collection name, blockchain descriptor and name.
         * @param {GetOwnershipTokensSpamEnum} [spam] Token ownership spam status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnershipTokens: async (blockchainDescriptor?: GetOwnershipTokensBlockchainDescriptorEnum, vaultAccountIds?: string, ncwId?: string, ncwAccountIds?: string, walletType?: GetOwnershipTokensWalletTypeEnum, ids?: string, collectionIds?: string, pageCursor?: string, pageSize?: number, sort?: Array<GetOwnershipTokensSortEnum>, order?: GetOwnershipTokensOrderEnum, status?: GetOwnershipTokensStatusEnum, search?: string, spam?: GetOwnershipTokensSpamEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/nfts/ownership/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blockchainDescriptor !== undefined) {
                localVarQueryParameter['blockchainDescriptor'] = blockchainDescriptor;
            }

            if (vaultAccountIds !== undefined) {
                localVarQueryParameter['vaultAccountIds'] = vaultAccountIds;
            }

            if (ncwId !== undefined) {
                localVarQueryParameter['ncwId'] = ncwId;
            }

            if (ncwAccountIds !== undefined) {
                localVarQueryParameter['ncwAccountIds'] = ncwAccountIds;
            }

            if (walletType !== undefined) {
                localVarQueryParameter['walletType'] = walletType;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (collectionIds !== undefined) {
                localVarQueryParameter['collectionIds'] = collectionIds;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (spam !== undefined) {
                localVarQueryParameter['spam'] = spam;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all collections in your workspace 
         * @summary List owned collections (paginated)
         * @param {string} [ncwId] Tenant\&#39;s Non-Custodial Wallet ID
         * @param {ListOwnedCollectionsWalletTypeEnum} [walletType] Wallet type, it can be &#x60;VAULT_ACCOUNT&#x60; or &#x60;END_USER_WALLET&#x60;
         * @param {string} [search] Search owned collections. Possible criteria for search: collection name, collection contract address.
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<ListOwnedCollectionsSortEnum>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {ListOwnedCollectionsOrderEnum} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {ListOwnedCollectionsStatusEnum} [status] Token ownership status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnedCollections: async (ncwId?: string, walletType?: ListOwnedCollectionsWalletTypeEnum, search?: string, pageCursor?: string, pageSize?: number, sort?: Array<ListOwnedCollectionsSortEnum>, order?: ListOwnedCollectionsOrderEnum, status?: ListOwnedCollectionsStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/nfts/ownership/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ncwId !== undefined) {
                localVarQueryParameter['ncwId'] = ncwId;
            }

            if (walletType !== undefined) {
                localVarQueryParameter['walletType'] = walletType;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all owned distinct tokens (for your tenant) and their data in your workspace. 
         * @summary List all distinct owned tokens (paginated)
         * @param {string} [ncwId] Tenant\&#39;s Non-Custodial Wallet ID
         * @param {ListOwnedTokensWalletTypeEnum} [walletType] Wallet type, it can be &#x60;VAULT_ACCOUNT&#x60; or &#x60;END_USER_WALLET&#x60;
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<ListOwnedTokensSortEnum>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {ListOwnedTokensOrderEnum} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {ListOwnedTokensStatusEnum} [status] Token ownership status
         * @param {string} [search] Search owned tokens by token name
         * @param {ListOwnedTokensSpamEnum} [spam] Token ownership spam status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnedTokens: async (ncwId?: string, walletType?: ListOwnedTokensWalletTypeEnum, pageCursor?: string, pageSize?: number, sort?: Array<ListOwnedTokensSortEnum>, order?: ListOwnedTokensOrderEnum, status?: ListOwnedTokensStatusEnum, search?: string, spam?: ListOwnedTokensSpamEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/nfts/ownership/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ncwId !== undefined) {
                localVarQueryParameter['ncwId'] = ncwId;
            }

            if (walletType !== undefined) {
                localVarQueryParameter['walletType'] = walletType;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (spam !== undefined) {
                localVarQueryParameter['spam'] = spam;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the latest token metadata. 
         * @summary Refresh token metadata
         * @param {string} id NFT ID
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshNFTMetadata: async (id: string, xEndUserWalletId?: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('refreshNFTMetadata', 'id', id)
            const localVarPath = `/nfts/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xEndUserWalletId != null) {
                localVarHeaderParameter['X-End-User-Wallet-Id'] = String(xEndUserWalletId);
            }

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates all tokens and balances per blockchain and vault account. 
         * @summary Refresh vault account tokens
         * @param {UpdateOwnershipTokensBlockchainDescriptorEnum} blockchainDescriptor Blockchain descriptor filter
         * @param {string} vaultAccountId Vault account filter
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOwnershipTokens: async (blockchainDescriptor: UpdateOwnershipTokensBlockchainDescriptorEnum, vaultAccountId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('updateOwnershipTokens', 'blockchainDescriptor', blockchainDescriptor)
            assertParamExistsAndNotEmpty('updateOwnershipTokens', 'vaultAccountId', vaultAccountId)
            const localVarPath = `/nfts/ownership/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blockchainDescriptor !== undefined) {
                localVarQueryParameter['blockchainDescriptor'] = blockchainDescriptor;
            }

            if (vaultAccountId !== undefined) {
                localVarQueryParameter['vaultAccountId'] = vaultAccountId;
            }

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates token status for a tenant, in all tenant vaults. 
         * @summary Update token ownership status
         * @param {UpdateTokenOwnershipStatusDto} updateTokenOwnershipStatusDto 
         * @param {string} id NFT ID
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTokenOwnershipStatus: async (updateTokenOwnershipStatusDto: UpdateTokenOwnershipStatusDto, id: string, xEndUserWalletId?: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('updateTokenOwnershipStatus', 'updateTokenOwnershipStatusDto', updateTokenOwnershipStatusDto)
            assertParamExistsAndNotEmpty('updateTokenOwnershipStatus', 'id', id)
            const localVarPath = `/nfts/ownership/tokens/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xEndUserWalletId != null) {
                localVarHeaderParameter['X-End-User-Wallet-Id'] = String(xEndUserWalletId);
            }

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTokenOwnershipStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates tokens spam property for a tenant\'s token ownerships, in all tenant vaults.
         * @summary Update tokens ownership spam property
         * @param {UpdateTokensOwnershipSpamRequest} updateTokensOwnershipSpamRequest 
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTokensOwnershipSpam: async (updateTokensOwnershipSpamRequest: UpdateTokensOwnershipSpamRequest, xEndUserWalletId?: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('updateTokensOwnershipSpam', 'updateTokensOwnershipSpamRequest', updateTokensOwnershipSpamRequest)
            const localVarPath = `/nfts/ownership/tokens/spam`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xEndUserWalletId != null) {
                localVarHeaderParameter['X-End-User-Wallet-Id'] = String(xEndUserWalletId);
            }

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTokensOwnershipSpamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates tokens status for a tenant, in all tenant vaults.
         * @summary Update tokens ownership status
         * @param {UpdateTokensOwnershipStatusRequest} updateTokensOwnershipStatusRequest 
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTokensOwnershipStatus: async (updateTokensOwnershipStatusRequest: UpdateTokensOwnershipStatusRequest, xEndUserWalletId?: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('updateTokensOwnershipStatus', 'updateTokensOwnershipStatusRequest', updateTokensOwnershipStatusRequest)
            const localVarPath = `/nfts/ownership/tokens/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xEndUserWalletId != null) {
                localVarHeaderParameter['X-End-User-Wallet-Id'] = String(xEndUserWalletId);
            }

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTokensOwnershipStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NFTsApi - functional programming interface
 * @export
 */
export const NFTsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NFTsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the requested token data. 
         * @summary List token data by ID
         * @param {string} id NFT ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNFT(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNFT(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NFTsApi.getNFT']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns the requested tokens data. 
         * @summary List tokens by IDs
         * @param {string} ids A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<GetNFTsSortEnum>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {GetNFTsOrderEnum} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNFTs(ids: string, pageCursor?: string, pageSize?: number, sort?: Array<GetNFTsSortEnum>, order?: GetNFTsOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNFTsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNFTs(ids, pageCursor, pageSize, sort, order, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NFTsApi.getNFTs']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns all tokens and their data in your workspace. 
         * @summary List all owned tokens (paginated)
         * @param {GetOwnershipTokensBlockchainDescriptorEnum} [blockchainDescriptor] Blockchain descriptor filter
         * @param {string} [vaultAccountIds] A comma separated list of Vault Account IDs. Up to 100 are allowed in a single request.  This field will be ignored when walletType&#x3D;END_USER_WALLET or ncwId is provided.
         * @param {string} [ncwId] Tenant\&#39;s Non-Custodial Wallet ID
         * @param {string} [ncwAccountIds] A comma separated list of Non-Custodial account IDs. Up to 100 are allowed in a single request. This field will be ignored when walletType&#x3D;VAULT_ACCOUNT or ncwId is not provided.
         * @param {GetOwnershipTokensWalletTypeEnum} [walletType] Wallet type, it can be &#x60;VAULT_ACCOUNT&#x60; or &#x60;END_USER_WALLET&#x60;
         * @param {string} [ids] A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
         * @param {string} [collectionIds] A comma separated list of collection IDs. Up to 100 are allowed in a single request.
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<GetOwnershipTokensSortEnum>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {GetOwnershipTokensOrderEnum} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {GetOwnershipTokensStatusEnum} [status] Token ownership status
         * @param {string} [search] Search owned tokens and their collections. Possible criteria for search:  token name and id within the contract/collection, collection name, blockchain descriptor and name.
         * @param {GetOwnershipTokensSpamEnum} [spam] Token ownership spam status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOwnershipTokens(blockchainDescriptor?: GetOwnershipTokensBlockchainDescriptorEnum, vaultAccountIds?: string, ncwId?: string, ncwAccountIds?: string, walletType?: GetOwnershipTokensWalletTypeEnum, ids?: string, collectionIds?: string, pageCursor?: string, pageSize?: number, sort?: Array<GetOwnershipTokensSortEnum>, order?: GetOwnershipTokensOrderEnum, status?: GetOwnershipTokensStatusEnum, search?: string, spam?: GetOwnershipTokensSpamEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOwnershipTokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOwnershipTokens(blockchainDescriptor, vaultAccountIds, ncwId, ncwAccountIds, walletType, ids, collectionIds, pageCursor, pageSize, sort, order, status, search, spam, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NFTsApi.getOwnershipTokens']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns all collections in your workspace 
         * @summary List owned collections (paginated)
         * @param {string} [ncwId] Tenant\&#39;s Non-Custodial Wallet ID
         * @param {ListOwnedCollectionsWalletTypeEnum} [walletType] Wallet type, it can be &#x60;VAULT_ACCOUNT&#x60; or &#x60;END_USER_WALLET&#x60;
         * @param {string} [search] Search owned collections. Possible criteria for search: collection name, collection contract address.
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<ListOwnedCollectionsSortEnum>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {ListOwnedCollectionsOrderEnum} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {ListOwnedCollectionsStatusEnum} [status] Token ownership status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOwnedCollections(ncwId?: string, walletType?: ListOwnedCollectionsWalletTypeEnum, search?: string, pageCursor?: string, pageSize?: number, sort?: Array<ListOwnedCollectionsSortEnum>, order?: ListOwnedCollectionsOrderEnum, status?: ListOwnedCollectionsStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOwnedCollectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOwnedCollections(ncwId, walletType, search, pageCursor, pageSize, sort, order, status, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NFTsApi.listOwnedCollections']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns all owned distinct tokens (for your tenant) and their data in your workspace. 
         * @summary List all distinct owned tokens (paginated)
         * @param {string} [ncwId] Tenant\&#39;s Non-Custodial Wallet ID
         * @param {ListOwnedTokensWalletTypeEnum} [walletType] Wallet type, it can be &#x60;VAULT_ACCOUNT&#x60; or &#x60;END_USER_WALLET&#x60;
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<ListOwnedTokensSortEnum>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {ListOwnedTokensOrderEnum} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {ListOwnedTokensStatusEnum} [status] Token ownership status
         * @param {string} [search] Search owned tokens by token name
         * @param {ListOwnedTokensSpamEnum} [spam] Token ownership spam status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOwnedTokens(ncwId?: string, walletType?: ListOwnedTokensWalletTypeEnum, pageCursor?: string, pageSize?: number, sort?: Array<ListOwnedTokensSortEnum>, order?: ListOwnedTokensOrderEnum, status?: ListOwnedTokensStatusEnum, search?: string, spam?: ListOwnedTokensSpamEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOwnedTokensResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOwnedTokens(ncwId, walletType, pageCursor, pageSize, sort, order, status, search, spam, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NFTsApi.listOwnedTokens']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates the latest token metadata. 
         * @summary Refresh token metadata
         * @param {string} id NFT ID
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshNFTMetadata(id: string, xEndUserWalletId?: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshNFTMetadata(id, xEndUserWalletId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NFTsApi.refreshNFTMetadata']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates all tokens and balances per blockchain and vault account. 
         * @summary Refresh vault account tokens
         * @param {UpdateOwnershipTokensBlockchainDescriptorEnum} blockchainDescriptor Blockchain descriptor filter
         * @param {string} vaultAccountId Vault account filter
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOwnershipTokens(blockchainDescriptor: UpdateOwnershipTokensBlockchainDescriptorEnum, vaultAccountId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOwnershipTokens(blockchainDescriptor, vaultAccountId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NFTsApi.updateOwnershipTokens']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates token status for a tenant, in all tenant vaults. 
         * @summary Update token ownership status
         * @param {UpdateTokenOwnershipStatusDto} updateTokenOwnershipStatusDto 
         * @param {string} id NFT ID
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTokenOwnershipStatus(updateTokenOwnershipStatusDto: UpdateTokenOwnershipStatusDto, id: string, xEndUserWalletId?: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTokenOwnershipStatus(updateTokenOwnershipStatusDto, id, xEndUserWalletId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NFTsApi.updateTokenOwnershipStatus']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates tokens spam property for a tenant\'s token ownerships, in all tenant vaults.
         * @summary Update tokens ownership spam property
         * @param {UpdateTokensOwnershipSpamRequest} updateTokensOwnershipSpamRequest 
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTokensOwnershipSpam(updateTokensOwnershipSpamRequest: UpdateTokensOwnershipSpamRequest, xEndUserWalletId?: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTokensOwnershipSpam(updateTokensOwnershipSpamRequest, xEndUserWalletId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NFTsApi.updateTokensOwnershipSpam']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates tokens status for a tenant, in all tenant vaults.
         * @summary Update tokens ownership status
         * @param {UpdateTokensOwnershipStatusRequest} updateTokensOwnershipStatusRequest 
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTokensOwnershipStatus(updateTokensOwnershipStatusRequest: UpdateTokensOwnershipStatusRequest, xEndUserWalletId?: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTokensOwnershipStatus(updateTokensOwnershipStatusRequest, xEndUserWalletId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NFTsApi.updateTokensOwnershipStatus']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * NFTsApi - factory interface
 * @export
 */
export const NFTsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NFTsApiFp(configuration)
    return {
        /**
         * Returns the requested token data. 
         * @summary List token data by ID
         * @param {NFTsApiGetNFTRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFT(requestParameters: NFTsApiGetNFTRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse> {
            return localVarFp.getNFT(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the requested tokens data. 
         * @summary List tokens by IDs
         * @param {NFTsApiGetNFTsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFTs(requestParameters: NFTsApiGetNFTsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetNFTsResponse> {
            return localVarFp.getNFTs(requestParameters.ids, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all tokens and their data in your workspace. 
         * @summary List all owned tokens (paginated)
         * @param {NFTsApiGetOwnershipTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnershipTokens(requestParameters: NFTsApiGetOwnershipTokensRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetOwnershipTokensResponse> {
            return localVarFp.getOwnershipTokens(requestParameters.blockchainDescriptor, requestParameters.vaultAccountIds, requestParameters.ncwId, requestParameters.ncwAccountIds, requestParameters.walletType, requestParameters.ids, requestParameters.collectionIds, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.status, requestParameters.search, requestParameters.spam, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all collections in your workspace 
         * @summary List owned collections (paginated)
         * @param {NFTsApiListOwnedCollectionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnedCollections(requestParameters: NFTsApiListOwnedCollectionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListOwnedCollectionsResponse> {
            return localVarFp.listOwnedCollections(requestParameters.ncwId, requestParameters.walletType, requestParameters.search, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.status, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all owned distinct tokens (for your tenant) and their data in your workspace. 
         * @summary List all distinct owned tokens (paginated)
         * @param {NFTsApiListOwnedTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnedTokens(requestParameters: NFTsApiListOwnedTokensRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListOwnedTokensResponse> {
            return localVarFp.listOwnedTokens(requestParameters.ncwId, requestParameters.walletType, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.status, requestParameters.search, requestParameters.spam, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the latest token metadata. 
         * @summary Refresh token metadata
         * @param {NFTsApiRefreshNFTMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshNFTMetadata(requestParameters: NFTsApiRefreshNFTMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.refreshNFTMetadata(requestParameters.id, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates all tokens and balances per blockchain and vault account. 
         * @summary Refresh vault account tokens
         * @param {NFTsApiUpdateOwnershipTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOwnershipTokens(requestParameters: NFTsApiUpdateOwnershipTokensRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateOwnershipTokens(requestParameters.blockchainDescriptor, requestParameters.vaultAccountId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates token status for a tenant, in all tenant vaults. 
         * @summary Update token ownership status
         * @param {NFTsApiUpdateTokenOwnershipStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTokenOwnershipStatus(requestParameters: NFTsApiUpdateTokenOwnershipStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateTokenOwnershipStatus(requestParameters.updateTokenOwnershipStatusDto, requestParameters.id, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates tokens spam property for a tenant\'s token ownerships, in all tenant vaults.
         * @summary Update tokens ownership spam property
         * @param {NFTsApiUpdateTokensOwnershipSpamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTokensOwnershipSpam(requestParameters: NFTsApiUpdateTokensOwnershipSpamRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateTokensOwnershipSpam(requestParameters.updateTokensOwnershipSpamRequest, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates tokens status for a tenant, in all tenant vaults.
         * @summary Update tokens ownership status
         * @param {NFTsApiUpdateTokensOwnershipStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTokensOwnershipStatus(requestParameters: NFTsApiUpdateTokensOwnershipStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateTokensOwnershipStatus(requestParameters.updateTokensOwnershipStatusRequest, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getNFT operation in NFTsApi.
 * @export
 * @interface NFTsApiGetNFTRequest
 */
export interface NFTsApiGetNFTRequest {
    /**
     * NFT ID
     * @type {string}
     * @memberof NFTsApiGetNFT
     */
    readonly id: string
}

/**
 * Request parameters for getNFTs operation in NFTsApi.
 * @export
 * @interface NFTsApiGetNFTsRequest
 */
export interface NFTsApiGetNFTsRequest {
    /**
     * A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
     * @type {string}
     * @memberof NFTsApiGetNFTs
     */
    readonly ids: string

    /**
     * Page cursor to fetch
     * @type {string}
     * @memberof NFTsApiGetNFTs
     */
    readonly pageCursor?: string

    /**
     * Items per page (max 100)
     * @type {number}
     * @memberof NFTsApiGetNFTs
     */
    readonly pageSize?: number

    /**
     * Sort by param, it can be one param or a list of params separated by comma
     * @type {Array<'collection.name' | 'name' | 'blockchainDescriptor'>}
     * @memberof NFTsApiGetNFTs
     */
    readonly sort?: Array<GetNFTsSortEnum>

    /**
     * Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
     * @type {'DESC' | 'ASC'}
     * @memberof NFTsApiGetNFTs
     */
    readonly order?: GetNFTsOrderEnum
}

/**
 * Request parameters for getOwnershipTokens operation in NFTsApi.
 * @export
 * @interface NFTsApiGetOwnershipTokensRequest
 */
export interface NFTsApiGetOwnershipTokensRequest {
    /**
     * Blockchain descriptor filter
     * @type {'ETH' | 'ETH_TEST3' | 'ETH_TEST5' | 'ETH_TEST6' | 'POLYGON' | 'POLYGON_TEST_MUMBAI' | 'AMOY_POLYGON_TEST' | 'XTZ' | 'XTZ_TEST' | 'BASECHAIN_ETH' | 'BASECHAIN_ETH_TEST3' | 'BASECHAIN_ETH_TEST5' | 'ETHERLINK' | 'ETHERLINK_TEST' | 'MANTLE' | 'MANTLE_TEST' | 'GUN_GUNZILLA' | 'GUN_GUNZILLA_TEST' | 'ETH_SONEIUM' | 'SONEIUM_MINATO_TEST' | 'IOTX_IOTEX' | 'KLAY_KAIA' | 'KLAY_KAIA_TEST' | 'APECHAIN' | 'APECHAIN_TEST'}
     * @memberof NFTsApiGetOwnershipTokens
     */
    readonly blockchainDescriptor?: GetOwnershipTokensBlockchainDescriptorEnum

    /**
     * A comma separated list of Vault Account IDs. Up to 100 are allowed in a single request.  This field will be ignored when walletType&#x3D;END_USER_WALLET or ncwId is provided.
     * @type {string}
     * @memberof NFTsApiGetOwnershipTokens
     */
    readonly vaultAccountIds?: string

    /**
     * Tenant\&#39;s Non-Custodial Wallet ID
     * @type {string}
     * @memberof NFTsApiGetOwnershipTokens
     */
    readonly ncwId?: string

    /**
     * A comma separated list of Non-Custodial account IDs. Up to 100 are allowed in a single request. This field will be ignored when walletType&#x3D;VAULT_ACCOUNT or ncwId is not provided.
     * @type {string}
     * @memberof NFTsApiGetOwnershipTokens
     */
    readonly ncwAccountIds?: string

    /**
     * Wallet type, it can be &#x60;VAULT_ACCOUNT&#x60; or &#x60;END_USER_WALLET&#x60;
     * @type {'VAULT_ACCOUNT' | 'END_USER_WALLET'}
     * @memberof NFTsApiGetOwnershipTokens
     */
    readonly walletType?: GetOwnershipTokensWalletTypeEnum

    /**
     * A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
     * @type {string}
     * @memberof NFTsApiGetOwnershipTokens
     */
    readonly ids?: string

    /**
     * A comma separated list of collection IDs. Up to 100 are allowed in a single request.
     * @type {string}
     * @memberof NFTsApiGetOwnershipTokens
     */
    readonly collectionIds?: string

    /**
     * Page cursor to fetch
     * @type {string}
     * @memberof NFTsApiGetOwnershipTokens
     */
    readonly pageCursor?: string

    /**
     * Items per page (max 100)
     * @type {number}
     * @memberof NFTsApiGetOwnershipTokens
     */
    readonly pageSize?: number

    /**
     * Sort by param, it can be one param or a list of params separated by comma
     * @type {Array<'ownershipLastUpdateTime' | 'name' | 'collection.name' | 'blockchainDescriptor'>}
     * @memberof NFTsApiGetOwnershipTokens
     */
    readonly sort?: Array<GetOwnershipTokensSortEnum>

    /**
     * Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
     * @type {'DESC' | 'ASC'}
     * @memberof NFTsApiGetOwnershipTokens
     */
    readonly order?: GetOwnershipTokensOrderEnum

    /**
     * Token ownership status
     * @type {'LISTED' | 'ARCHIVED'}
     * @memberof NFTsApiGetOwnershipTokens
     */
    readonly status?: GetOwnershipTokensStatusEnum

    /**
     * Search owned tokens and their collections. Possible criteria for search:  token name and id within the contract/collection, collection name, blockchain descriptor and name.
     * @type {string}
     * @memberof NFTsApiGetOwnershipTokens
     */
    readonly search?: string

    /**
     * Token ownership spam status.
     * @type {'true' | 'false' | 'all'}
     * @memberof NFTsApiGetOwnershipTokens
     */
    readonly spam?: GetOwnershipTokensSpamEnum
}

/**
 * Request parameters for listOwnedCollections operation in NFTsApi.
 * @export
 * @interface NFTsApiListOwnedCollectionsRequest
 */
export interface NFTsApiListOwnedCollectionsRequest {
    /**
     * Tenant\&#39;s Non-Custodial Wallet ID
     * @type {string}
     * @memberof NFTsApiListOwnedCollections
     */
    readonly ncwId?: string

    /**
     * Wallet type, it can be &#x60;VAULT_ACCOUNT&#x60; or &#x60;END_USER_WALLET&#x60;
     * @type {'VAULT_ACCOUNT' | 'END_USER_WALLET'}
     * @memberof NFTsApiListOwnedCollections
     */
    readonly walletType?: ListOwnedCollectionsWalletTypeEnum

    /**
     * Search owned collections. Possible criteria for search: collection name, collection contract address.
     * @type {string}
     * @memberof NFTsApiListOwnedCollections
     */
    readonly search?: string

    /**
     * Page cursor to fetch
     * @type {string}
     * @memberof NFTsApiListOwnedCollections
     */
    readonly pageCursor?: string

    /**
     * Items per page (max 100)
     * @type {number}
     * @memberof NFTsApiListOwnedCollections
     */
    readonly pageSize?: number

    /**
     * Sort by param, it can be one param or a list of params separated by comma
     * @type {Array<'name'>}
     * @memberof NFTsApiListOwnedCollections
     */
    readonly sort?: Array<ListOwnedCollectionsSortEnum>

    /**
     * Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
     * @type {'DESC' | 'ASC'}
     * @memberof NFTsApiListOwnedCollections
     */
    readonly order?: ListOwnedCollectionsOrderEnum

    /**
     * Token ownership status
     * @type {'LISTED' | 'ARCHIVED'}
     * @memberof NFTsApiListOwnedCollections
     */
    readonly status?: ListOwnedCollectionsStatusEnum
}

/**
 * Request parameters for listOwnedTokens operation in NFTsApi.
 * @export
 * @interface NFTsApiListOwnedTokensRequest
 */
export interface NFTsApiListOwnedTokensRequest {
    /**
     * Tenant\&#39;s Non-Custodial Wallet ID
     * @type {string}
     * @memberof NFTsApiListOwnedTokens
     */
    readonly ncwId?: string

    /**
     * Wallet type, it can be &#x60;VAULT_ACCOUNT&#x60; or &#x60;END_USER_WALLET&#x60;
     * @type {'VAULT_ACCOUNT' | 'END_USER_WALLET'}
     * @memberof NFTsApiListOwnedTokens
     */
    readonly walletType?: ListOwnedTokensWalletTypeEnum

    /**
     * Page cursor to fetch
     * @type {string}
     * @memberof NFTsApiListOwnedTokens
     */
    readonly pageCursor?: string

    /**
     * Items per page (max 100)
     * @type {number}
     * @memberof NFTsApiListOwnedTokens
     */
    readonly pageSize?: number

    /**
     * Sort by param, it can be one param or a list of params separated by comma
     * @type {Array<'name'>}
     * @memberof NFTsApiListOwnedTokens
     */
    readonly sort?: Array<ListOwnedTokensSortEnum>

    /**
     * Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
     * @type {'DESC' | 'ASC'}
     * @memberof NFTsApiListOwnedTokens
     */
    readonly order?: ListOwnedTokensOrderEnum

    /**
     * Token ownership status
     * @type {'LISTED' | 'ARCHIVED'}
     * @memberof NFTsApiListOwnedTokens
     */
    readonly status?: ListOwnedTokensStatusEnum

    /**
     * Search owned tokens by token name
     * @type {string}
     * @memberof NFTsApiListOwnedTokens
     */
    readonly search?: string

    /**
     * Token ownership spam status.
     * @type {'true' | 'false' | 'all'}
     * @memberof NFTsApiListOwnedTokens
     */
    readonly spam?: ListOwnedTokensSpamEnum
}

/**
 * Request parameters for refreshNFTMetadata operation in NFTsApi.
 * @export
 * @interface NFTsApiRefreshNFTMetadataRequest
 */
export interface NFTsApiRefreshNFTMetadataRequest {
    /**
     * NFT ID
     * @type {string}
     * @memberof NFTsApiRefreshNFTMetadata
     */
    readonly id: string

    /**
     * Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
     * @type {string}
     * @memberof NFTsApiRefreshNFTMetadata
     */
    readonly xEndUserWalletId?: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof NFTsApiRefreshNFTMetadata
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for updateOwnershipTokens operation in NFTsApi.
 * @export
 * @interface NFTsApiUpdateOwnershipTokensRequest
 */
export interface NFTsApiUpdateOwnershipTokensRequest {
    /**
     * Blockchain descriptor filter
     * @type {'ETH' | 'ETH_TEST5' | 'ETH_TEST6' | 'POLYGON' | 'POLYGON_TEST_MUMBAI' | 'AMOY_POLYGON_TEST' | 'BASECHAIN_ETH' | 'BASECHAIN_ETH_TEST5' | 'ETHERLINK' | 'ETHERLINK_TEST' | 'MANTLE' | 'MANTLE_TEST' | 'GUN_GUNZILLA' | 'GUN_GUNZILLA_TEST' | 'ETH_SONEIUM' | 'SONEIUM_MINATO_TEST' | 'IOTX_IOTEX' | 'KLAY_KAIA' | 'KLAY_KAIA_TEST' | 'APECHAIN' | 'APECHAIN_TEST'}
     * @memberof NFTsApiUpdateOwnershipTokens
     */
    readonly blockchainDescriptor: UpdateOwnershipTokensBlockchainDescriptorEnum

    /**
     * Vault account filter
     * @type {string}
     * @memberof NFTsApiUpdateOwnershipTokens
     */
    readonly vaultAccountId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof NFTsApiUpdateOwnershipTokens
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for updateTokenOwnershipStatus operation in NFTsApi.
 * @export
 * @interface NFTsApiUpdateTokenOwnershipStatusRequest
 */
export interface NFTsApiUpdateTokenOwnershipStatusRequest {
    /**
     * 
     * @type {UpdateTokenOwnershipStatusDto}
     * @memberof NFTsApiUpdateTokenOwnershipStatus
     */
    readonly updateTokenOwnershipStatusDto: UpdateTokenOwnershipStatusDto

    /**
     * NFT ID
     * @type {string}
     * @memberof NFTsApiUpdateTokenOwnershipStatus
     */
    readonly id: string

    /**
     * Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
     * @type {string}
     * @memberof NFTsApiUpdateTokenOwnershipStatus
     */
    readonly xEndUserWalletId?: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof NFTsApiUpdateTokenOwnershipStatus
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for updateTokensOwnershipSpam operation in NFTsApi.
 * @export
 * @interface NFTsApiUpdateTokensOwnershipSpamRequest
 */
export interface NFTsApiUpdateTokensOwnershipSpamRequest {
    /**
     * 
     * @type {UpdateTokensOwnershipSpamRequest}
     * @memberof NFTsApiUpdateTokensOwnershipSpam
     */
    readonly updateTokensOwnershipSpamRequest: UpdateTokensOwnershipSpamRequest

    /**
     * Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
     * @type {string}
     * @memberof NFTsApiUpdateTokensOwnershipSpam
     */
    readonly xEndUserWalletId?: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof NFTsApiUpdateTokensOwnershipSpam
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for updateTokensOwnershipStatus operation in NFTsApi.
 * @export
 * @interface NFTsApiUpdateTokensOwnershipStatusRequest
 */
export interface NFTsApiUpdateTokensOwnershipStatusRequest {
    /**
     * 
     * @type {UpdateTokensOwnershipStatusRequest}
     * @memberof NFTsApiUpdateTokensOwnershipStatus
     */
    readonly updateTokensOwnershipStatusRequest: UpdateTokensOwnershipStatusRequest

    /**
     * Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
     * @type {string}
     * @memberof NFTsApiUpdateTokensOwnershipStatus
     */
    readonly xEndUserWalletId?: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof NFTsApiUpdateTokensOwnershipStatus
     */
    readonly idempotencyKey?: string
}

/**
 * NFTsApi - object-oriented interface
 * @export
 * @class NFTsApi
 * @extends {BaseAPI}
 */
export class NFTsApi extends BaseAPI {
    /**
     * Returns the requested token data. 
     * @summary List token data by ID
     * @param {NFTsApiGetNFTRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    public getNFT(requestParameters: NFTsApiGetNFTRequest) {
        return NFTsApiFp(this.configuration).getNFT(requestParameters.id).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns the requested tokens data. 
     * @summary List tokens by IDs
     * @param {NFTsApiGetNFTsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    public getNFTs(requestParameters: NFTsApiGetNFTsRequest) {
        return NFTsApiFp(this.configuration).getNFTs(requestParameters.ids, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns all tokens and their data in your workspace. 
     * @summary List all owned tokens (paginated)
     * @param {NFTsApiGetOwnershipTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    public getOwnershipTokens(requestParameters: NFTsApiGetOwnershipTokensRequest = {}) {
        return NFTsApiFp(this.configuration).getOwnershipTokens(requestParameters.blockchainDescriptor, requestParameters.vaultAccountIds, requestParameters.ncwId, requestParameters.ncwAccountIds, requestParameters.walletType, requestParameters.ids, requestParameters.collectionIds, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.status, requestParameters.search, requestParameters.spam).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns all collections in your workspace 
     * @summary List owned collections (paginated)
     * @param {NFTsApiListOwnedCollectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    public listOwnedCollections(requestParameters: NFTsApiListOwnedCollectionsRequest = {}) {
        return NFTsApiFp(this.configuration).listOwnedCollections(requestParameters.ncwId, requestParameters.walletType, requestParameters.search, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.status).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns all owned distinct tokens (for your tenant) and their data in your workspace. 
     * @summary List all distinct owned tokens (paginated)
     * @param {NFTsApiListOwnedTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    public listOwnedTokens(requestParameters: NFTsApiListOwnedTokensRequest = {}) {
        return NFTsApiFp(this.configuration).listOwnedTokens(requestParameters.ncwId, requestParameters.walletType, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.status, requestParameters.search, requestParameters.spam).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Updates the latest token metadata. 
     * @summary Refresh token metadata
     * @param {NFTsApiRefreshNFTMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    public refreshNFTMetadata(requestParameters: NFTsApiRefreshNFTMetadataRequest) {
        return NFTsApiFp(this.configuration).refreshNFTMetadata(requestParameters.id, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Updates all tokens and balances per blockchain and vault account. 
     * @summary Refresh vault account tokens
     * @param {NFTsApiUpdateOwnershipTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    public updateOwnershipTokens(requestParameters: NFTsApiUpdateOwnershipTokensRequest) {
        return NFTsApiFp(this.configuration).updateOwnershipTokens(requestParameters.blockchainDescriptor, requestParameters.vaultAccountId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Updates token status for a tenant, in all tenant vaults. 
     * @summary Update token ownership status
     * @param {NFTsApiUpdateTokenOwnershipStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    public updateTokenOwnershipStatus(requestParameters: NFTsApiUpdateTokenOwnershipStatusRequest) {
        return NFTsApiFp(this.configuration).updateTokenOwnershipStatus(requestParameters.updateTokenOwnershipStatusDto, requestParameters.id, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Updates tokens spam property for a tenant\'s token ownerships, in all tenant vaults.
     * @summary Update tokens ownership spam property
     * @param {NFTsApiUpdateTokensOwnershipSpamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    public updateTokensOwnershipSpam(requestParameters: NFTsApiUpdateTokensOwnershipSpamRequest) {
        return NFTsApiFp(this.configuration).updateTokensOwnershipSpam(requestParameters.updateTokensOwnershipSpamRequest, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Updates tokens status for a tenant, in all tenant vaults.
     * @summary Update tokens ownership status
     * @param {NFTsApiUpdateTokensOwnershipStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    public updateTokensOwnershipStatus(requestParameters: NFTsApiUpdateTokensOwnershipStatusRequest) {
        return NFTsApiFp(this.configuration).updateTokensOwnershipStatus(requestParameters.updateTokensOwnershipStatusRequest, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }
}

/**
 * @export
 */
export const GetNFTsSortEnum = {
    CollectionName: 'collection.name',
    Name: 'name',
    BlockchainDescriptor: 'blockchainDescriptor'
} as const;
export type GetNFTsSortEnum = typeof GetNFTsSortEnum[keyof typeof GetNFTsSortEnum];
/**
 * @export
 */
export const GetNFTsOrderEnum = {
    Desc: 'DESC',
    Asc: 'ASC'
} as const;
export type GetNFTsOrderEnum = typeof GetNFTsOrderEnum[keyof typeof GetNFTsOrderEnum];
/**
 * @export
 */
export const GetOwnershipTokensBlockchainDescriptorEnum = {
    Eth: 'ETH',
    EthTest3: 'ETH_TEST3',
    EthTest5: 'ETH_TEST5',
    EthTest6: 'ETH_TEST6',
    Polygon: 'POLYGON',
    PolygonTestMumbai: 'POLYGON_TEST_MUMBAI',
    AmoyPolygonTest: 'AMOY_POLYGON_TEST',
    Xtz: 'XTZ',
    XtzTest: 'XTZ_TEST',
    BasechainEth: 'BASECHAIN_ETH',
    BasechainEthTest3: 'BASECHAIN_ETH_TEST3',
    BasechainEthTest5: 'BASECHAIN_ETH_TEST5',
    Etherlink: 'ETHERLINK',
    EtherlinkTest: 'ETHERLINK_TEST',
    Mantle: 'MANTLE',
    MantleTest: 'MANTLE_TEST',
    GunGunzilla: 'GUN_GUNZILLA',
    GunGunzillaTest: 'GUN_GUNZILLA_TEST',
    EthSoneium: 'ETH_SONEIUM',
    SoneiumMinatoTest: 'SONEIUM_MINATO_TEST',
    IotxIotex: 'IOTX_IOTEX',
    KlayKaia: 'KLAY_KAIA',
    KlayKaiaTest: 'KLAY_KAIA_TEST',
    Apechain: 'APECHAIN',
    ApechainTest: 'APECHAIN_TEST'
} as const;
export type GetOwnershipTokensBlockchainDescriptorEnum = typeof GetOwnershipTokensBlockchainDescriptorEnum[keyof typeof GetOwnershipTokensBlockchainDescriptorEnum];
/**
 * @export
 */
export const GetOwnershipTokensWalletTypeEnum = {
    VaultAccount: 'VAULT_ACCOUNT',
    EndUserWallet: 'END_USER_WALLET'
} as const;
export type GetOwnershipTokensWalletTypeEnum = typeof GetOwnershipTokensWalletTypeEnum[keyof typeof GetOwnershipTokensWalletTypeEnum];
/**
 * @export
 */
export const GetOwnershipTokensSortEnum = {
    OwnershipLastUpdateTime: 'ownershipLastUpdateTime',
    Name: 'name',
    CollectionName: 'collection.name',
    BlockchainDescriptor: 'blockchainDescriptor'
} as const;
export type GetOwnershipTokensSortEnum = typeof GetOwnershipTokensSortEnum[keyof typeof GetOwnershipTokensSortEnum];
/**
 * @export
 */
export const GetOwnershipTokensOrderEnum = {
    Desc: 'DESC',
    Asc: 'ASC'
} as const;
export type GetOwnershipTokensOrderEnum = typeof GetOwnershipTokensOrderEnum[keyof typeof GetOwnershipTokensOrderEnum];
/**
 * @export
 */
export const GetOwnershipTokensStatusEnum = {
    Listed: 'LISTED',
    Archived: 'ARCHIVED'
} as const;
export type GetOwnershipTokensStatusEnum = typeof GetOwnershipTokensStatusEnum[keyof typeof GetOwnershipTokensStatusEnum];
/**
 * @export
 */
export const GetOwnershipTokensSpamEnum = {
    True: 'true',
    False: 'false',
    All: 'all'
} as const;
export type GetOwnershipTokensSpamEnum = typeof GetOwnershipTokensSpamEnum[keyof typeof GetOwnershipTokensSpamEnum];
/**
 * @export
 */
export const ListOwnedCollectionsWalletTypeEnum = {
    VaultAccount: 'VAULT_ACCOUNT',
    EndUserWallet: 'END_USER_WALLET'
} as const;
export type ListOwnedCollectionsWalletTypeEnum = typeof ListOwnedCollectionsWalletTypeEnum[keyof typeof ListOwnedCollectionsWalletTypeEnum];
/**
 * @export
 */
export const ListOwnedCollectionsSortEnum = {
    Name: 'name'
} as const;
export type ListOwnedCollectionsSortEnum = typeof ListOwnedCollectionsSortEnum[keyof typeof ListOwnedCollectionsSortEnum];
/**
 * @export
 */
export const ListOwnedCollectionsOrderEnum = {
    Desc: 'DESC',
    Asc: 'ASC'
} as const;
export type ListOwnedCollectionsOrderEnum = typeof ListOwnedCollectionsOrderEnum[keyof typeof ListOwnedCollectionsOrderEnum];
/**
 * @export
 */
export const ListOwnedCollectionsStatusEnum = {
    Listed: 'LISTED',
    Archived: 'ARCHIVED'
} as const;
export type ListOwnedCollectionsStatusEnum = typeof ListOwnedCollectionsStatusEnum[keyof typeof ListOwnedCollectionsStatusEnum];
/**
 * @export
 */
export const ListOwnedTokensWalletTypeEnum = {
    VaultAccount: 'VAULT_ACCOUNT',
    EndUserWallet: 'END_USER_WALLET'
} as const;
export type ListOwnedTokensWalletTypeEnum = typeof ListOwnedTokensWalletTypeEnum[keyof typeof ListOwnedTokensWalletTypeEnum];
/**
 * @export
 */
export const ListOwnedTokensSortEnum = {
    Name: 'name'
} as const;
export type ListOwnedTokensSortEnum = typeof ListOwnedTokensSortEnum[keyof typeof ListOwnedTokensSortEnum];
/**
 * @export
 */
export const ListOwnedTokensOrderEnum = {
    Desc: 'DESC',
    Asc: 'ASC'
} as const;
export type ListOwnedTokensOrderEnum = typeof ListOwnedTokensOrderEnum[keyof typeof ListOwnedTokensOrderEnum];
/**
 * @export
 */
export const ListOwnedTokensStatusEnum = {
    Listed: 'LISTED',
    Archived: 'ARCHIVED'
} as const;
export type ListOwnedTokensStatusEnum = typeof ListOwnedTokensStatusEnum[keyof typeof ListOwnedTokensStatusEnum];
/**
 * @export
 */
export const ListOwnedTokensSpamEnum = {
    True: 'true',
    False: 'false',
    All: 'all'
} as const;
export type ListOwnedTokensSpamEnum = typeof ListOwnedTokensSpamEnum[keyof typeof ListOwnedTokensSpamEnum];
/**
 * @export
 */
export const UpdateOwnershipTokensBlockchainDescriptorEnum = {
    Eth: 'ETH',
    EthTest5: 'ETH_TEST5',
    EthTest6: 'ETH_TEST6',
    Polygon: 'POLYGON',
    PolygonTestMumbai: 'POLYGON_TEST_MUMBAI',
    AmoyPolygonTest: 'AMOY_POLYGON_TEST',
    BasechainEth: 'BASECHAIN_ETH',
    BasechainEthTest5: 'BASECHAIN_ETH_TEST5',
    Etherlink: 'ETHERLINK',
    EtherlinkTest: 'ETHERLINK_TEST',
    Mantle: 'MANTLE',
    MantleTest: 'MANTLE_TEST',
    GunGunzilla: 'GUN_GUNZILLA',
    GunGunzillaTest: 'GUN_GUNZILLA_TEST',
    EthSoneium: 'ETH_SONEIUM',
    SoneiumMinatoTest: 'SONEIUM_MINATO_TEST',
    IotxIotex: 'IOTX_IOTEX',
    KlayKaia: 'KLAY_KAIA',
    KlayKaiaTest: 'KLAY_KAIA_TEST',
    Apechain: 'APECHAIN',
    ApechainTest: 'APECHAIN_TEST'
} as const;
export type UpdateOwnershipTokensBlockchainDescriptorEnum = typeof UpdateOwnershipTokensBlockchainDescriptorEnum[keyof typeof UpdateOwnershipTokensBlockchainDescriptorEnum];
