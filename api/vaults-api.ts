/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import { convertToFireblocksResponse } from "../response/fireblocksResponse";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { CreateAddressResponse } from '../models';
// @ts-ignore
import { CreateMultipleAccountsRequest } from '../models';
// @ts-ignore
import { CreateVaultAccountAssetAddressRequest } from '../models';
// @ts-ignore
import { CreateVaultAccountAssetRequest } from '../models';
// @ts-ignore
import { CreateVaultAccountRequest } from '../models';
// @ts-ignore
import { CreateVaultAssetResponse } from '../models';
// @ts-ignore
import { ErrorSchema } from '../models';
// @ts-ignore
import { JobCreated } from '../models';
// @ts-ignore
import { PaginatedAddressResponse } from '../models';
// @ts-ignore
import { PaginatedAssetWalletResponse } from '../models';
// @ts-ignore
import { PublicKeyInformation } from '../models';
// @ts-ignore
import { SetAutoFuelForVaultAccountRequest } from '../models';
// @ts-ignore
import { SetCustomerRefIdForVaultAccountRequest } from '../models';
// @ts-ignore
import { UnspentInputsResponse } from '../models';
// @ts-ignore
import { UpdateVaultAccountAssetAddressRequest } from '../models';
// @ts-ignore
import { UpdateVaultAccountRequest } from '../models';
// @ts-ignore
import { VaultAccount } from '../models';
// @ts-ignore
import { VaultAccountsPagedResponse } from '../models';
// @ts-ignore
import { VaultAsset } from '../models';
// @ts-ignore
import { VaultWalletAddress } from '../models';
/**
 * VaultsApi - axios parameter creator
 * @export
 */
export const VaultsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiates activation for a wallet in a vault account.
         * @summary Activate a wallet in a vault account
         * @param {string} vaultAccountId The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAssetForVaultAccount: async (vaultAccountId: string, assetId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('activateAssetForVaultAccount', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('activateAssetForVaultAccount', 'assetId', assetId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/activate`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts an existing segwit address to the legacy format.
         * @summary Convert a segwit address to legacy format
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The segwit address to translate
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLegacyAddress: async (vaultAccountId: string, assetId: string, addressId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('createLegacyAddress', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('createLegacyAddress', 'assetId', assetId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('createLegacyAddress', 'addressId', addressId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/create_legacy`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create multiple vault accounts by running an async job. </br> **Note**: - These endpoints are currently in beta and might be subject to changes. - We limit accounts to 10k per operation and 200k per customer during beta testing. 
         * @summary Bulk creation of new vault accounts
         * @param {CreateMultipleAccountsRequest} createMultipleAccountsRequest 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMultipleAccounts: async (createMultipleAccountsRequest: CreateMultipleAccountsRequest, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMultipleAccountsRequest' is not null or undefined
            assertParamExists('createMultipleAccounts', 'createMultipleAccountsRequest', createMultipleAccountsRequest)
            const localVarPath = `/vault/accounts/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMultipleAccountsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new vault account with the requested name.
         * @summary Create a new vault account
         * @param {CreateVaultAccountRequest} createVaultAccountRequest 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccount: async (createVaultAccountRequest: CreateVaultAccountRequest, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVaultAccountRequest' is not null or undefined
            assertParamExists('createVaultAccount', 'createVaultAccountRequest', createVaultAccountRequest)
            const localVarPath = `/vault/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVaultAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a wallet for a specific asset in a vault account.
         * @summary Create a new wallet
         * @param {string} vaultAccountId The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {CreateVaultAccountAssetRequest} [createVaultAccountAssetRequest] 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccountAsset: async (vaultAccountId: string, assetId: string, createVaultAccountAssetRequest?: CreateVaultAccountAssetRequest, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('createVaultAccountAsset', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('createVaultAccountAsset', 'assetId', assetId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVaultAccountAssetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new deposit address for an asset of a vault account.
         * @summary Create new asset deposit address
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {CreateVaultAccountAssetAddressRequest} [createVaultAccountAssetAddressRequest] 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccountAssetAddress: async (vaultAccountId: string, assetId: string, createVaultAccountAssetAddressRequest?: CreateVaultAccountAssetAddressRequest, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('createVaultAccountAssetAddress', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('createVaultAccountAssetAddress', 'assetId', assetId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/addresses`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVaultAccountAssetAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all asset wallets at all of the vault accounts in your workspace. An asset wallet is an asset at a vault account. This method allows fast traversal of all account balances. 
         * @summary List asset wallets (Paginated)
         * @param {number} [totalAmountLargerThan] When specified, only asset wallets with total balance larger than this amount are returned.
         * @param {string} [assetId] When specified, only asset wallets cross vault accounts that have this asset ID are returned.
         * @param {GetAssetWalletsOrderByEnum} [orderBy] 
         * @param {string} [before] Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page.
         * @param {string} [after] Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page.
         * @param {number} [limit] The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetWallets: async (totalAmountLargerThan?: number, assetId?: string, orderBy?: GetAssetWalletsOrderByEnum, before?: string, after?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vault/asset_wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (totalAmountLargerThan !== undefined) {
                localVarQueryParameter['totalAmountLargerThan'] = totalAmountLargerThan;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['assetId'] = assetId;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.
         * @summary Get the maximum spendable amount in a single transaction.
         * @param {string} vaultAccountId The ID of the vault account, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {boolean} [manualSignging] False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxSpendableAmount: async (vaultAccountId: string, assetId: string, manualSignging?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('getMaxSpendableAmount', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getMaxSpendableAmount', 'assetId', assetId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/max_spendable_amount`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (manualSignging !== undefined) {
                localVarQueryParameter['manualSignging'] = manualSignging;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.
         * @summary List vault accounts (Paginated)
         * @param {string} [namePrefix] 
         * @param {string} [nameSuffix] 
         * @param {number} [minAmountThreshold] Specifying minAmountThreshold will filter accounts with balances greater than this value, otherwise, it will return all accounts.
         * @param {string} [assetId] 
         * @param {GetPagedVaultAccountsOrderByEnum} [orderBy] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPagedVaultAccounts: async (namePrefix?: string, nameSuffix?: string, minAmountThreshold?: number, assetId?: string, orderBy?: GetPagedVaultAccountsOrderByEnum, before?: string, after?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vault/accounts_paged`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namePrefix !== undefined) {
                localVarQueryParameter['namePrefix'] = namePrefix;
            }

            if (nameSuffix !== undefined) {
                localVarQueryParameter['nameSuffix'] = nameSuffix;
            }

            if (minAmountThreshold !== undefined) {
                localVarQueryParameter['minAmountThreshold'] = minAmountThreshold;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['assetId'] = assetId;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the public key information based on derivation path and signing algorithm.
         * @summary Get the public key information
         * @param {string} derivationPath 
         * @param {string} algorithm 
         * @param {boolean} [compressed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyInfo: async (derivationPath: string, algorithm: string, compressed?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'derivationPath' is not null or undefined
            assertParamExists('getPublicKeyInfo', 'derivationPath', derivationPath)
            // verify required parameter 'algorithm' is not null or undefined
            assertParamExists('getPublicKeyInfo', 'algorithm', algorithm)
            const localVarPath = `/vault/public_key_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (derivationPath !== undefined) {
                localVarQueryParameter['derivationPath'] = derivationPath;
            }

            if (algorithm !== undefined) {
                localVarQueryParameter['algorithm'] = algorithm;
            }

            if (compressed !== undefined) {
                localVarQueryParameter['compressed'] = compressed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the public key information for the vault account.
         * @summary Get the public key for a vault account
         * @param {string} vaultAccountId 
         * @param {string} assetId 
         * @param {number} change 
         * @param {number} addressIndex 
         * @param {boolean} [compressed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyInfoForAddress: async (vaultAccountId: string, assetId: string, change: number, addressIndex: number, compressed?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('getPublicKeyInfoForAddress', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getPublicKeyInfoForAddress', 'assetId', assetId)
            // verify required parameter 'change' is not null or undefined
            assertParamExists('getPublicKeyInfoForAddress', 'change', change)
            // verify required parameter 'addressIndex' is not null or undefined
            assertParamExists('getPublicKeyInfoForAddress', 'addressIndex', addressIndex)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/{change}/{addressIndex}/public_key_info`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"change"}}`, encodeURIComponent(String(change)))
                .replace(`{${"addressIndex"}}`, encodeURIComponent(String(addressIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (compressed !== undefined) {
                localVarQueryParameter['compressed'] = compressed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns unspent inputs information of an asset in a vault account.
         * @summary Get UTXO unspent inputs information
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnspentInputs: async (vaultAccountId: string, assetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('getUnspentInputs', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getUnspentInputs', 'assetId', assetId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/unspent_inputs`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the requested vault account.
         * @summary Find a vault account by ID
         * @param {string} vaultAccountId The ID of the vault account to return type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccount: async (vaultAccountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('getVaultAccount', 'vaultAccountId', vaultAccountId)
            const localVarPath = `/vault/accounts/{vaultAccountId}`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a wallet for a specific asset of a vault account.
         * @summary Get the asset balance for a vault account
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccountAsset: async (vaultAccountId: string, assetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('getVaultAccountAsset', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getVaultAccountAsset', 'assetId', assetId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all addresses for specific asset of vault account. - This endpoint will be deprecated on Mar 31,2024. - If your application logic or scripts rely on the deprecated endpoint, you should update to account for GET/V1/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated before Mar 31,2024. - All workspaces created after Mar 31,2024. will have it disabled. If it is disabled for your workspace and you attempt to use it, you will receive the following error message: \"This endpoint is unavailable. - Please use the GET/V1/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated endpoint to return all the wallet addresses associated with the specified vault account and asset in a paginated list. - This API call is subject to rate limits.
         * @summary Get asset addresses
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccountAssetAddresses: async (vaultAccountId: string, assetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('getVaultAccountAssetAddresses', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getVaultAccountAssetAddresses', 'assetId', assetId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/addresses`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated response of the addresses for a given vault account and asset.
         * @summary List addresses (Paginated)
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {number} [limit] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccountAssetAddressesPaginated: async (vaultAccountId: string, assetId: string, limit?: number, before?: string, after?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('getVaultAccountAssetAddressesPaginated', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getVaultAccountAssetAddressesPaginated', 'assetId', assetId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all vault accounts in your workspace.
         * @summary List vault accounts
         * @param {string} [namePrefix] 
         * @param {string} [nameSuffix] 
         * @param {number} [minAmountThreshold] 
         * @param {string} [assetId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccounts: async (namePrefix?: string, nameSuffix?: string, minAmountThreshold?: number, assetId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vault/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namePrefix !== undefined) {
                localVarQueryParameter['namePrefix'] = namePrefix;
            }

            if (nameSuffix !== undefined) {
                localVarQueryParameter['nameSuffix'] = nameSuffix;
            }

            if (minAmountThreshold !== undefined) {
                localVarQueryParameter['minAmountThreshold'] = minAmountThreshold;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['assetId'] = assetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the assets amount summary for all accounts or filtered accounts.
         * @summary Get asset balance for chosen assets
         * @param {string} [accountNamePrefix] 
         * @param {string} [accountNameSuffix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAssets: async (accountNamePrefix?: string, accountNameSuffix?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vault/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountNamePrefix !== undefined) {
                localVarQueryParameter['accountNamePrefix'] = accountNamePrefix;
            }

            if (accountNameSuffix !== undefined) {
                localVarQueryParameter['accountNameSuffix'] = accountNameSuffix;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the vault balance summary for an asset.
         * @summary Get vault balance by asset
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultBalanceByAsset: async (assetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getVaultBalanceByAsset', 'assetId', assetId)
            const localVarPath = `/vault/assets/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Hides the requested vault account from the web console view.
         * @summary Hide a vault account in the console
         * @param {string} vaultAccountId The vault account to hide
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideVaultAccount: async (vaultAccountId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('hideVaultAccount', 'vaultAccountId', vaultAccountId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/hide`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the autofueling property of the vault account to enabled or disabled.
         * @summary Turn autofueling on or off
         * @param {SetAutoFuelForVaultAccountRequest} setAutoFuelForVaultAccountRequest 
         * @param {string} vaultAccountId The vault account ID
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAutoFuelForVaultAccount: async (setAutoFuelForVaultAccountRequest: SetAutoFuelForVaultAccountRequest, vaultAccountId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setAutoFuelForVaultAccountRequest' is not null or undefined
            assertParamExists('setAutoFuelForVaultAccount', 'setAutoFuelForVaultAccountRequest', setAutoFuelForVaultAccountRequest)
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('setAutoFuelForVaultAccount', 'vaultAccountId', vaultAccountId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/set_auto_fuel`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setAutoFuelForVaultAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets an AML/KYT customer reference ID for a specific address.
         * @summary Assign AML customer reference ID
         * @param {SetCustomerRefIdForVaultAccountRequest} setCustomerRefIdForVaultAccountRequest 
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomerRefIdForAddress: async (setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest, vaultAccountId: string, assetId: string, addressId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setCustomerRefIdForVaultAccountRequest' is not null or undefined
            assertParamExists('setCustomerRefIdForAddress', 'setCustomerRefIdForVaultAccountRequest', setCustomerRefIdForVaultAccountRequest)
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('setCustomerRefIdForAddress', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('setCustomerRefIdForAddress', 'assetId', assetId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('setCustomerRefIdForAddress', 'addressId', addressId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/set_customer_ref_id`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setCustomerRefIdForVaultAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assigns an AML/KYT customer reference ID for the vault account.
         * @summary Set an AML/KYT customer reference ID for a vault account
         * @param {SetCustomerRefIdForVaultAccountRequest} setCustomerRefIdForVaultAccountRequest 
         * @param {string} vaultAccountId The vault account ID
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomerRefIdForVaultAccount: async (setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest, vaultAccountId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setCustomerRefIdForVaultAccountRequest' is not null or undefined
            assertParamExists('setCustomerRefIdForVaultAccount', 'setCustomerRefIdForVaultAccountRequest', setCustomerRefIdForVaultAccountRequest)
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('setCustomerRefIdForVaultAccount', 'vaultAccountId', vaultAccountId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/set_customer_ref_id`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setCustomerRefIdForVaultAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Makes a hidden vault account visible in web console view.
         * @summary Unhide a vault account in the console
         * @param {string} vaultAccountId The vault account to unhide
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unhideVaultAccount: async (vaultAccountId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('unhideVaultAccount', 'vaultAccountId', vaultAccountId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/unhide`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Renames the requested vault account.
         * @summary Rename a vault account
         * @param {UpdateVaultAccountRequest} updateVaultAccountRequest 
         * @param {string} vaultAccountId The ID of the vault account to edit
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccount: async (updateVaultAccountRequest: UpdateVaultAccountRequest, vaultAccountId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateVaultAccountRequest' is not null or undefined
            assertParamExists('updateVaultAccount', 'updateVaultAccountRequest', updateVaultAccountRequest)
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('updateVaultAccount', 'vaultAccountId', vaultAccountId)
            const localVarPath = `/vault/accounts/{vaultAccountId}`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVaultAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the description of an existing address of an asset in a vault account.
         * @summary Update address description
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
         * @param {UpdateVaultAccountAssetAddressRequest} [updateVaultAccountAssetAddressRequest] 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccountAssetAddress: async (vaultAccountId: string, assetId: string, addressId: string, updateVaultAccountAssetAddressRequest?: UpdateVaultAccountAssetAddressRequest, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('updateVaultAccountAssetAddress', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('updateVaultAccountAssetAddress', 'assetId', assetId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('updateVaultAccountAssetAddress', 'addressId', addressId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVaultAccountAssetAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the balance of a specific asset in a vault account.
         * @summary Refresh asset balance data
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {object} [body] 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccountAssetBalance: async (vaultAccountId: string, assetId: string, body?: object, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('updateVaultAccountAssetBalance', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('updateVaultAccountAssetBalance', 'assetId', assetId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/balance`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VaultsApi - functional programming interface
 * @export
 */
export const VaultsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VaultsApiAxiosParamCreator(configuration)
    return {
        /**
         * Initiates activation for a wallet in a vault account.
         * @summary Activate a wallet in a vault account
         * @param {string} vaultAccountId The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateAssetForVaultAccount(vaultAccountId: string, assetId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVaultAssetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateAssetForVaultAccount(vaultAccountId, assetId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.activateAssetForVaultAccount']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Converts an existing segwit address to the legacy format.
         * @summary Convert a segwit address to legacy format
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The segwit address to translate
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLegacyAddress(vaultAccountId: string, assetId: string, addressId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLegacyAddress(vaultAccountId, assetId, addressId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.createLegacyAddress']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create multiple vault accounts by running an async job. </br> **Note**: - These endpoints are currently in beta and might be subject to changes. - We limit accounts to 10k per operation and 200k per customer during beta testing. 
         * @summary Bulk creation of new vault accounts
         * @param {CreateMultipleAccountsRequest} createMultipleAccountsRequest 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMultipleAccounts(createMultipleAccountsRequest: CreateMultipleAccountsRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobCreated>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMultipleAccounts(createMultipleAccountsRequest, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.createMultipleAccounts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a new vault account with the requested name.
         * @summary Create a new vault account
         * @param {CreateVaultAccountRequest} createVaultAccountRequest 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVaultAccount(createVaultAccountRequest: CreateVaultAccountRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVaultAccount(createVaultAccountRequest, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.createVaultAccount']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a wallet for a specific asset in a vault account.
         * @summary Create a new wallet
         * @param {string} vaultAccountId The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {CreateVaultAccountAssetRequest} [createVaultAccountAssetRequest] 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVaultAccountAsset(vaultAccountId: string, assetId: string, createVaultAccountAssetRequest?: CreateVaultAccountAssetRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVaultAssetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVaultAccountAsset(vaultAccountId, assetId, createVaultAccountAssetRequest, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.createVaultAccountAsset']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a new deposit address for an asset of a vault account.
         * @summary Create new asset deposit address
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {CreateVaultAccountAssetAddressRequest} [createVaultAccountAssetAddressRequest] 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVaultAccountAssetAddress(vaultAccountId: string, assetId: string, createVaultAccountAssetAddressRequest?: CreateVaultAccountAssetAddressRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVaultAccountAssetAddress(vaultAccountId, assetId, createVaultAccountAssetAddressRequest, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.createVaultAccountAssetAddress']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Gets all asset wallets at all of the vault accounts in your workspace. An asset wallet is an asset at a vault account. This method allows fast traversal of all account balances. 
         * @summary List asset wallets (Paginated)
         * @param {number} [totalAmountLargerThan] When specified, only asset wallets with total balance larger than this amount are returned.
         * @param {string} [assetId] When specified, only asset wallets cross vault accounts that have this asset ID are returned.
         * @param {GetAssetWalletsOrderByEnum} [orderBy] 
         * @param {string} [before] Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page.
         * @param {string} [after] Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page.
         * @param {number} [limit] The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetWallets(totalAmountLargerThan?: number, assetId?: string, orderBy?: GetAssetWalletsOrderByEnum, before?: string, after?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAssetWalletResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetWallets(totalAmountLargerThan, assetId, orderBy, before, after, limit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.getAssetWallets']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.
         * @summary Get the maximum spendable amount in a single transaction.
         * @param {string} vaultAccountId The ID of the vault account, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {boolean} [manualSignging] False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaxSpendableAmount(vaultAccountId: string, assetId: string, manualSignging?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaxSpendableAmount(vaultAccountId, assetId, manualSignging, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.getMaxSpendableAmount']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.
         * @summary List vault accounts (Paginated)
         * @param {string} [namePrefix] 
         * @param {string} [nameSuffix] 
         * @param {number} [minAmountThreshold] Specifying minAmountThreshold will filter accounts with balances greater than this value, otherwise, it will return all accounts.
         * @param {string} [assetId] 
         * @param {GetPagedVaultAccountsOrderByEnum} [orderBy] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPagedVaultAccounts(namePrefix?: string, nameSuffix?: string, minAmountThreshold?: number, assetId?: string, orderBy?: GetPagedVaultAccountsOrderByEnum, before?: string, after?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultAccountsPagedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPagedVaultAccounts(namePrefix, nameSuffix, minAmountThreshold, assetId, orderBy, before, after, limit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.getPagedVaultAccounts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Gets the public key information based on derivation path and signing algorithm.
         * @summary Get the public key information
         * @param {string} derivationPath 
         * @param {string} algorithm 
         * @param {boolean} [compressed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeyInfo(derivationPath: string, algorithm: string, compressed?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeyInfo(derivationPath, algorithm, compressed, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.getPublicKeyInfo']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Gets the public key information for the vault account.
         * @summary Get the public key for a vault account
         * @param {string} vaultAccountId 
         * @param {string} assetId 
         * @param {number} change 
         * @param {number} addressIndex 
         * @param {boolean} [compressed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeyInfoForAddress(vaultAccountId: string, assetId: string, change: number, addressIndex: number, compressed?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeyInfoForAddress(vaultAccountId, assetId, change, addressIndex, compressed, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.getPublicKeyInfoForAddress']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns unspent inputs information of an asset in a vault account.
         * @summary Get UTXO unspent inputs information
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnspentInputs(vaultAccountId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UnspentInputsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnspentInputs(vaultAccountId, assetId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.getUnspentInputs']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns the requested vault account.
         * @summary Find a vault account by ID
         * @param {string} vaultAccountId The ID of the vault account to return type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVaultAccount(vaultAccountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVaultAccount(vaultAccountId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.getVaultAccount']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns a wallet for a specific asset of a vault account.
         * @summary Get the asset balance for a vault account
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVaultAccountAsset(vaultAccountId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVaultAccountAsset(vaultAccountId, assetId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.getVaultAccountAsset']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Lists all addresses for specific asset of vault account. - This endpoint will be deprecated on Mar 31,2024. - If your application logic or scripts rely on the deprecated endpoint, you should update to account for GET/V1/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated before Mar 31,2024. - All workspaces created after Mar 31,2024. will have it disabled. If it is disabled for your workspace and you attempt to use it, you will receive the following error message: \"This endpoint is unavailable. - Please use the GET/V1/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated endpoint to return all the wallet addresses associated with the specified vault account and asset in a paginated list. - This API call is subject to rate limits.
         * @summary Get asset addresses
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVaultAccountAssetAddresses(vaultAccountId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VaultWalletAddress>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVaultAccountAssetAddresses(vaultAccountId, assetId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.getVaultAccountAssetAddresses']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns a paginated response of the addresses for a given vault account and asset.
         * @summary List addresses (Paginated)
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {number} [limit] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVaultAccountAssetAddressesPaginated(vaultAccountId: string, assetId: string, limit?: number, before?: string, after?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVaultAccountAssetAddressesPaginated(vaultAccountId, assetId, limit, before, after, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.getVaultAccountAssetAddressesPaginated']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Gets all vault accounts in your workspace.
         * @summary List vault accounts
         * @param {string} [namePrefix] 
         * @param {string} [nameSuffix] 
         * @param {number} [minAmountThreshold] 
         * @param {string} [assetId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVaultAccounts(namePrefix?: string, nameSuffix?: string, minAmountThreshold?: number, assetId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VaultAccount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVaultAccounts(namePrefix, nameSuffix, minAmountThreshold, assetId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.getVaultAccounts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Gets the assets amount summary for all accounts or filtered accounts.
         * @summary Get asset balance for chosen assets
         * @param {string} [accountNamePrefix] 
         * @param {string} [accountNameSuffix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVaultAssets(accountNamePrefix?: string, accountNameSuffix?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VaultAsset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVaultAssets(accountNamePrefix, accountNameSuffix, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.getVaultAssets']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Gets the vault balance summary for an asset.
         * @summary Get vault balance by asset
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVaultBalanceByAsset(assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVaultBalanceByAsset(assetId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.getVaultBalanceByAsset']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Hides the requested vault account from the web console view.
         * @summary Hide a vault account in the console
         * @param {string} vaultAccountId The vault account to hide
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hideVaultAccount(vaultAccountId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hideVaultAccount(vaultAccountId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.hideVaultAccount']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Sets the autofueling property of the vault account to enabled or disabled.
         * @summary Turn autofueling on or off
         * @param {SetAutoFuelForVaultAccountRequest} setAutoFuelForVaultAccountRequest 
         * @param {string} vaultAccountId The vault account ID
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAutoFuelForVaultAccount(setAutoFuelForVaultAccountRequest: SetAutoFuelForVaultAccountRequest, vaultAccountId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAutoFuelForVaultAccount(setAutoFuelForVaultAccountRequest, vaultAccountId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.setAutoFuelForVaultAccount']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Sets an AML/KYT customer reference ID for a specific address.
         * @summary Assign AML customer reference ID
         * @param {SetCustomerRefIdForVaultAccountRequest} setCustomerRefIdForVaultAccountRequest 
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCustomerRefIdForAddress(setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest, vaultAccountId: string, assetId: string, addressId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCustomerRefIdForAddress(setCustomerRefIdForVaultAccountRequest, vaultAccountId, assetId, addressId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.setCustomerRefIdForAddress']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Assigns an AML/KYT customer reference ID for the vault account.
         * @summary Set an AML/KYT customer reference ID for a vault account
         * @param {SetCustomerRefIdForVaultAccountRequest} setCustomerRefIdForVaultAccountRequest 
         * @param {string} vaultAccountId The vault account ID
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCustomerRefIdForVaultAccount(setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest, vaultAccountId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCustomerRefIdForVaultAccount(setCustomerRefIdForVaultAccountRequest, vaultAccountId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.setCustomerRefIdForVaultAccount']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Makes a hidden vault account visible in web console view.
         * @summary Unhide a vault account in the console
         * @param {string} vaultAccountId The vault account to unhide
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unhideVaultAccount(vaultAccountId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unhideVaultAccount(vaultAccountId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.unhideVaultAccount']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Renames the requested vault account.
         * @summary Rename a vault account
         * @param {UpdateVaultAccountRequest} updateVaultAccountRequest 
         * @param {string} vaultAccountId The ID of the vault account to edit
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVaultAccount(updateVaultAccountRequest: UpdateVaultAccountRequest, vaultAccountId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVaultAccount(updateVaultAccountRequest, vaultAccountId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.updateVaultAccount']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates the description of an existing address of an asset in a vault account.
         * @summary Update address description
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
         * @param {UpdateVaultAccountAssetAddressRequest} [updateVaultAccountAssetAddressRequest] 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVaultAccountAssetAddress(vaultAccountId: string, assetId: string, addressId: string, updateVaultAccountAssetAddressRequest?: UpdateVaultAccountAssetAddressRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVaultAccountAssetAddress(vaultAccountId, assetId, addressId, updateVaultAccountAssetAddressRequest, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.updateVaultAccountAssetAddress']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Updates the balance of a specific asset in a vault account.
         * @summary Refresh asset balance data
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {object} [body] 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVaultAccountAssetBalance(vaultAccountId: string, assetId: string, body?: object, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVaultAccountAssetBalance(vaultAccountId, assetId, body, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VaultsApi.updateVaultAccountAssetBalance']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * VaultsApi - factory interface
 * @export
 */
export const VaultsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VaultsApiFp(configuration)
    return {
        /**
         * Initiates activation for a wallet in a vault account.
         * @summary Activate a wallet in a vault account
         * @param {VaultsApiActivateAssetForVaultAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAssetForVaultAccount(requestParameters: VaultsApiActivateAssetForVaultAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateVaultAssetResponse> {
            return localVarFp.activateAssetForVaultAccount(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Converts an existing segwit address to the legacy format.
         * @summary Convert a segwit address to legacy format
         * @param {VaultsApiCreateLegacyAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLegacyAddress(requestParameters: VaultsApiCreateLegacyAddressRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateAddressResponse> {
            return localVarFp.createLegacyAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.addressId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create multiple vault accounts by running an async job. </br> **Note**: - These endpoints are currently in beta and might be subject to changes. - We limit accounts to 10k per operation and 200k per customer during beta testing. 
         * @summary Bulk creation of new vault accounts
         * @param {VaultsApiCreateMultipleAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMultipleAccounts(requestParameters: VaultsApiCreateMultipleAccountsRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobCreated> {
            return localVarFp.createMultipleAccounts(requestParameters.createMultipleAccountsRequest, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new vault account with the requested name.
         * @summary Create a new vault account
         * @param {VaultsApiCreateVaultAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccount(requestParameters: VaultsApiCreateVaultAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<VaultAccount> {
            return localVarFp.createVaultAccount(requestParameters.createVaultAccountRequest, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a wallet for a specific asset in a vault account.
         * @summary Create a new wallet
         * @param {VaultsApiCreateVaultAccountAssetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccountAsset(requestParameters: VaultsApiCreateVaultAccountAssetRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateVaultAssetResponse> {
            return localVarFp.createVaultAccountAsset(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.createVaultAccountAssetRequest, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new deposit address for an asset of a vault account.
         * @summary Create new asset deposit address
         * @param {VaultsApiCreateVaultAccountAssetAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccountAssetAddress(requestParameters: VaultsApiCreateVaultAccountAssetAddressRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateAddressResponse> {
            return localVarFp.createVaultAccountAssetAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.createVaultAccountAssetAddressRequest, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all asset wallets at all of the vault accounts in your workspace. An asset wallet is an asset at a vault account. This method allows fast traversal of all account balances. 
         * @summary List asset wallets (Paginated)
         * @param {VaultsApiGetAssetWalletsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetWallets(requestParameters: VaultsApiGetAssetWalletsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAssetWalletResponse> {
            return localVarFp.getAssetWallets(requestParameters.totalAmountLargerThan, requestParameters.assetId, requestParameters.orderBy, requestParameters.before, requestParameters.after, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.
         * @summary Get the maximum spendable amount in a single transaction.
         * @param {VaultsApiGetMaxSpendableAmountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxSpendableAmount(requestParameters: VaultsApiGetMaxSpendableAmountRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getMaxSpendableAmount(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.manualSignging, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.
         * @summary List vault accounts (Paginated)
         * @param {VaultsApiGetPagedVaultAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPagedVaultAccounts(requestParameters: VaultsApiGetPagedVaultAccountsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<VaultAccountsPagedResponse> {
            return localVarFp.getPagedVaultAccounts(requestParameters.namePrefix, requestParameters.nameSuffix, requestParameters.minAmountThreshold, requestParameters.assetId, requestParameters.orderBy, requestParameters.before, requestParameters.after, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the public key information based on derivation path and signing algorithm.
         * @summary Get the public key information
         * @param {VaultsApiGetPublicKeyInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyInfo(requestParameters: VaultsApiGetPublicKeyInfoRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublicKeyInformation> {
            return localVarFp.getPublicKeyInfo(requestParameters.derivationPath, requestParameters.algorithm, requestParameters.compressed, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the public key information for the vault account.
         * @summary Get the public key for a vault account
         * @param {VaultsApiGetPublicKeyInfoForAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyInfoForAddress(requestParameters: VaultsApiGetPublicKeyInfoForAddressRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublicKeyInformation> {
            return localVarFp.getPublicKeyInfoForAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.change, requestParameters.addressIndex, requestParameters.compressed, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns unspent inputs information of an asset in a vault account.
         * @summary Get UTXO unspent inputs information
         * @param {VaultsApiGetUnspentInputsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnspentInputs(requestParameters: VaultsApiGetUnspentInputsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UnspentInputsResponse>> {
            return localVarFp.getUnspentInputs(requestParameters.vaultAccountId, requestParameters.assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the requested vault account.
         * @summary Find a vault account by ID
         * @param {VaultsApiGetVaultAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccount(requestParameters: VaultsApiGetVaultAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<VaultAccount> {
            return localVarFp.getVaultAccount(requestParameters.vaultAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a wallet for a specific asset of a vault account.
         * @summary Get the asset balance for a vault account
         * @param {VaultsApiGetVaultAccountAssetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccountAsset(requestParameters: VaultsApiGetVaultAccountAssetRequest, options?: RawAxiosRequestConfig): AxiosPromise<VaultAsset> {
            return localVarFp.getVaultAccountAsset(requestParameters.vaultAccountId, requestParameters.assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all addresses for specific asset of vault account. - This endpoint will be deprecated on Mar 31,2024. - If your application logic or scripts rely on the deprecated endpoint, you should update to account for GET/V1/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated before Mar 31,2024. - All workspaces created after Mar 31,2024. will have it disabled. If it is disabled for your workspace and you attempt to use it, you will receive the following error message: \"This endpoint is unavailable. - Please use the GET/V1/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated endpoint to return all the wallet addresses associated with the specified vault account and asset in a paginated list. - This API call is subject to rate limits.
         * @summary Get asset addresses
         * @param {VaultsApiGetVaultAccountAssetAddressesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccountAssetAddresses(requestParameters: VaultsApiGetVaultAccountAssetAddressesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<VaultWalletAddress>> {
            return localVarFp.getVaultAccountAssetAddresses(requestParameters.vaultAccountId, requestParameters.assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated response of the addresses for a given vault account and asset.
         * @summary List addresses (Paginated)
         * @param {VaultsApiGetVaultAccountAssetAddressesPaginatedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccountAssetAddressesPaginated(requestParameters: VaultsApiGetVaultAccountAssetAddressesPaginatedRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAddressResponse> {
            return localVarFp.getVaultAccountAssetAddressesPaginated(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.limit, requestParameters.before, requestParameters.after, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all vault accounts in your workspace.
         * @summary List vault accounts
         * @param {VaultsApiGetVaultAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccounts(requestParameters: VaultsApiGetVaultAccountsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<VaultAccount>> {
            return localVarFp.getVaultAccounts(requestParameters.namePrefix, requestParameters.nameSuffix, requestParameters.minAmountThreshold, requestParameters.assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the assets amount summary for all accounts or filtered accounts.
         * @summary Get asset balance for chosen assets
         * @param {VaultsApiGetVaultAssetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAssets(requestParameters: VaultsApiGetVaultAssetsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<VaultAsset>> {
            return localVarFp.getVaultAssets(requestParameters.accountNamePrefix, requestParameters.accountNameSuffix, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the vault balance summary for an asset.
         * @summary Get vault balance by asset
         * @param {VaultsApiGetVaultBalanceByAssetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultBalanceByAsset(requestParameters: VaultsApiGetVaultBalanceByAssetRequest, options?: RawAxiosRequestConfig): AxiosPromise<VaultAsset> {
            return localVarFp.getVaultBalanceByAsset(requestParameters.assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Hides the requested vault account from the web console view.
         * @summary Hide a vault account in the console
         * @param {VaultsApiHideVaultAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideVaultAccount(requestParameters: VaultsApiHideVaultAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.hideVaultAccount(requestParameters.vaultAccountId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the autofueling property of the vault account to enabled or disabled.
         * @summary Turn autofueling on or off
         * @param {VaultsApiSetAutoFuelForVaultAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAutoFuelForVaultAccount(requestParameters: VaultsApiSetAutoFuelForVaultAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setAutoFuelForVaultAccount(requestParameters.setAutoFuelForVaultAccountRequest, requestParameters.vaultAccountId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets an AML/KYT customer reference ID for a specific address.
         * @summary Assign AML customer reference ID
         * @param {VaultsApiSetCustomerRefIdForAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomerRefIdForAddress(requestParameters: VaultsApiSetCustomerRefIdForAddressRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setCustomerRefIdForAddress(requestParameters.setCustomerRefIdForVaultAccountRequest, requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.addressId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Assigns an AML/KYT customer reference ID for the vault account.
         * @summary Set an AML/KYT customer reference ID for a vault account
         * @param {VaultsApiSetCustomerRefIdForVaultAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomerRefIdForVaultAccount(requestParameters: VaultsApiSetCustomerRefIdForVaultAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setCustomerRefIdForVaultAccount(requestParameters.setCustomerRefIdForVaultAccountRequest, requestParameters.vaultAccountId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Makes a hidden vault account visible in web console view.
         * @summary Unhide a vault account in the console
         * @param {VaultsApiUnhideVaultAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unhideVaultAccount(requestParameters: VaultsApiUnhideVaultAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unhideVaultAccount(requestParameters.vaultAccountId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Renames the requested vault account.
         * @summary Rename a vault account
         * @param {VaultsApiUpdateVaultAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccount(requestParameters: VaultsApiUpdateVaultAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateVaultAccount(requestParameters.updateVaultAccountRequest, requestParameters.vaultAccountId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the description of an existing address of an asset in a vault account.
         * @summary Update address description
         * @param {VaultsApiUpdateVaultAccountAssetAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccountAssetAddress(requestParameters: VaultsApiUpdateVaultAccountAssetAddressRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateVaultAccountAssetAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.addressId, requestParameters.updateVaultAccountAssetAddressRequest, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the balance of a specific asset in a vault account.
         * @summary Refresh asset balance data
         * @param {VaultsApiUpdateVaultAccountAssetBalanceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccountAssetBalance(requestParameters: VaultsApiUpdateVaultAccountAssetBalanceRequest, options?: RawAxiosRequestConfig): AxiosPromise<VaultAsset> {
            return localVarFp.updateVaultAccountAssetBalance(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.body, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for activateAssetForVaultAccount operation in VaultsApi.
 * @export
 * @interface VaultsApiActivateAssetForVaultAccountRequest
 */
export interface VaultsApiActivateAssetForVaultAccountRequest {
    /**
     * The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
     * @type {string}
     * @memberof VaultsApiActivateAssetForVaultAccount
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiActivateAssetForVaultAccount
     */
    readonly assetId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof VaultsApiActivateAssetForVaultAccount
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for createLegacyAddress operation in VaultsApi.
 * @export
 * @interface VaultsApiCreateLegacyAddressRequest
 */
export interface VaultsApiCreateLegacyAddressRequest {
    /**
     * The ID of the vault account
     * @type {string}
     * @memberof VaultsApiCreateLegacyAddress
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiCreateLegacyAddress
     */
    readonly assetId: string

    /**
     * The segwit address to translate
     * @type {string}
     * @memberof VaultsApiCreateLegacyAddress
     */
    readonly addressId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof VaultsApiCreateLegacyAddress
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for createMultipleAccounts operation in VaultsApi.
 * @export
 * @interface VaultsApiCreateMultipleAccountsRequest
 */
export interface VaultsApiCreateMultipleAccountsRequest {
    /**
     * 
     * @type {CreateMultipleAccountsRequest}
     * @memberof VaultsApiCreateMultipleAccounts
     */
    readonly createMultipleAccountsRequest: CreateMultipleAccountsRequest

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof VaultsApiCreateMultipleAccounts
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for createVaultAccount operation in VaultsApi.
 * @export
 * @interface VaultsApiCreateVaultAccountRequest
 */
export interface VaultsApiCreateVaultAccountRequest {
    /**
     * 
     * @type {CreateVaultAccountRequest}
     * @memberof VaultsApiCreateVaultAccount
     */
    readonly createVaultAccountRequest: CreateVaultAccountRequest

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof VaultsApiCreateVaultAccount
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for createVaultAccountAsset operation in VaultsApi.
 * @export
 * @interface VaultsApiCreateVaultAccountAssetRequest
 */
export interface VaultsApiCreateVaultAccountAssetRequest {
    /**
     * The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
     * @type {string}
     * @memberof VaultsApiCreateVaultAccountAsset
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiCreateVaultAccountAsset
     */
    readonly assetId: string

    /**
     * 
     * @type {CreateVaultAccountAssetRequest}
     * @memberof VaultsApiCreateVaultAccountAsset
     */
    readonly createVaultAccountAssetRequest?: CreateVaultAccountAssetRequest

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof VaultsApiCreateVaultAccountAsset
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for createVaultAccountAssetAddress operation in VaultsApi.
 * @export
 * @interface VaultsApiCreateVaultAccountAssetAddressRequest
 */
export interface VaultsApiCreateVaultAccountAssetAddressRequest {
    /**
     * The ID of the vault account to return
     * @type {string}
     * @memberof VaultsApiCreateVaultAccountAssetAddress
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiCreateVaultAccountAssetAddress
     */
    readonly assetId: string

    /**
     * 
     * @type {CreateVaultAccountAssetAddressRequest}
     * @memberof VaultsApiCreateVaultAccountAssetAddress
     */
    readonly createVaultAccountAssetAddressRequest?: CreateVaultAccountAssetAddressRequest

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof VaultsApiCreateVaultAccountAssetAddress
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for getAssetWallets operation in VaultsApi.
 * @export
 * @interface VaultsApiGetAssetWalletsRequest
 */
export interface VaultsApiGetAssetWalletsRequest {
    /**
     * When specified, only asset wallets with total balance larger than this amount are returned.
     * @type {number}
     * @memberof VaultsApiGetAssetWallets
     */
    readonly totalAmountLargerThan?: number

    /**
     * When specified, only asset wallets cross vault accounts that have this asset ID are returned.
     * @type {string}
     * @memberof VaultsApiGetAssetWallets
     */
    readonly assetId?: string

    /**
     * 
     * @type {'ASC' | 'DESC'}
     * @memberof VaultsApiGetAssetWallets
     */
    readonly orderBy?: GetAssetWalletsOrderByEnum

    /**
     * Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page.
     * @type {string}
     * @memberof VaultsApiGetAssetWallets
     */
    readonly before?: string

    /**
     * Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page.
     * @type {string}
     * @memberof VaultsApiGetAssetWallets
     */
    readonly after?: string

    /**
     * The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000.
     * @type {number}
     * @memberof VaultsApiGetAssetWallets
     */
    readonly limit?: number
}

/**
 * Request parameters for getMaxSpendableAmount operation in VaultsApi.
 * @export
 * @interface VaultsApiGetMaxSpendableAmountRequest
 */
export interface VaultsApiGetMaxSpendableAmountRequest {
    /**
     * The ID of the vault account, or \&#39;default\&#39; for the default vault account
     * @type {string}
     * @memberof VaultsApiGetMaxSpendableAmount
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiGetMaxSpendableAmount
     */
    readonly assetId: string

    /**
     * False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device.
     * @type {boolean}
     * @memberof VaultsApiGetMaxSpendableAmount
     */
    readonly manualSignging?: boolean
}

/**
 * Request parameters for getPagedVaultAccounts operation in VaultsApi.
 * @export
 * @interface VaultsApiGetPagedVaultAccountsRequest
 */
export interface VaultsApiGetPagedVaultAccountsRequest {
    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly namePrefix?: string

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly nameSuffix?: string

    /**
     * Specifying minAmountThreshold will filter accounts with balances greater than this value, otherwise, it will return all accounts.
     * @type {number}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly minAmountThreshold?: number

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly assetId?: string

    /**
     * 
     * @type {'ASC' | 'DESC'}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly orderBy?: GetPagedVaultAccountsOrderByEnum

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly after?: string

    /**
     * 
     * @type {number}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly limit?: number
}

/**
 * Request parameters for getPublicKeyInfo operation in VaultsApi.
 * @export
 * @interface VaultsApiGetPublicKeyInfoRequest
 */
export interface VaultsApiGetPublicKeyInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPublicKeyInfo
     */
    readonly derivationPath: string

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPublicKeyInfo
     */
    readonly algorithm: string

    /**
     * 
     * @type {boolean}
     * @memberof VaultsApiGetPublicKeyInfo
     */
    readonly compressed?: boolean
}

/**
 * Request parameters for getPublicKeyInfoForAddress operation in VaultsApi.
 * @export
 * @interface VaultsApiGetPublicKeyInfoForAddressRequest
 */
export interface VaultsApiGetPublicKeyInfoForAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPublicKeyInfoForAddress
     */
    readonly vaultAccountId: string

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPublicKeyInfoForAddress
     */
    readonly assetId: string

    /**
     * 
     * @type {number}
     * @memberof VaultsApiGetPublicKeyInfoForAddress
     */
    readonly change: number

    /**
     * 
     * @type {number}
     * @memberof VaultsApiGetPublicKeyInfoForAddress
     */
    readonly addressIndex: number

    /**
     * 
     * @type {boolean}
     * @memberof VaultsApiGetPublicKeyInfoForAddress
     */
    readonly compressed?: boolean
}

/**
 * Request parameters for getUnspentInputs operation in VaultsApi.
 * @export
 * @interface VaultsApiGetUnspentInputsRequest
 */
export interface VaultsApiGetUnspentInputsRequest {
    /**
     * The ID of the vault account
     * @type {string}
     * @memberof VaultsApiGetUnspentInputs
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiGetUnspentInputs
     */
    readonly assetId: string
}

/**
 * Request parameters for getVaultAccount operation in VaultsApi.
 * @export
 * @interface VaultsApiGetVaultAccountRequest
 */
export interface VaultsApiGetVaultAccountRequest {
    /**
     * The ID of the vault account to return type: string
     * @type {string}
     * @memberof VaultsApiGetVaultAccount
     */
    readonly vaultAccountId: string
}

/**
 * Request parameters for getVaultAccountAsset operation in VaultsApi.
 * @export
 * @interface VaultsApiGetVaultAccountAssetRequest
 */
export interface VaultsApiGetVaultAccountAssetRequest {
    /**
     * The ID of the vault account to return
     * @type {string}
     * @memberof VaultsApiGetVaultAccountAsset
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiGetVaultAccountAsset
     */
    readonly assetId: string
}

/**
 * Request parameters for getVaultAccountAssetAddresses operation in VaultsApi.
 * @export
 * @interface VaultsApiGetVaultAccountAssetAddressesRequest
 */
export interface VaultsApiGetVaultAccountAssetAddressesRequest {
    /**
     * The ID of the vault account to return
     * @type {string}
     * @memberof VaultsApiGetVaultAccountAssetAddresses
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiGetVaultAccountAssetAddresses
     */
    readonly assetId: string
}

/**
 * Request parameters for getVaultAccountAssetAddressesPaginated operation in VaultsApi.
 * @export
 * @interface VaultsApiGetVaultAccountAssetAddressesPaginatedRequest
 */
export interface VaultsApiGetVaultAccountAssetAddressesPaginatedRequest {
    /**
     * The ID of the vault account to return
     * @type {string}
     * @memberof VaultsApiGetVaultAccountAssetAddressesPaginated
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiGetVaultAccountAssetAddressesPaginated
     */
    readonly assetId: string

    /**
     * 
     * @type {number}
     * @memberof VaultsApiGetVaultAccountAssetAddressesPaginated
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetVaultAccountAssetAddressesPaginated
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetVaultAccountAssetAddressesPaginated
     */
    readonly after?: string
}

/**
 * Request parameters for getVaultAccounts operation in VaultsApi.
 * @export
 * @interface VaultsApiGetVaultAccountsRequest
 */
export interface VaultsApiGetVaultAccountsRequest {
    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetVaultAccounts
     */
    readonly namePrefix?: string

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetVaultAccounts
     */
    readonly nameSuffix?: string

    /**
     * 
     * @type {number}
     * @memberof VaultsApiGetVaultAccounts
     */
    readonly minAmountThreshold?: number

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetVaultAccounts
     */
    readonly assetId?: string
}

/**
 * Request parameters for getVaultAssets operation in VaultsApi.
 * @export
 * @interface VaultsApiGetVaultAssetsRequest
 */
export interface VaultsApiGetVaultAssetsRequest {
    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetVaultAssets
     */
    readonly accountNamePrefix?: string

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetVaultAssets
     */
    readonly accountNameSuffix?: string
}

/**
 * Request parameters for getVaultBalanceByAsset operation in VaultsApi.
 * @export
 * @interface VaultsApiGetVaultBalanceByAssetRequest
 */
export interface VaultsApiGetVaultBalanceByAssetRequest {
    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetVaultBalanceByAsset
     */
    readonly assetId: string
}

/**
 * Request parameters for hideVaultAccount operation in VaultsApi.
 * @export
 * @interface VaultsApiHideVaultAccountRequest
 */
export interface VaultsApiHideVaultAccountRequest {
    /**
     * The vault account to hide
     * @type {string}
     * @memberof VaultsApiHideVaultAccount
     */
    readonly vaultAccountId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof VaultsApiHideVaultAccount
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for setAutoFuelForVaultAccount operation in VaultsApi.
 * @export
 * @interface VaultsApiSetAutoFuelForVaultAccountRequest
 */
export interface VaultsApiSetAutoFuelForVaultAccountRequest {
    /**
     * 
     * @type {SetAutoFuelForVaultAccountRequest}
     * @memberof VaultsApiSetAutoFuelForVaultAccount
     */
    readonly setAutoFuelForVaultAccountRequest: SetAutoFuelForVaultAccountRequest

    /**
     * The vault account ID
     * @type {string}
     * @memberof VaultsApiSetAutoFuelForVaultAccount
     */
    readonly vaultAccountId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof VaultsApiSetAutoFuelForVaultAccount
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for setCustomerRefIdForAddress operation in VaultsApi.
 * @export
 * @interface VaultsApiSetCustomerRefIdForAddressRequest
 */
export interface VaultsApiSetCustomerRefIdForAddressRequest {
    /**
     * 
     * @type {SetCustomerRefIdForVaultAccountRequest}
     * @memberof VaultsApiSetCustomerRefIdForAddress
     */
    readonly setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest

    /**
     * The ID of the vault account
     * @type {string}
     * @memberof VaultsApiSetCustomerRefIdForAddress
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiSetCustomerRefIdForAddress
     */
    readonly assetId: string

    /**
     * The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
     * @type {string}
     * @memberof VaultsApiSetCustomerRefIdForAddress
     */
    readonly addressId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof VaultsApiSetCustomerRefIdForAddress
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for setCustomerRefIdForVaultAccount operation in VaultsApi.
 * @export
 * @interface VaultsApiSetCustomerRefIdForVaultAccountRequest
 */
export interface VaultsApiSetCustomerRefIdForVaultAccountRequest {
    /**
     * 
     * @type {SetCustomerRefIdForVaultAccountRequest}
     * @memberof VaultsApiSetCustomerRefIdForVaultAccount
     */
    readonly setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest

    /**
     * The vault account ID
     * @type {string}
     * @memberof VaultsApiSetCustomerRefIdForVaultAccount
     */
    readonly vaultAccountId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof VaultsApiSetCustomerRefIdForVaultAccount
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for unhideVaultAccount operation in VaultsApi.
 * @export
 * @interface VaultsApiUnhideVaultAccountRequest
 */
export interface VaultsApiUnhideVaultAccountRequest {
    /**
     * The vault account to unhide
     * @type {string}
     * @memberof VaultsApiUnhideVaultAccount
     */
    readonly vaultAccountId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof VaultsApiUnhideVaultAccount
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for updateVaultAccount operation in VaultsApi.
 * @export
 * @interface VaultsApiUpdateVaultAccountRequest
 */
export interface VaultsApiUpdateVaultAccountRequest {
    /**
     * 
     * @type {UpdateVaultAccountRequest}
     * @memberof VaultsApiUpdateVaultAccount
     */
    readonly updateVaultAccountRequest: UpdateVaultAccountRequest

    /**
     * The ID of the vault account to edit
     * @type {string}
     * @memberof VaultsApiUpdateVaultAccount
     */
    readonly vaultAccountId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof VaultsApiUpdateVaultAccount
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for updateVaultAccountAssetAddress operation in VaultsApi.
 * @export
 * @interface VaultsApiUpdateVaultAccountAssetAddressRequest
 */
export interface VaultsApiUpdateVaultAccountAssetAddressRequest {
    /**
     * The ID of the vault account
     * @type {string}
     * @memberof VaultsApiUpdateVaultAccountAssetAddress
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiUpdateVaultAccountAssetAddress
     */
    readonly assetId: string

    /**
     * The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
     * @type {string}
     * @memberof VaultsApiUpdateVaultAccountAssetAddress
     */
    readonly addressId: string

    /**
     * 
     * @type {UpdateVaultAccountAssetAddressRequest}
     * @memberof VaultsApiUpdateVaultAccountAssetAddress
     */
    readonly updateVaultAccountAssetAddressRequest?: UpdateVaultAccountAssetAddressRequest

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof VaultsApiUpdateVaultAccountAssetAddress
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for updateVaultAccountAssetBalance operation in VaultsApi.
 * @export
 * @interface VaultsApiUpdateVaultAccountAssetBalanceRequest
 */
export interface VaultsApiUpdateVaultAccountAssetBalanceRequest {
    /**
     * The ID of the vault account to return
     * @type {string}
     * @memberof VaultsApiUpdateVaultAccountAssetBalance
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiUpdateVaultAccountAssetBalance
     */
    readonly assetId: string

    /**
     * 
     * @type {object}
     * @memberof VaultsApiUpdateVaultAccountAssetBalance
     */
    readonly body?: object

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof VaultsApiUpdateVaultAccountAssetBalance
     */
    readonly idempotencyKey?: string
}

/**
 * VaultsApi - object-oriented interface
 * @export
 * @class VaultsApi
 * @extends {BaseAPI}
 */
export class VaultsApi extends BaseAPI {
    /**
     * Initiates activation for a wallet in a vault account.
     * @summary Activate a wallet in a vault account
     * @param {VaultsApiActivateAssetForVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public activateAssetForVaultAccount(requestParameters: VaultsApiActivateAssetForVaultAccountRequest) {
        return VaultsApiFp(this.configuration).activateAssetForVaultAccount(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Converts an existing segwit address to the legacy format.
     * @summary Convert a segwit address to legacy format
     * @param {VaultsApiCreateLegacyAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public createLegacyAddress(requestParameters: VaultsApiCreateLegacyAddressRequest) {
        return VaultsApiFp(this.configuration).createLegacyAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.addressId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Create multiple vault accounts by running an async job. </br> **Note**: - These endpoints are currently in beta and might be subject to changes. - We limit accounts to 10k per operation and 200k per customer during beta testing. 
     * @summary Bulk creation of new vault accounts
     * @param {VaultsApiCreateMultipleAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public createMultipleAccounts(requestParameters: VaultsApiCreateMultipleAccountsRequest) {
        return VaultsApiFp(this.configuration).createMultipleAccounts(requestParameters.createMultipleAccountsRequest, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Creates a new vault account with the requested name.
     * @summary Create a new vault account
     * @param {VaultsApiCreateVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public createVaultAccount(requestParameters: VaultsApiCreateVaultAccountRequest) {
        return VaultsApiFp(this.configuration).createVaultAccount(requestParameters.createVaultAccountRequest, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Creates a wallet for a specific asset in a vault account.
     * @summary Create a new wallet
     * @param {VaultsApiCreateVaultAccountAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public createVaultAccountAsset(requestParameters: VaultsApiCreateVaultAccountAssetRequest) {
        return VaultsApiFp(this.configuration).createVaultAccountAsset(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.createVaultAccountAssetRequest, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Creates a new deposit address for an asset of a vault account.
     * @summary Create new asset deposit address
     * @param {VaultsApiCreateVaultAccountAssetAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public createVaultAccountAssetAddress(requestParameters: VaultsApiCreateVaultAccountAssetAddressRequest) {
        return VaultsApiFp(this.configuration).createVaultAccountAssetAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.createVaultAccountAssetAddressRequest, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Gets all asset wallets at all of the vault accounts in your workspace. An asset wallet is an asset at a vault account. This method allows fast traversal of all account balances. 
     * @summary List asset wallets (Paginated)
     * @param {VaultsApiGetAssetWalletsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getAssetWallets(requestParameters: VaultsApiGetAssetWalletsRequest = {}) {
        return VaultsApiFp(this.configuration).getAssetWallets(requestParameters.totalAmountLargerThan, requestParameters.assetId, requestParameters.orderBy, requestParameters.before, requestParameters.after, requestParameters.limit).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.
     * @summary Get the maximum spendable amount in a single transaction.
     * @param {VaultsApiGetMaxSpendableAmountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getMaxSpendableAmount(requestParameters: VaultsApiGetMaxSpendableAmountRequest) {
        return VaultsApiFp(this.configuration).getMaxSpendableAmount(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.manualSignging).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.
     * @summary List vault accounts (Paginated)
     * @param {VaultsApiGetPagedVaultAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getPagedVaultAccounts(requestParameters: VaultsApiGetPagedVaultAccountsRequest = {}) {
        return VaultsApiFp(this.configuration).getPagedVaultAccounts(requestParameters.namePrefix, requestParameters.nameSuffix, requestParameters.minAmountThreshold, requestParameters.assetId, requestParameters.orderBy, requestParameters.before, requestParameters.after, requestParameters.limit).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Gets the public key information based on derivation path and signing algorithm.
     * @summary Get the public key information
     * @param {VaultsApiGetPublicKeyInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getPublicKeyInfo(requestParameters: VaultsApiGetPublicKeyInfoRequest) {
        return VaultsApiFp(this.configuration).getPublicKeyInfo(requestParameters.derivationPath, requestParameters.algorithm, requestParameters.compressed).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Gets the public key information for the vault account.
     * @summary Get the public key for a vault account
     * @param {VaultsApiGetPublicKeyInfoForAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getPublicKeyInfoForAddress(requestParameters: VaultsApiGetPublicKeyInfoForAddressRequest) {
        return VaultsApiFp(this.configuration).getPublicKeyInfoForAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.change, requestParameters.addressIndex, requestParameters.compressed).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns unspent inputs information of an asset in a vault account.
     * @summary Get UTXO unspent inputs information
     * @param {VaultsApiGetUnspentInputsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getUnspentInputs(requestParameters: VaultsApiGetUnspentInputsRequest) {
        return VaultsApiFp(this.configuration).getUnspentInputs(requestParameters.vaultAccountId, requestParameters.assetId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns the requested vault account.
     * @summary Find a vault account by ID
     * @param {VaultsApiGetVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getVaultAccount(requestParameters: VaultsApiGetVaultAccountRequest) {
        return VaultsApiFp(this.configuration).getVaultAccount(requestParameters.vaultAccountId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns a wallet for a specific asset of a vault account.
     * @summary Get the asset balance for a vault account
     * @param {VaultsApiGetVaultAccountAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getVaultAccountAsset(requestParameters: VaultsApiGetVaultAccountAssetRequest) {
        return VaultsApiFp(this.configuration).getVaultAccountAsset(requestParameters.vaultAccountId, requestParameters.assetId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Lists all addresses for specific asset of vault account. - This endpoint will be deprecated on Mar 31,2024. - If your application logic or scripts rely on the deprecated endpoint, you should update to account for GET/V1/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated before Mar 31,2024. - All workspaces created after Mar 31,2024. will have it disabled. If it is disabled for your workspace and you attempt to use it, you will receive the following error message: \"This endpoint is unavailable. - Please use the GET/V1/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated endpoint to return all the wallet addresses associated with the specified vault account and asset in a paginated list. - This API call is subject to rate limits.
     * @summary Get asset addresses
     * @param {VaultsApiGetVaultAccountAssetAddressesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getVaultAccountAssetAddresses(requestParameters: VaultsApiGetVaultAccountAssetAddressesRequest) {
        return VaultsApiFp(this.configuration).getVaultAccountAssetAddresses(requestParameters.vaultAccountId, requestParameters.assetId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns a paginated response of the addresses for a given vault account and asset.
     * @summary List addresses (Paginated)
     * @param {VaultsApiGetVaultAccountAssetAddressesPaginatedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getVaultAccountAssetAddressesPaginated(requestParameters: VaultsApiGetVaultAccountAssetAddressesPaginatedRequest) {
        return VaultsApiFp(this.configuration).getVaultAccountAssetAddressesPaginated(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.limit, requestParameters.before, requestParameters.after).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Gets all vault accounts in your workspace.
     * @summary List vault accounts
     * @param {VaultsApiGetVaultAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getVaultAccounts(requestParameters: VaultsApiGetVaultAccountsRequest = {}) {
        return VaultsApiFp(this.configuration).getVaultAccounts(requestParameters.namePrefix, requestParameters.nameSuffix, requestParameters.minAmountThreshold, requestParameters.assetId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Gets the assets amount summary for all accounts or filtered accounts.
     * @summary Get asset balance for chosen assets
     * @param {VaultsApiGetVaultAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getVaultAssets(requestParameters: VaultsApiGetVaultAssetsRequest = {}) {
        return VaultsApiFp(this.configuration).getVaultAssets(requestParameters.accountNamePrefix, requestParameters.accountNameSuffix).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Gets the vault balance summary for an asset.
     * @summary Get vault balance by asset
     * @param {VaultsApiGetVaultBalanceByAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getVaultBalanceByAsset(requestParameters: VaultsApiGetVaultBalanceByAssetRequest) {
        return VaultsApiFp(this.configuration).getVaultBalanceByAsset(requestParameters.assetId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Hides the requested vault account from the web console view.
     * @summary Hide a vault account in the console
     * @param {VaultsApiHideVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public hideVaultAccount(requestParameters: VaultsApiHideVaultAccountRequest) {
        return VaultsApiFp(this.configuration).hideVaultAccount(requestParameters.vaultAccountId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Sets the autofueling property of the vault account to enabled or disabled.
     * @summary Turn autofueling on or off
     * @param {VaultsApiSetAutoFuelForVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public setAutoFuelForVaultAccount(requestParameters: VaultsApiSetAutoFuelForVaultAccountRequest) {
        return VaultsApiFp(this.configuration).setAutoFuelForVaultAccount(requestParameters.setAutoFuelForVaultAccountRequest, requestParameters.vaultAccountId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Sets an AML/KYT customer reference ID for a specific address.
     * @summary Assign AML customer reference ID
     * @param {VaultsApiSetCustomerRefIdForAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public setCustomerRefIdForAddress(requestParameters: VaultsApiSetCustomerRefIdForAddressRequest) {
        return VaultsApiFp(this.configuration).setCustomerRefIdForAddress(requestParameters.setCustomerRefIdForVaultAccountRequest, requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.addressId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Assigns an AML/KYT customer reference ID for the vault account.
     * @summary Set an AML/KYT customer reference ID for a vault account
     * @param {VaultsApiSetCustomerRefIdForVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public setCustomerRefIdForVaultAccount(requestParameters: VaultsApiSetCustomerRefIdForVaultAccountRequest) {
        return VaultsApiFp(this.configuration).setCustomerRefIdForVaultAccount(requestParameters.setCustomerRefIdForVaultAccountRequest, requestParameters.vaultAccountId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Makes a hidden vault account visible in web console view.
     * @summary Unhide a vault account in the console
     * @param {VaultsApiUnhideVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public unhideVaultAccount(requestParameters: VaultsApiUnhideVaultAccountRequest) {
        return VaultsApiFp(this.configuration).unhideVaultAccount(requestParameters.vaultAccountId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Renames the requested vault account.
     * @summary Rename a vault account
     * @param {VaultsApiUpdateVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public updateVaultAccount(requestParameters: VaultsApiUpdateVaultAccountRequest) {
        return VaultsApiFp(this.configuration).updateVaultAccount(requestParameters.updateVaultAccountRequest, requestParameters.vaultAccountId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Updates the description of an existing address of an asset in a vault account.
     * @summary Update address description
     * @param {VaultsApiUpdateVaultAccountAssetAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public updateVaultAccountAssetAddress(requestParameters: VaultsApiUpdateVaultAccountAssetAddressRequest) {
        return VaultsApiFp(this.configuration).updateVaultAccountAssetAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.addressId, requestParameters.updateVaultAccountAssetAddressRequest, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Updates the balance of a specific asset in a vault account.
     * @summary Refresh asset balance data
     * @param {VaultsApiUpdateVaultAccountAssetBalanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public updateVaultAccountAssetBalance(requestParameters: VaultsApiUpdateVaultAccountAssetBalanceRequest) {
        return VaultsApiFp(this.configuration).updateVaultAccountAssetBalance(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.body, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }
}

/**
 * @export
 */
export const GetAssetWalletsOrderByEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type GetAssetWalletsOrderByEnum = typeof GetAssetWalletsOrderByEnum[keyof typeof GetAssetWalletsOrderByEnum];
/**
 * @export
 */
export const GetPagedVaultAccountsOrderByEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type GetPagedVaultAccountsOrderByEnum = typeof GetPagedVaultAccountsOrderByEnum[keyof typeof GetPagedVaultAccountsOrderByEnum];
