/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * Fireblocks provides a suite of applications to manage digital asset operations and a complete development platform to build your business on the blockchain.  - Visit our website for more information: [Fireblocks Website](https://fireblocks.com) - Visit our developer docs: [Fireblocks DevPortal](https://developers.fireblocks.com) 
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: developers@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import { convertToFireblocksResponse } from "../response/fireblocksResponse";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import { assertParamExistsAndNotEmpty } from '../utils/validation_utils';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { CreateWebhookRequest } from '../models';
// @ts-ignore
import { ErrorSchema } from '../models';
// @ts-ignore
import { NotificationAttemptsPaginatedResponse } from '../models';
// @ts-ignore
import { NotificationPaginatedResponse } from '../models';
// @ts-ignore
import { NotificationStatus } from '../models';
// @ts-ignore
import { NotificationWithData } from '../models';
// @ts-ignore
import { ResendFailedNotificationsJobStatusResponse } from '../models';
// @ts-ignore
import { ResendFailedNotificationsRequest } from '../models';
// @ts-ignore
import { ResendFailedNotificationsResponse } from '../models';
// @ts-ignore
import { ResendNotificationsByResourceIdRequest } from '../models';
// @ts-ignore
import { UpdateWebhookRequest } from '../models';
// @ts-ignore
import { Webhook } from '../models';
// @ts-ignore
import { WebhookEvent } from '../models';
// @ts-ignore
import { WebhookMetric } from '../models';
// @ts-ignore
import { WebhookPaginatedResponse } from '../models';
/**
 * WebhooksV2Api - axios parameter creator
 * @export
 */
export const WebhooksV2ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new webhook, which will be triggered on the specified events  **Endpoint Permissions:** Owner, Admin, Non-Signing Admin. 
         * @summary Create a new webhook
         * @param {CreateWebhookRequest} createWebhookRequest 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (createWebhookRequest: CreateWebhookRequest, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('createWebhook', 'createWebhookRequest', createWebhookRequest)
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook by its id  Endpoint Permission: Owner, Admin, Non-Signing Admin. 
         * @summary Delete webhook
         * @param {string} webhookId The unique identifier of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('deleteWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get webhook metrics by webhook id and metric name 
         * @summary Get webhook metrics
         * @param {string} webhookId 
         * @param {GetMetricsMetricNameEnum} metricName Name of the metric to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics: async (webhookId: string, metricName: GetMetricsMetricNameEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getMetrics', 'webhookId', webhookId)
            assertParamExistsAndNotEmpty('getMetrics', 'metricName', metricName)
            const localVarPath = `/webhooks/{webhookId}/metrics/{metricName}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"metricName"}}`, encodeURIComponent(String(metricName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get notification by id 
         * @summary Get notification by id
         * @param {string} webhookId The ID of the webhook to fetch
         * @param {string} notificationId The ID of the notification to fetch
         * @param {boolean} [includeData] Include the data of the notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotification: async (webhookId: string, notificationId: string, includeData?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getNotification', 'webhookId', webhookId)
            assertParamExistsAndNotEmpty('getNotification', 'notificationId', notificationId)
            const localVarPath = `/webhooks/{webhookId}/notifications/{notificationId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeData !== undefined) {
                localVarQueryParameter['includeData'] = includeData;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get notification attempts by notification id 
         * @summary Get notification attempts
         * @param {string} webhookId The ID of the webhook to fetch
         * @param {string} notificationId The ID of the notification to fetch
         * @param {string} [pageCursor] Cursor of the required page
         * @param {number} [pageSize] Maximum number of items in the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationAttempts: async (webhookId: string, notificationId: string, pageCursor?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getNotificationAttempts', 'webhookId', webhookId)
            assertParamExistsAndNotEmpty('getNotificationAttempts', 'notificationId', notificationId)
            const localVarPath = `/webhooks/{webhookId}/notifications/{notificationId}/attempts`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all notifications by webhook id (paginated) 
         * @summary Get all notifications by webhook id
         * @param {string} webhookId 
         * @param {GetNotificationsOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {GetNotificationsSortByEnum} [sortBy] Sort by field
         * @param {string} [pageCursor] Cursor of the required page
         * @param {number} [pageSize] Maximum number of items in the page
         * @param {number} [startTime] Start time in milliseconds since epoch to filter by notifications created after this time (default 31 days ago)
         * @param {number} [endTime] End time in milliseconds since epoch to filter by notifications created before this time (default current time)
         * @param {Array<NotificationStatus>} [statuses] List of notification statuses to filter by
         * @param {Array<WebhookEvent>} [events] List of webhook event types to filter by
         * @param {string} [resourceId] Resource ID to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (webhookId: string, order?: GetNotificationsOrderEnum, sortBy?: GetNotificationsSortByEnum, pageCursor?: string, pageSize?: number, startTime?: number, endTime?: number, statuses?: Array<NotificationStatus>, events?: Array<WebhookEvent>, resourceId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getNotifications', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}/notifications`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (events) {
                localVarQueryParameter['events'] = events;
            }

            if (resourceId !== undefined) {
                localVarQueryParameter['resourceId'] = resourceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of a resend job 
         * @summary Get resend job status
         * @param {string} webhookId The ID of the webhook
         * @param {string} jobId The ID of the resend job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResendJobStatus: async (webhookId: string, jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getResendJobStatus', 'webhookId', webhookId)
            assertParamExistsAndNotEmpty('getResendJobStatus', 'jobId', jobId)
            const localVarPath = `/webhooks/{webhookId}/notifications/resend_failed/jobs/{jobId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a webhook by its id 
         * @summary Get webhook by id
         * @param {string} webhookId The unique identifier of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all webhooks (paginated). 
         * @summary Get all webhooks
         * @param {GetWebhooksOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {string} [pageCursor] Cursor of the required page
         * @param {number} [pageSize] Maximum number of items in the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: async (order?: GetWebhooksOrderEnum, pageCursor?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend all failed notifications for a webhook in the last 24 hours  Endpoint Permission: Owner, Admin, Non-Signing Admin, Editor, Signer. 
         * @summary Resend failed notifications
         * @param {ResendFailedNotificationsRequest} resendFailedNotificationsRequest 
         * @param {string} webhookId The ID of the webhook
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendFailedNotifications: async (resendFailedNotificationsRequest: ResendFailedNotificationsRequest, webhookId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('resendFailedNotifications', 'resendFailedNotificationsRequest', resendFailedNotificationsRequest)
            assertParamExistsAndNotEmpty('resendFailedNotifications', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}/notifications/resend_failed`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendFailedNotificationsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend notification by ID  Endpoint Permission: Owner, Admin, Non-Signing Admin, Editor, Signer. 
         * @summary Resend notification by id
         * @param {string} webhookId The ID of the webhook
         * @param {string} notificationId The ID of the notification
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendNotificationById: async (webhookId: string, notificationId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('resendNotificationById', 'webhookId', webhookId)
            assertParamExistsAndNotEmpty('resendNotificationById', 'notificationId', notificationId)
            const localVarPath = `/webhooks/{webhookId}/notifications/{notificationId}/resend`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend notifications by resource Id  Endpoint Permission: Owner, Admin, Non-Signing Admin, Editor, Signer. 
         * @summary Resend notifications by resource Id
         * @param {ResendNotificationsByResourceIdRequest} resendNotificationsByResourceIdRequest 
         * @param {string} webhookId The ID of the webhook
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendNotificationsByResourceId: async (resendNotificationsByResourceIdRequest: ResendNotificationsByResourceIdRequest, webhookId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('resendNotificationsByResourceId', 'resendNotificationsByResourceIdRequest', resendNotificationsByResourceIdRequest)
            assertParamExistsAndNotEmpty('resendNotificationsByResourceId', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}/notifications/resend_by_resource`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendNotificationsByResourceIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a webhook by its id  Endpoint Permission: Owner, Admin, Non-Signing Admin. 
         * @summary Update webhook
         * @param {UpdateWebhookRequest} updateWebhookRequest 
         * @param {string} webhookId The unique identifier of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (updateWebhookRequest: UpdateWebhookRequest, webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('updateWebhook', 'updateWebhookRequest', updateWebhookRequest)
            assertParamExistsAndNotEmpty('updateWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksV2Api - functional programming interface
 * @export
 */
export const WebhooksV2ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksV2ApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new webhook, which will be triggered on the specified events  **Endpoint Permissions:** Owner, Admin, Non-Signing Admin. 
         * @summary Create a new webhook
         * @param {CreateWebhookRequest} createWebhookRequest 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(createWebhookRequest: CreateWebhookRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(createWebhookRequest, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2Api.createWebhook']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a webhook by its id  Endpoint Permission: Owner, Admin, Non-Signing Admin. 
         * @summary Delete webhook
         * @param {string} webhookId The unique identifier of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2Api.deleteWebhook']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get webhook metrics by webhook id and metric name 
         * @summary Get webhook metrics
         * @param {string} webhookId 
         * @param {GetMetricsMetricNameEnum} metricName Name of the metric to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetrics(webhookId: string, metricName: GetMetricsMetricNameEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookMetric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetrics(webhookId, metricName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2Api.getMetrics']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get notification by id 
         * @summary Get notification by id
         * @param {string} webhookId The ID of the webhook to fetch
         * @param {string} notificationId The ID of the notification to fetch
         * @param {boolean} [includeData] Include the data of the notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotification(webhookId: string, notificationId: string, includeData?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationWithData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotification(webhookId, notificationId, includeData, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2Api.getNotification']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get notification attempts by notification id 
         * @summary Get notification attempts
         * @param {string} webhookId The ID of the webhook to fetch
         * @param {string} notificationId The ID of the notification to fetch
         * @param {string} [pageCursor] Cursor of the required page
         * @param {number} [pageSize] Maximum number of items in the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationAttempts(webhookId: string, notificationId: string, pageCursor?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationAttemptsPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationAttempts(webhookId, notificationId, pageCursor, pageSize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2Api.getNotificationAttempts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get all notifications by webhook id (paginated) 
         * @summary Get all notifications by webhook id
         * @param {string} webhookId 
         * @param {GetNotificationsOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {GetNotificationsSortByEnum} [sortBy] Sort by field
         * @param {string} [pageCursor] Cursor of the required page
         * @param {number} [pageSize] Maximum number of items in the page
         * @param {number} [startTime] Start time in milliseconds since epoch to filter by notifications created after this time (default 31 days ago)
         * @param {number} [endTime] End time in milliseconds since epoch to filter by notifications created before this time (default current time)
         * @param {Array<NotificationStatus>} [statuses] List of notification statuses to filter by
         * @param {Array<WebhookEvent>} [events] List of webhook event types to filter by
         * @param {string} [resourceId] Resource ID to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(webhookId: string, order?: GetNotificationsOrderEnum, sortBy?: GetNotificationsSortByEnum, pageCursor?: string, pageSize?: number, startTime?: number, endTime?: number, statuses?: Array<NotificationStatus>, events?: Array<WebhookEvent>, resourceId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotifications(webhookId, order, sortBy, pageCursor, pageSize, startTime, endTime, statuses, events, resourceId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2Api.getNotifications']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get the status of a resend job 
         * @summary Get resend job status
         * @param {string} webhookId The ID of the webhook
         * @param {string} jobId The ID of the resend job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResendJobStatus(webhookId: string, jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResendFailedNotificationsJobStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResendJobStatus(webhookId, jobId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2Api.getResendJobStatus']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve a webhook by its id 
         * @summary Get webhook by id
         * @param {string} webhookId The unique identifier of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(webhookId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2Api.getWebhook']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get all webhooks (paginated). 
         * @summary Get all webhooks
         * @param {GetWebhooksOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {string} [pageCursor] Cursor of the required page
         * @param {number} [pageSize] Maximum number of items in the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhooks(order?: GetWebhooksOrderEnum, pageCursor?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooks(order, pageCursor, pageSize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2Api.getWebhooks']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Resend all failed notifications for a webhook in the last 24 hours  Endpoint Permission: Owner, Admin, Non-Signing Admin, Editor, Signer. 
         * @summary Resend failed notifications
         * @param {ResendFailedNotificationsRequest} resendFailedNotificationsRequest 
         * @param {string} webhookId The ID of the webhook
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendFailedNotifications(resendFailedNotificationsRequest: ResendFailedNotificationsRequest, webhookId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResendFailedNotificationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendFailedNotifications(resendFailedNotificationsRequest, webhookId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2Api.resendFailedNotifications']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Resend notification by ID  Endpoint Permission: Owner, Admin, Non-Signing Admin, Editor, Signer. 
         * @summary Resend notification by id
         * @param {string} webhookId The ID of the webhook
         * @param {string} notificationId The ID of the notification
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendNotificationById(webhookId: string, notificationId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendNotificationById(webhookId, notificationId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2Api.resendNotificationById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Resend notifications by resource Id  Endpoint Permission: Owner, Admin, Non-Signing Admin, Editor, Signer. 
         * @summary Resend notifications by resource Id
         * @param {ResendNotificationsByResourceIdRequest} resendNotificationsByResourceIdRequest 
         * @param {string} webhookId The ID of the webhook
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendNotificationsByResourceId(resendNotificationsByResourceIdRequest: ResendNotificationsByResourceIdRequest, webhookId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendNotificationsByResourceId(resendNotificationsByResourceIdRequest, webhookId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2Api.resendNotificationsByResourceId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update a webhook by its id  Endpoint Permission: Owner, Admin, Non-Signing Admin. 
         * @summary Update webhook
         * @param {UpdateWebhookRequest} updateWebhookRequest 
         * @param {string} webhookId The unique identifier of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(updateWebhookRequest: UpdateWebhookRequest, webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(updateWebhookRequest, webhookId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2Api.updateWebhook']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * WebhooksV2Api - factory interface
 * @export
 */
export const WebhooksV2ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksV2ApiFp(configuration)
    return {
        /**
         * Creates a new webhook, which will be triggered on the specified events  **Endpoint Permissions:** Owner, Admin, Non-Signing Admin. 
         * @summary Create a new webhook
         * @param {WebhooksV2ApiCreateWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(requestParameters: WebhooksV2ApiCreateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.createWebhook(requestParameters.createWebhookRequest, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a webhook by its id  Endpoint Permission: Owner, Admin, Non-Signing Admin. 
         * @summary Delete webhook
         * @param {WebhooksV2ApiDeleteWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(requestParameters: WebhooksV2ApiDeleteWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.deleteWebhook(requestParameters.webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get webhook metrics by webhook id and metric name 
         * @summary Get webhook metrics
         * @param {WebhooksV2ApiGetMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(requestParameters: WebhooksV2ApiGetMetricsRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookMetric> {
            return localVarFp.getMetrics(requestParameters.webhookId, requestParameters.metricName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get notification by id 
         * @summary Get notification by id
         * @param {WebhooksV2ApiGetNotificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotification(requestParameters: WebhooksV2ApiGetNotificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<NotificationWithData> {
            return localVarFp.getNotification(requestParameters.webhookId, requestParameters.notificationId, requestParameters.includeData, options).then((request) => request(axios, basePath));
        },
        /**
         * Get notification attempts by notification id 
         * @summary Get notification attempts
         * @param {WebhooksV2ApiGetNotificationAttemptsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationAttempts(requestParameters: WebhooksV2ApiGetNotificationAttemptsRequest, options?: RawAxiosRequestConfig): AxiosPromise<NotificationAttemptsPaginatedResponse> {
            return localVarFp.getNotificationAttempts(requestParameters.webhookId, requestParameters.notificationId, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all notifications by webhook id (paginated) 
         * @summary Get all notifications by webhook id
         * @param {WebhooksV2ApiGetNotificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(requestParameters: WebhooksV2ApiGetNotificationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<NotificationPaginatedResponse> {
            return localVarFp.getNotifications(requestParameters.webhookId, requestParameters.order, requestParameters.sortBy, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.startTime, requestParameters.endTime, requestParameters.statuses, requestParameters.events, requestParameters.resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of a resend job 
         * @summary Get resend job status
         * @param {WebhooksV2ApiGetResendJobStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResendJobStatus(requestParameters: WebhooksV2ApiGetResendJobStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResendFailedNotificationsJobStatusResponse> {
            return localVarFp.getResendJobStatus(requestParameters.webhookId, requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a webhook by its id 
         * @summary Get webhook by id
         * @param {WebhooksV2ApiGetWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(requestParameters: WebhooksV2ApiGetWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.getWebhook(requestParameters.webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all webhooks (paginated). 
         * @summary Get all webhooks
         * @param {WebhooksV2ApiGetWebhooksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(requestParameters: WebhooksV2ApiGetWebhooksRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<WebhookPaginatedResponse> {
            return localVarFp.getWebhooks(requestParameters.order, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend all failed notifications for a webhook in the last 24 hours  Endpoint Permission: Owner, Admin, Non-Signing Admin, Editor, Signer. 
         * @summary Resend failed notifications
         * @param {WebhooksV2ApiResendFailedNotificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendFailedNotifications(requestParameters: WebhooksV2ApiResendFailedNotificationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResendFailedNotificationsResponse> {
            return localVarFp.resendFailedNotifications(requestParameters.resendFailedNotificationsRequest, requestParameters.webhookId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend notification by ID  Endpoint Permission: Owner, Admin, Non-Signing Admin, Editor, Signer. 
         * @summary Resend notification by id
         * @param {WebhooksV2ApiResendNotificationByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendNotificationById(requestParameters: WebhooksV2ApiResendNotificationByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resendNotificationById(requestParameters.webhookId, requestParameters.notificationId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend notifications by resource Id  Endpoint Permission: Owner, Admin, Non-Signing Admin, Editor, Signer. 
         * @summary Resend notifications by resource Id
         * @param {WebhooksV2ApiResendNotificationsByResourceIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendNotificationsByResourceId(requestParameters: WebhooksV2ApiResendNotificationsByResourceIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resendNotificationsByResourceId(requestParameters.resendNotificationsByResourceIdRequest, requestParameters.webhookId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a webhook by its id  Endpoint Permission: Owner, Admin, Non-Signing Admin. 
         * @summary Update webhook
         * @param {WebhooksV2ApiUpdateWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(requestParameters: WebhooksV2ApiUpdateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.updateWebhook(requestParameters.updateWebhookRequest, requestParameters.webhookId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createWebhook operation in WebhooksV2Api.
 * @export
 * @interface WebhooksV2ApiCreateWebhookRequest
 */
export interface WebhooksV2ApiCreateWebhookRequest {
    /**
     * 
     * @type {CreateWebhookRequest}
     * @memberof WebhooksV2ApiCreateWebhook
     */
    readonly createWebhookRequest: CreateWebhookRequest

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof WebhooksV2ApiCreateWebhook
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for deleteWebhook operation in WebhooksV2Api.
 * @export
 * @interface WebhooksV2ApiDeleteWebhookRequest
 */
export interface WebhooksV2ApiDeleteWebhookRequest {
    /**
     * The unique identifier of the webhook
     * @type {string}
     * @memberof WebhooksV2ApiDeleteWebhook
     */
    readonly webhookId: string
}

/**
 * Request parameters for getMetrics operation in WebhooksV2Api.
 * @export
 * @interface WebhooksV2ApiGetMetricsRequest
 */
export interface WebhooksV2ApiGetMetricsRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhooksV2ApiGetMetrics
     */
    readonly webhookId: string

    /**
     * Name of the metric to retrieve
     * @type {'LAST_ACTIVE_HOUR_ERROR_RATE'}
     * @memberof WebhooksV2ApiGetMetrics
     */
    readonly metricName: GetMetricsMetricNameEnum
}

/**
 * Request parameters for getNotification operation in WebhooksV2Api.
 * @export
 * @interface WebhooksV2ApiGetNotificationRequest
 */
export interface WebhooksV2ApiGetNotificationRequest {
    /**
     * The ID of the webhook to fetch
     * @type {string}
     * @memberof WebhooksV2ApiGetNotification
     */
    readonly webhookId: string

    /**
     * The ID of the notification to fetch
     * @type {string}
     * @memberof WebhooksV2ApiGetNotification
     */
    readonly notificationId: string

    /**
     * Include the data of the notification
     * @type {boolean}
     * @memberof WebhooksV2ApiGetNotification
     */
    readonly includeData?: boolean
}

/**
 * Request parameters for getNotificationAttempts operation in WebhooksV2Api.
 * @export
 * @interface WebhooksV2ApiGetNotificationAttemptsRequest
 */
export interface WebhooksV2ApiGetNotificationAttemptsRequest {
    /**
     * The ID of the webhook to fetch
     * @type {string}
     * @memberof WebhooksV2ApiGetNotificationAttempts
     */
    readonly webhookId: string

    /**
     * The ID of the notification to fetch
     * @type {string}
     * @memberof WebhooksV2ApiGetNotificationAttempts
     */
    readonly notificationId: string

    /**
     * Cursor of the required page
     * @type {string}
     * @memberof WebhooksV2ApiGetNotificationAttempts
     */
    readonly pageCursor?: string

    /**
     * Maximum number of items in the page
     * @type {number}
     * @memberof WebhooksV2ApiGetNotificationAttempts
     */
    readonly pageSize?: number
}

/**
 * Request parameters for getNotifications operation in WebhooksV2Api.
 * @export
 * @interface WebhooksV2ApiGetNotificationsRequest
 */
export interface WebhooksV2ApiGetNotificationsRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhooksV2ApiGetNotifications
     */
    readonly webhookId: string

    /**
     * ASC / DESC ordering (default DESC)
     * @type {'ASC' | 'DESC'}
     * @memberof WebhooksV2ApiGetNotifications
     */
    readonly order?: GetNotificationsOrderEnum

    /**
     * Sort by field
     * @type {'id' | 'createdAt' | 'updatedAt' | 'status' | 'eventType' | 'resourceId'}
     * @memberof WebhooksV2ApiGetNotifications
     */
    readonly sortBy?: GetNotificationsSortByEnum

    /**
     * Cursor of the required page
     * @type {string}
     * @memberof WebhooksV2ApiGetNotifications
     */
    readonly pageCursor?: string

    /**
     * Maximum number of items in the page
     * @type {number}
     * @memberof WebhooksV2ApiGetNotifications
     */
    readonly pageSize?: number

    /**
     * Start time in milliseconds since epoch to filter by notifications created after this time (default 31 days ago)
     * @type {number}
     * @memberof WebhooksV2ApiGetNotifications
     */
    readonly startTime?: number

    /**
     * End time in milliseconds since epoch to filter by notifications created before this time (default current time)
     * @type {number}
     * @memberof WebhooksV2ApiGetNotifications
     */
    readonly endTime?: number

    /**
     * List of notification statuses to filter by
     * @type {Array<NotificationStatus>}
     * @memberof WebhooksV2ApiGetNotifications
     */
    readonly statuses?: Array<NotificationStatus>

    /**
     * List of webhook event types to filter by
     * @type {Array<WebhookEvent>}
     * @memberof WebhooksV2ApiGetNotifications
     */
    readonly events?: Array<WebhookEvent>

    /**
     * Resource ID to filter by
     * @type {string}
     * @memberof WebhooksV2ApiGetNotifications
     */
    readonly resourceId?: string
}

/**
 * Request parameters for getResendJobStatus operation in WebhooksV2Api.
 * @export
 * @interface WebhooksV2ApiGetResendJobStatusRequest
 */
export interface WebhooksV2ApiGetResendJobStatusRequest {
    /**
     * The ID of the webhook
     * @type {string}
     * @memberof WebhooksV2ApiGetResendJobStatus
     */
    readonly webhookId: string

    /**
     * The ID of the resend job
     * @type {string}
     * @memberof WebhooksV2ApiGetResendJobStatus
     */
    readonly jobId: string
}

/**
 * Request parameters for getWebhook operation in WebhooksV2Api.
 * @export
 * @interface WebhooksV2ApiGetWebhookRequest
 */
export interface WebhooksV2ApiGetWebhookRequest {
    /**
     * The unique identifier of the webhook
     * @type {string}
     * @memberof WebhooksV2ApiGetWebhook
     */
    readonly webhookId: string
}

/**
 * Request parameters for getWebhooks operation in WebhooksV2Api.
 * @export
 * @interface WebhooksV2ApiGetWebhooksRequest
 */
export interface WebhooksV2ApiGetWebhooksRequest {
    /**
     * ASC / DESC ordering (default DESC)
     * @type {'ASC' | 'DESC'}
     * @memberof WebhooksV2ApiGetWebhooks
     */
    readonly order?: GetWebhooksOrderEnum

    /**
     * Cursor of the required page
     * @type {string}
     * @memberof WebhooksV2ApiGetWebhooks
     */
    readonly pageCursor?: string

    /**
     * Maximum number of items in the page
     * @type {number}
     * @memberof WebhooksV2ApiGetWebhooks
     */
    readonly pageSize?: number
}

/**
 * Request parameters for resendFailedNotifications operation in WebhooksV2Api.
 * @export
 * @interface WebhooksV2ApiResendFailedNotificationsRequest
 */
export interface WebhooksV2ApiResendFailedNotificationsRequest {
    /**
     * 
     * @type {ResendFailedNotificationsRequest}
     * @memberof WebhooksV2ApiResendFailedNotifications
     */
    readonly resendFailedNotificationsRequest: ResendFailedNotificationsRequest

    /**
     * The ID of the webhook
     * @type {string}
     * @memberof WebhooksV2ApiResendFailedNotifications
     */
    readonly webhookId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof WebhooksV2ApiResendFailedNotifications
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for resendNotificationById operation in WebhooksV2Api.
 * @export
 * @interface WebhooksV2ApiResendNotificationByIdRequest
 */
export interface WebhooksV2ApiResendNotificationByIdRequest {
    /**
     * The ID of the webhook
     * @type {string}
     * @memberof WebhooksV2ApiResendNotificationById
     */
    readonly webhookId: string

    /**
     * The ID of the notification
     * @type {string}
     * @memberof WebhooksV2ApiResendNotificationById
     */
    readonly notificationId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof WebhooksV2ApiResendNotificationById
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for resendNotificationsByResourceId operation in WebhooksV2Api.
 * @export
 * @interface WebhooksV2ApiResendNotificationsByResourceIdRequest
 */
export interface WebhooksV2ApiResendNotificationsByResourceIdRequest {
    /**
     * 
     * @type {ResendNotificationsByResourceIdRequest}
     * @memberof WebhooksV2ApiResendNotificationsByResourceId
     */
    readonly resendNotificationsByResourceIdRequest: ResendNotificationsByResourceIdRequest

    /**
     * The ID of the webhook
     * @type {string}
     * @memberof WebhooksV2ApiResendNotificationsByResourceId
     */
    readonly webhookId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof WebhooksV2ApiResendNotificationsByResourceId
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for updateWebhook operation in WebhooksV2Api.
 * @export
 * @interface WebhooksV2ApiUpdateWebhookRequest
 */
export interface WebhooksV2ApiUpdateWebhookRequest {
    /**
     * 
     * @type {UpdateWebhookRequest}
     * @memberof WebhooksV2ApiUpdateWebhook
     */
    readonly updateWebhookRequest: UpdateWebhookRequest

    /**
     * The unique identifier of the webhook
     * @type {string}
     * @memberof WebhooksV2ApiUpdateWebhook
     */
    readonly webhookId: string
}

/**
 * WebhooksV2Api - object-oriented interface
 * @export
 * @class WebhooksV2Api
 * @extends {BaseAPI}
 */
export class WebhooksV2Api extends BaseAPI {
    /**
     * Creates a new webhook, which will be triggered on the specified events  **Endpoint Permissions:** Owner, Admin, Non-Signing Admin. 
     * @summary Create a new webhook
     * @param {WebhooksV2ApiCreateWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2Api
     */
    public createWebhook(requestParameters: WebhooksV2ApiCreateWebhookRequest) {
        return WebhooksV2ApiFp(this.configuration).createWebhook(requestParameters.createWebhookRequest, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Delete a webhook by its id  Endpoint Permission: Owner, Admin, Non-Signing Admin. 
     * @summary Delete webhook
     * @param {WebhooksV2ApiDeleteWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2Api
     */
    public deleteWebhook(requestParameters: WebhooksV2ApiDeleteWebhookRequest) {
        return WebhooksV2ApiFp(this.configuration).deleteWebhook(requestParameters.webhookId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Get webhook metrics by webhook id and metric name 
     * @summary Get webhook metrics
     * @param {WebhooksV2ApiGetMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2Api
     */
    public getMetrics(requestParameters: WebhooksV2ApiGetMetricsRequest) {
        return WebhooksV2ApiFp(this.configuration).getMetrics(requestParameters.webhookId, requestParameters.metricName).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Get notification by id 
     * @summary Get notification by id
     * @param {WebhooksV2ApiGetNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2Api
     */
    public getNotification(requestParameters: WebhooksV2ApiGetNotificationRequest) {
        return WebhooksV2ApiFp(this.configuration).getNotification(requestParameters.webhookId, requestParameters.notificationId, requestParameters.includeData).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Get notification attempts by notification id 
     * @summary Get notification attempts
     * @param {WebhooksV2ApiGetNotificationAttemptsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2Api
     */
    public getNotificationAttempts(requestParameters: WebhooksV2ApiGetNotificationAttemptsRequest) {
        return WebhooksV2ApiFp(this.configuration).getNotificationAttempts(requestParameters.webhookId, requestParameters.notificationId, requestParameters.pageCursor, requestParameters.pageSize).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Get all notifications by webhook id (paginated) 
     * @summary Get all notifications by webhook id
     * @param {WebhooksV2ApiGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2Api
     */
    public getNotifications(requestParameters: WebhooksV2ApiGetNotificationsRequest) {
        return WebhooksV2ApiFp(this.configuration).getNotifications(requestParameters.webhookId, requestParameters.order, requestParameters.sortBy, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.startTime, requestParameters.endTime, requestParameters.statuses, requestParameters.events, requestParameters.resourceId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Get the status of a resend job 
     * @summary Get resend job status
     * @param {WebhooksV2ApiGetResendJobStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2Api
     */
    public getResendJobStatus(requestParameters: WebhooksV2ApiGetResendJobStatusRequest) {
        return WebhooksV2ApiFp(this.configuration).getResendJobStatus(requestParameters.webhookId, requestParameters.jobId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Retrieve a webhook by its id 
     * @summary Get webhook by id
     * @param {WebhooksV2ApiGetWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2Api
     */
    public getWebhook(requestParameters: WebhooksV2ApiGetWebhookRequest) {
        return WebhooksV2ApiFp(this.configuration).getWebhook(requestParameters.webhookId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Get all webhooks (paginated). 
     * @summary Get all webhooks
     * @param {WebhooksV2ApiGetWebhooksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2Api
     */
    public getWebhooks(requestParameters: WebhooksV2ApiGetWebhooksRequest = {}) {
        return WebhooksV2ApiFp(this.configuration).getWebhooks(requestParameters.order, requestParameters.pageCursor, requestParameters.pageSize).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Resend all failed notifications for a webhook in the last 24 hours  Endpoint Permission: Owner, Admin, Non-Signing Admin, Editor, Signer. 
     * @summary Resend failed notifications
     * @param {WebhooksV2ApiResendFailedNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2Api
     */
    public resendFailedNotifications(requestParameters: WebhooksV2ApiResendFailedNotificationsRequest) {
        return WebhooksV2ApiFp(this.configuration).resendFailedNotifications(requestParameters.resendFailedNotificationsRequest, requestParameters.webhookId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Resend notification by ID  Endpoint Permission: Owner, Admin, Non-Signing Admin, Editor, Signer. 
     * @summary Resend notification by id
     * @param {WebhooksV2ApiResendNotificationByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2Api
     */
    public resendNotificationById(requestParameters: WebhooksV2ApiResendNotificationByIdRequest) {
        return WebhooksV2ApiFp(this.configuration).resendNotificationById(requestParameters.webhookId, requestParameters.notificationId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Resend notifications by resource Id  Endpoint Permission: Owner, Admin, Non-Signing Admin, Editor, Signer. 
     * @summary Resend notifications by resource Id
     * @param {WebhooksV2ApiResendNotificationsByResourceIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2Api
     */
    public resendNotificationsByResourceId(requestParameters: WebhooksV2ApiResendNotificationsByResourceIdRequest) {
        return WebhooksV2ApiFp(this.configuration).resendNotificationsByResourceId(requestParameters.resendNotificationsByResourceIdRequest, requestParameters.webhookId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Update a webhook by its id  Endpoint Permission: Owner, Admin, Non-Signing Admin. 
     * @summary Update webhook
     * @param {WebhooksV2ApiUpdateWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2Api
     */
    public updateWebhook(requestParameters: WebhooksV2ApiUpdateWebhookRequest) {
        return WebhooksV2ApiFp(this.configuration).updateWebhook(requestParameters.updateWebhookRequest, requestParameters.webhookId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }
}

/**
 * @export
 */
export const GetMetricsMetricNameEnum = {
    LastActiveHourErrorRate: 'LAST_ACTIVE_HOUR_ERROR_RATE'
} as const;
export type GetMetricsMetricNameEnum = typeof GetMetricsMetricNameEnum[keyof typeof GetMetricsMetricNameEnum];
/**
 * @export
 */
export const GetNotificationsOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type GetNotificationsOrderEnum = typeof GetNotificationsOrderEnum[keyof typeof GetNotificationsOrderEnum];
/**
 * @export
 */
export const GetNotificationsSortByEnum = {
    Id: 'id',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    Status: 'status',
    EventType: 'eventType',
    ResourceId: 'resourceId'
} as const;
export type GetNotificationsSortByEnum = typeof GetNotificationsSortByEnum[keyof typeof GetNotificationsSortByEnum];
/**
 * @export
 */
export const GetWebhooksOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type GetWebhooksOrderEnum = typeof GetWebhooksOrderEnum[keyof typeof GetWebhooksOrderEnum];
