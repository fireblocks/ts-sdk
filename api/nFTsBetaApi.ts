/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

    import { GetNFTTokens200Response } from '../model/getNFTTokens200Response';
    import { GetOwnershipTokens200Response } from '../model/getOwnershipTokens200Response';
    import { TokenResponse } from '../model/tokenResponse';
    import { UpdateTokenOwnershipStatusDto } from '../model/updateTokenOwnershipStatusDto';
import {HttpClient} from '../utils/http-client';
import {Configuration, ConfigurationParameters} from '../utils/types/configuration';
import {ObjectSerializer} from "../model/models";
import { AxiosRequestConfig, AxiosResponse } from 'axios';


    export class NFTsBetaApi {
        private  configuration: Configuration;
        private  httpClient: HttpClient;

        constructor(private configurationParameters:ConfigurationParameters = {}) {
            this.configuration = new Configuration(configurationParameters)
            this.httpClient = new HttpClient(this.configuration);
        }

            /**
            * Returns the requested token data.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
                * @summary List token data by ID
                * @param id NFT ID
            */
        public async getNFTTokenById (id: string, ) : Promise<TokenResponse> {
                const path = this.configuration.basePath + '/nfts/tokens/{id}'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'id' is not null or undefined
                        if (id === null || id === undefined) {
                        throw new Error('Required parameter id was null or undefined when calling getNFTTokenById.');
                        }


                    if (typeof id === 'object') {
                        for( const [key,value] of Object.entries(id)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['id'] = ObjectSerializer.serialize(id, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<TokenResponse>(requestOptions);
        }
            /**
            * Returns the requested tokens data  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
                * @summary List tokens by IDs
                * @param ids A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
                * @param pageCursor Page cursor to fetch
                * @param pageSize Items per page (max 100)
                * @param sort Sort by param, it can be one param or a list of params separated by comma
                * @param order Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
            */
        public async getNFTTokens (ids: string, pageCursor?: string, pageSize?: number, sort?: Array<'collection.name' | 'name'>, order?: 'DESC' | 'ASC', ) : Promise<GetNFTTokens200Response> {
                const path = this.configuration.basePath + '/nfts/tokens';
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'ids' is not null or undefined
                        if (ids === null || ids === undefined) {
                        throw new Error('Required parameter ids was null or undefined when calling getNFTTokens.');
                        }


                    if (typeof ids === 'object') {
                        for( const [key,value] of Object.entries(ids)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['ids'] = ObjectSerializer.serialize(ids, "string");
                    }

                    if (typeof pageCursor === 'object') {
                        for( const [key,value] of Object.entries(pageCursor)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['pageCursor'] = ObjectSerializer.serialize(pageCursor, "string");
                    }

                    if (typeof pageSize === 'object') {
                        for( const [key,value] of Object.entries(pageSize)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
                    }

                    if (typeof sort === 'object') {
                        for( const [key,value] of Object.entries(sort)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['sort'] = ObjectSerializer.serialize(sort, "Array<'collection.name' | 'name'>");
                    }

                    if (typeof order === 'object') {
                        for( const [key,value] of Object.entries(order)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['order'] = ObjectSerializer.serialize(order, "'DESC' | 'ASC'");
                    }
                    if (ids !== undefined) {
                        params['ids'] = ObjectSerializer.serialize(ids, "string");
                    }
                    if (pageCursor !== undefined) {
                        params['pageCursor'] = ObjectSerializer.serialize(pageCursor, "string");
                    }
                    if (pageSize !== undefined) {
                        params['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
                    }
                    if (sort !== undefined) {
                        params['sort'] = ObjectSerializer.serialize(sort, "Array<'collection.name' | 'name'>");
                    }
                    if (order !== undefined) {
                        params['order'] = ObjectSerializer.serialize(order, "'DESC' | 'ASC'");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<GetNFTTokens200Response>(requestOptions);
        }
            /**
            * Returns all tokens and their data in your workspace.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
                * @summary List all owned tokens (paginated)
                * @param blockchainDescriptor Blockchain descriptor filter
                * @param vaultAccountIds A comma separated list of Vault Account IDs. Up to 100 are allowed in a single request
                * @param ids A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
                * @param collectionIds A comma separated list of collection IDs. Up to 100 are allowed in a single request.
                * @param pageCursor Page cursor to fetch
                * @param pageSize Items per page (max 100)
                * @param sort Sort by param, it can be one param or a list of params separated by comma
                * @param order Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
                * @param status Token ownership status
            */
        public async getOwnershipTokens (blockchainDescriptor?: 'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI', vaultAccountIds?: string, ids?: string, collectionIds?: string, pageCursor?: string, pageSize?: number, sort?: Array<'ownershipLastUpdateTime' | 'name' | 'collection.name'>, order?: 'DESC' | 'ASC', status?: 'LISTED' | 'ARCHIVED', ) : Promise<GetOwnershipTokens200Response> {
                const path = this.configuration.basePath + '/nfts/ownership/tokens';
                let params: any = {};
                let headers: any = {}

                    if (typeof blockchainDescriptor === 'object') {
                        for( const [key,value] of Object.entries(blockchainDescriptor)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['blockchainDescriptor'] = ObjectSerializer.serialize(blockchainDescriptor, "'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI'");
                    }

                    if (typeof vaultAccountIds === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountIds)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountIds'] = ObjectSerializer.serialize(vaultAccountIds, "string");
                    }

                    if (typeof ids === 'object') {
                        for( const [key,value] of Object.entries(ids)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['ids'] = ObjectSerializer.serialize(ids, "string");
                    }

                    if (typeof collectionIds === 'object') {
                        for( const [key,value] of Object.entries(collectionIds)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['collectionIds'] = ObjectSerializer.serialize(collectionIds, "string");
                    }

                    if (typeof pageCursor === 'object') {
                        for( const [key,value] of Object.entries(pageCursor)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['pageCursor'] = ObjectSerializer.serialize(pageCursor, "string");
                    }

                    if (typeof pageSize === 'object') {
                        for( const [key,value] of Object.entries(pageSize)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
                    }

                    if (typeof sort === 'object') {
                        for( const [key,value] of Object.entries(sort)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['sort'] = ObjectSerializer.serialize(sort, "Array<'ownershipLastUpdateTime' | 'name' | 'collection.name'>");
                    }

                    if (typeof order === 'object') {
                        for( const [key,value] of Object.entries(order)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['order'] = ObjectSerializer.serialize(order, "'DESC' | 'ASC'");
                    }

                    if (typeof status === 'object') {
                        for( const [key,value] of Object.entries(status)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['status'] = ObjectSerializer.serialize(status, "'LISTED' | 'ARCHIVED'");
                    }
                    if (blockchainDescriptor !== undefined) {
                        params['blockchainDescriptor'] = ObjectSerializer.serialize(blockchainDescriptor, "'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI'");
                    }
                    if (vaultAccountIds !== undefined) {
                        params['vaultAccountIds'] = ObjectSerializer.serialize(vaultAccountIds, "string");
                    }
                    if (ids !== undefined) {
                        params['ids'] = ObjectSerializer.serialize(ids, "string");
                    }
                    if (collectionIds !== undefined) {
                        params['collectionIds'] = ObjectSerializer.serialize(collectionIds, "string");
                    }
                    if (pageCursor !== undefined) {
                        params['pageCursor'] = ObjectSerializer.serialize(pageCursor, "string");
                    }
                    if (pageSize !== undefined) {
                        params['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
                    }
                    if (sort !== undefined) {
                        params['sort'] = ObjectSerializer.serialize(sort, "Array<'ownershipLastUpdateTime' | 'name' | 'collection.name'>");
                    }
                    if (order !== undefined) {
                        params['order'] = ObjectSerializer.serialize(order, "'DESC' | 'ASC'");
                    }
                    if (status !== undefined) {
                        params['status'] = ObjectSerializer.serialize(status, "'LISTED' | 'ARCHIVED'");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<GetOwnershipTokens200Response>(requestOptions);
        }
            /**
            * Updates the latest token metadata.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
                * @summary Refresh token metadata
                * @param id NFT ID
            */
        public async updateNFTTokenById (id: string, ) : Promise<any> {
                const path = this.configuration.basePath + '/nfts/tokens/{id}'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'id' is not null or undefined
                        if (id === null || id === undefined) {
                        throw new Error('Required parameter id was null or undefined when calling updateNFTTokenById.');
                        }


                    if (typeof id === 'object') {
                        for( const [key,value] of Object.entries(id)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['id'] = ObjectSerializer.serialize(id, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'PUT',
                    url: path,
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Updates token ownership status for a tenant, in all tenant vaults.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
                * @summary Update token ownership status
                * @param id NFT ID
                * @param updateTokenOwnershipStatusDto 
            */
        public async updateNFTTokenStatus (id: string, updateTokenOwnershipStatusDto: UpdateTokenOwnershipStatusDto, ) : Promise<any> {
                const path = this.configuration.basePath + '/nfts/ownership/tokens/{id}/status'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'id' is not null or undefined
                        if (id === null || id === undefined) {
                        throw new Error('Required parameter id was null or undefined when calling updateNFTTokenStatus.');
                        }


                    if (typeof id === 'object') {
                        for( const [key,value] of Object.entries(id)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['id'] = ObjectSerializer.serialize(id, "string");
                    }
                        // verify required parameter 'updateTokenOwnershipStatusDto' is not null or undefined
                        if (updateTokenOwnershipStatusDto === null || updateTokenOwnershipStatusDto === undefined) {
                        throw new Error('Required parameter updateTokenOwnershipStatusDto was null or undefined when calling updateNFTTokenStatus.');
                        }


                    if (typeof updateTokenOwnershipStatusDto === 'object') {
                        for( const [key,value] of Object.entries(updateTokenOwnershipStatusDto)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['UpdateTokenOwnershipStatusDto'] = ObjectSerializer.serialize(updateTokenOwnershipStatusDto, "UpdateTokenOwnershipStatusDto");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'PUT',
                    url: path,
                        data: params
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Updates all tokens and balances per blockchain and vault account.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
                * @summary Refresh vault account tokens
                * @param blockchainDescriptor Blockchain descriptor filter
                * @param vaultAccountId Vault account filter
            */
        public async updateOwnershipTokens (blockchainDescriptor: 'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI', vaultAccountId: string, ) : Promise<any> {
                const path = this.configuration.basePath + '/nfts/ownership/tokens';
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'blockchainDescriptor' is not null or undefined
                        if (blockchainDescriptor === null || blockchainDescriptor === undefined) {
                        throw new Error('Required parameter blockchainDescriptor was null or undefined when calling updateOwnershipTokens.');
                        }


                    if (typeof blockchainDescriptor === 'object') {
                        for( const [key,value] of Object.entries(blockchainDescriptor)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['blockchainDescriptor'] = ObjectSerializer.serialize(blockchainDescriptor, "'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI'");
                    }
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling updateOwnershipTokens.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                    if (blockchainDescriptor !== undefined) {
                        params['blockchainDescriptor'] = ObjectSerializer.serialize(blockchainDescriptor, "'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI'");
                    }
                    if (vaultAccountId !== undefined) {
                        params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'PUT',
                    url: path,
                };
                return this.httpClient.request<any>(requestOptions);
        }
        }
