/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * Fireblocks provides a suite of applications to manage digital asset operations and a complete development platform to build your business on the blockchain.  - Visit our website for more information: [Fireblocks Website](https://fireblocks.com) - Visit our developer docs: [Fireblocks DevPortal](https://developers.fireblocks.com) 
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: developers@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import { convertToFireblocksResponse } from "../response/fireblocksResponse";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import { assertParamExistsAndNotEmpty } from '../utils/validation_utils';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { AccessRegistryCurrentStateResponse } from '../models';
// @ts-ignore
import { AccessRegistrySummaryResponse } from '../models';
// @ts-ignore
import { ActiveRolesResponse } from '../models';
// @ts-ignore
import { AddressBalancePagedResponse } from '../models';
// @ts-ignore
import { BalanceHistoryPagedResponse } from '../models';
// @ts-ignore
import { ErrorSchema } from '../models';
// @ts-ignore
import { OnchainTransactionsPagedResponse } from '../models';
// @ts-ignore
import { TokenContractSummaryResponse } from '../models';
// @ts-ignore
import { TotalSupplyPagedResponse } from '../models';
/**
 * OnchainDataApi - axios parameter creator
 * @export
 */
export const OnchainDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the current state of addresses in the specified access registry. Only addresses that are currently active (added but not removed) are included.
         * @summary Get the current state of addresses in an access registry
         * @param {string} baseAssetId The blockchain base assetId
         * @param {string} accessRegistryAddress The access registry address
         * @param {string} [pageCursor] Page cursor to get the next page\&quot;
         * @param {number} [pageSize] Number of items per page (max 100), requesting more then 100 will return 100 items
         * @param {GetAccessRegistryCurrentStateSortByEnum} [sortBy] Sorting field (enum).
         * @param {GetAccessRegistryCurrentStateOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRegistryCurrentState: async (baseAssetId: string, accessRegistryAddress: string, pageCursor?: string, pageSize?: number, sortBy?: GetAccessRegistryCurrentStateSortByEnum, order?: GetAccessRegistryCurrentStateOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getAccessRegistryCurrentState', 'baseAssetId', baseAssetId)
            assertParamExistsAndNotEmpty('getAccessRegistryCurrentState', 'accessRegistryAddress', accessRegistryAddress)
            const localVarPath = `/onchain_data/base_asset_id/{baseAssetId}/access_registry_address/{accessRegistryAddress}/list`
                .replace(`{${"baseAssetId"}}`, encodeURIComponent(String(baseAssetId)))
                .replace(`{${"accessRegistryAddress"}}`, encodeURIComponent(String(accessRegistryAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a summary of the current state of the access registry for the specified baseAssetId and accessRegistryAddress.
         * @summary Summary of access registry state
         * @param {string} baseAssetId The blockchain base assetId
         * @param {string} accessRegistryAddress The access registry address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRegistrySummary: async (baseAssetId: string, accessRegistryAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getAccessRegistrySummary', 'baseAssetId', baseAssetId)
            assertParamExistsAndNotEmpty('getAccessRegistrySummary', 'accessRegistryAddress', accessRegistryAddress)
            const localVarPath = `/onchain_data/base_asset_id/{baseAssetId}/access_registry_address/{accessRegistryAddress}/summary`
                .replace(`{${"baseAssetId"}}`, encodeURIComponent(String(baseAssetId)))
                .replace(`{${"accessRegistryAddress"}}`, encodeURIComponent(String(accessRegistryAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of currently active roles for the specified baseAssetId and contractAddress.
         * @summary List of active roles for a given contract address and base asset ID
         * @param {string} baseAssetId The blockchain base assetId
         * @param {string} contractAddress The contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveRolesForContract: async (baseAssetId: string, contractAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getActiveRolesForContract', 'baseAssetId', baseAssetId)
            assertParamExistsAndNotEmpty('getActiveRolesForContract', 'contractAddress', contractAddress)
            const localVarPath = `/onchain_data/base_asset_id/{baseAssetId}/contract_address/{contractAddress}/roles`
                .replace(`{${"baseAssetId"}}`, encodeURIComponent(String(baseAssetId)))
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the paginated balance history of the specified account in a contract with optional date range and interval filtering.
         * @summary Get historical balance data for a specific account in a contract
         * @param {string} baseAssetId The blockchain base assetId
         * @param {string} contractAddress The contract address
         * @param {string} accountAddress The account address to get balance history for
         * @param {string} [startDate] Start date of the time range in ISO 8601 format
         * @param {string} [endDate] End date of the time range in ISO 8601 format
         * @param {GetContractBalanceHistoryIntervalEnum} [interval] Time interval for grouping data
         * @param {string} [pageCursor] Page cursor to get the next page\&quot;
         * @param {number} [pageSize] Number of items per page (max 100), requesting more then 100 will return 100 items
         * @param {GetContractBalanceHistorySortByEnum} [sortBy] Sorting field (enum). Sorting only supported by \&#39;blockTimestamp\&#39;
         * @param {GetContractBalanceHistoryOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractBalanceHistory: async (baseAssetId: string, contractAddress: string, accountAddress: string, startDate?: string, endDate?: string, interval?: GetContractBalanceHistoryIntervalEnum, pageCursor?: string, pageSize?: number, sortBy?: GetContractBalanceHistorySortByEnum, order?: GetContractBalanceHistoryOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getContractBalanceHistory', 'baseAssetId', baseAssetId)
            assertParamExistsAndNotEmpty('getContractBalanceHistory', 'contractAddress', contractAddress)
            assertParamExistsAndNotEmpty('getContractBalanceHistory', 'accountAddress', accountAddress)
            const localVarPath = `/onchain_data/base_asset_id/{baseAssetId}/contract_address/{contractAddress}/account_address/{accountAddress}/balance_history`
                .replace(`{${"baseAssetId"}}`, encodeURIComponent(String(baseAssetId)))
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"accountAddress"}}`, encodeURIComponent(String(accountAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the total number of unique addresses holding balances and the total supply for the specified contract.
         * @summary Get summary for the token contract
         * @param {string} baseAssetId The blockchain base assetId
         * @param {string} contractAddress The contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractBalancesSummary: async (baseAssetId: string, contractAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getContractBalancesSummary', 'baseAssetId', baseAssetId)
            assertParamExistsAndNotEmpty('getContractBalancesSummary', 'contractAddress', contractAddress)
            const localVarPath = `/onchain_data/base_asset_id/{baseAssetId}/contract_address/{contractAddress}/summary`
                .replace(`{${"baseAssetId"}}`, encodeURIComponent(String(baseAssetId)))
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the paginated total supply history of the specified contract with optional date range and interval filtering.
         * @summary Get historical total supply data for a contract
         * @param {string} baseAssetId The blockchain base assetId
         * @param {string} contractAddress The contract address
         * @param {string} [startDate] Start date of the time range in ISO 8601 format
         * @param {string} [endDate] End date of the time range in ISO 8601 format
         * @param {GetContractTotalSupplyIntervalEnum} [interval] Time interval for grouping data
         * @param {string} [pageCursor] Page cursor to get the next page\&quot;
         * @param {number} [pageSize] Number of items per page (max 100), requesting more then 100 will return 100 items
         * @param {GetContractTotalSupplySortByEnum} [sortBy] Sorting field (enum). Sorting only supported by \&#39;blockTimestamp\&#39;
         * @param {GetContractTotalSupplyOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractTotalSupply: async (baseAssetId: string, contractAddress: string, startDate?: string, endDate?: string, interval?: GetContractTotalSupplyIntervalEnum, pageCursor?: string, pageSize?: number, sortBy?: GetContractTotalSupplySortByEnum, order?: GetContractTotalSupplyOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getContractTotalSupply', 'baseAssetId', baseAssetId)
            assertParamExistsAndNotEmpty('getContractTotalSupply', 'contractAddress', contractAddress)
            const localVarPath = `/onchain_data/base_asset_id/{baseAssetId}/contract_address/{contractAddress}/total_supply`
                .replace(`{${"baseAssetId"}}`, encodeURIComponent(String(baseAssetId)))
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the latest balance for each unique address with support for numeric balance sorting. The `prev` cursor is reserved for future support.
         * @summary Get latest balances for all addresses holding tokens from a contract
         * @param {string} baseAssetId The blockchain base assetId
         * @param {string} contractAddress The contract address
         * @param {string} [accountAddress] Optional filter to get balance for a specific account address
         * @param {string} [pageCursor] Page cursor to get the next page\&quot;
         * @param {number} [pageSize] Number of items per page (max 100), requesting more then 100 will return 100 items
         * @param {GetLatestBalancesForContractSortByEnum} [sortBy] Sorting field for balances
         * @param {GetLatestBalancesForContractOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBalancesForContract: async (baseAssetId: string, contractAddress: string, accountAddress?: string, pageCursor?: string, pageSize?: number, sortBy?: GetLatestBalancesForContractSortByEnum, order?: GetLatestBalancesForContractOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getLatestBalancesForContract', 'baseAssetId', baseAssetId)
            assertParamExistsAndNotEmpty('getLatestBalancesForContract', 'contractAddress', contractAddress)
            const localVarPath = `/onchain_data/base_asset_id/{baseAssetId}/contract_address/{contractAddress}/balances`
                .replace(`{${"baseAssetId"}}`, encodeURIComponent(String(baseAssetId)))
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountAddress !== undefined) {
                localVarQueryParameter['accountAddress'] = accountAddress;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of onchain transactions for the specified contract address and base asset ID, optionally filtered by date range.
         * @summary Fetch onchain transactions for a contract
         * @param {string} baseAssetId The blockchain base assetId
         * @param {string} contractAddress The contract address
         * @param {string} [startDate] Start date of the time range in ISO 8601 format
         * @param {string} [endDate] End date of the time range in ISO 8601 format
         * @param {string} [pageCursor] Page cursor to get the next page\&quot;
         * @param {number} [pageSize] Number of items per page (max 100), requesting more then 100 will return 100 items
         * @param {GetOnchainTransactionsSortByEnum} [sortBy] Sorting field (enum).
         * @param {GetOnchainTransactionsOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnchainTransactions: async (baseAssetId: string, contractAddress: string, startDate?: string, endDate?: string, pageCursor?: string, pageSize?: number, sortBy?: GetOnchainTransactionsSortByEnum, order?: GetOnchainTransactionsOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getOnchainTransactions', 'baseAssetId', baseAssetId)
            assertParamExistsAndNotEmpty('getOnchainTransactions', 'contractAddress', contractAddress)
            const localVarPath = `/onchain_data/base_asset_id/{baseAssetId}/contract_address/{contractAddress}/transactions`
                .replace(`{${"baseAssetId"}}`, encodeURIComponent(String(baseAssetId)))
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OnchainDataApi - functional programming interface
 * @export
 */
export const OnchainDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OnchainDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the current state of addresses in the specified access registry. Only addresses that are currently active (added but not removed) are included.
         * @summary Get the current state of addresses in an access registry
         * @param {string} baseAssetId The blockchain base assetId
         * @param {string} accessRegistryAddress The access registry address
         * @param {string} [pageCursor] Page cursor to get the next page\&quot;
         * @param {number} [pageSize] Number of items per page (max 100), requesting more then 100 will return 100 items
         * @param {GetAccessRegistryCurrentStateSortByEnum} [sortBy] Sorting field (enum).
         * @param {GetAccessRegistryCurrentStateOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRegistryCurrentState(baseAssetId: string, accessRegistryAddress: string, pageCursor?: string, pageSize?: number, sortBy?: GetAccessRegistryCurrentStateSortByEnum, order?: GetAccessRegistryCurrentStateOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRegistryCurrentStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRegistryCurrentState(baseAssetId, accessRegistryAddress, pageCursor, pageSize, sortBy, order, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OnchainDataApi.getAccessRegistryCurrentState']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns a summary of the current state of the access registry for the specified baseAssetId and accessRegistryAddress.
         * @summary Summary of access registry state
         * @param {string} baseAssetId The blockchain base assetId
         * @param {string} accessRegistryAddress The access registry address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessRegistrySummary(baseAssetId: string, accessRegistryAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessRegistrySummaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessRegistrySummary(baseAssetId, accessRegistryAddress, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OnchainDataApi.getAccessRegistrySummary']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns a list of currently active roles for the specified baseAssetId and contractAddress.
         * @summary List of active roles for a given contract address and base asset ID
         * @param {string} baseAssetId The blockchain base assetId
         * @param {string} contractAddress The contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveRolesForContract(baseAssetId: string, contractAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveRolesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveRolesForContract(baseAssetId, contractAddress, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OnchainDataApi.getActiveRolesForContract']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns the paginated balance history of the specified account in a contract with optional date range and interval filtering.
         * @summary Get historical balance data for a specific account in a contract
         * @param {string} baseAssetId The blockchain base assetId
         * @param {string} contractAddress The contract address
         * @param {string} accountAddress The account address to get balance history for
         * @param {string} [startDate] Start date of the time range in ISO 8601 format
         * @param {string} [endDate] End date of the time range in ISO 8601 format
         * @param {GetContractBalanceHistoryIntervalEnum} [interval] Time interval for grouping data
         * @param {string} [pageCursor] Page cursor to get the next page\&quot;
         * @param {number} [pageSize] Number of items per page (max 100), requesting more then 100 will return 100 items
         * @param {GetContractBalanceHistorySortByEnum} [sortBy] Sorting field (enum). Sorting only supported by \&#39;blockTimestamp\&#39;
         * @param {GetContractBalanceHistoryOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractBalanceHistory(baseAssetId: string, contractAddress: string, accountAddress: string, startDate?: string, endDate?: string, interval?: GetContractBalanceHistoryIntervalEnum, pageCursor?: string, pageSize?: number, sortBy?: GetContractBalanceHistorySortByEnum, order?: GetContractBalanceHistoryOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceHistoryPagedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractBalanceHistory(baseAssetId, contractAddress, accountAddress, startDate, endDate, interval, pageCursor, pageSize, sortBy, order, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OnchainDataApi.getContractBalanceHistory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns the total number of unique addresses holding balances and the total supply for the specified contract.
         * @summary Get summary for the token contract
         * @param {string} baseAssetId The blockchain base assetId
         * @param {string} contractAddress The contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractBalancesSummary(baseAssetId: string, contractAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenContractSummaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractBalancesSummary(baseAssetId, contractAddress, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OnchainDataApi.getContractBalancesSummary']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns the paginated total supply history of the specified contract with optional date range and interval filtering.
         * @summary Get historical total supply data for a contract
         * @param {string} baseAssetId The blockchain base assetId
         * @param {string} contractAddress The contract address
         * @param {string} [startDate] Start date of the time range in ISO 8601 format
         * @param {string} [endDate] End date of the time range in ISO 8601 format
         * @param {GetContractTotalSupplyIntervalEnum} [interval] Time interval for grouping data
         * @param {string} [pageCursor] Page cursor to get the next page\&quot;
         * @param {number} [pageSize] Number of items per page (max 100), requesting more then 100 will return 100 items
         * @param {GetContractTotalSupplySortByEnum} [sortBy] Sorting field (enum). Sorting only supported by \&#39;blockTimestamp\&#39;
         * @param {GetContractTotalSupplyOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractTotalSupply(baseAssetId: string, contractAddress: string, startDate?: string, endDate?: string, interval?: GetContractTotalSupplyIntervalEnum, pageCursor?: string, pageSize?: number, sortBy?: GetContractTotalSupplySortByEnum, order?: GetContractTotalSupplyOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TotalSupplyPagedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractTotalSupply(baseAssetId, contractAddress, startDate, endDate, interval, pageCursor, pageSize, sortBy, order, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OnchainDataApi.getContractTotalSupply']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns the latest balance for each unique address with support for numeric balance sorting. The `prev` cursor is reserved for future support.
         * @summary Get latest balances for all addresses holding tokens from a contract
         * @param {string} baseAssetId The blockchain base assetId
         * @param {string} contractAddress The contract address
         * @param {string} [accountAddress] Optional filter to get balance for a specific account address
         * @param {string} [pageCursor] Page cursor to get the next page\&quot;
         * @param {number} [pageSize] Number of items per page (max 100), requesting more then 100 will return 100 items
         * @param {GetLatestBalancesForContractSortByEnum} [sortBy] Sorting field for balances
         * @param {GetLatestBalancesForContractOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestBalancesForContract(baseAssetId: string, contractAddress: string, accountAddress?: string, pageCursor?: string, pageSize?: number, sortBy?: GetLatestBalancesForContractSortByEnum, order?: GetLatestBalancesForContractOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressBalancePagedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestBalancesForContract(baseAssetId, contractAddress, accountAddress, pageCursor, pageSize, sortBy, order, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OnchainDataApi.getLatestBalancesForContract']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns a paginated list of onchain transactions for the specified contract address and base asset ID, optionally filtered by date range.
         * @summary Fetch onchain transactions for a contract
         * @param {string} baseAssetId The blockchain base assetId
         * @param {string} contractAddress The contract address
         * @param {string} [startDate] Start date of the time range in ISO 8601 format
         * @param {string} [endDate] End date of the time range in ISO 8601 format
         * @param {string} [pageCursor] Page cursor to get the next page\&quot;
         * @param {number} [pageSize] Number of items per page (max 100), requesting more then 100 will return 100 items
         * @param {GetOnchainTransactionsSortByEnum} [sortBy] Sorting field (enum).
         * @param {GetOnchainTransactionsOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOnchainTransactions(baseAssetId: string, contractAddress: string, startDate?: string, endDate?: string, pageCursor?: string, pageSize?: number, sortBy?: GetOnchainTransactionsSortByEnum, order?: GetOnchainTransactionsOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnchainTransactionsPagedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOnchainTransactions(baseAssetId, contractAddress, startDate, endDate, pageCursor, pageSize, sortBy, order, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OnchainDataApi.getOnchainTransactions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OnchainDataApi - factory interface
 * @export
 */
export const OnchainDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OnchainDataApiFp(configuration)
    return {
        /**
         * Returns the current state of addresses in the specified access registry. Only addresses that are currently active (added but not removed) are included.
         * @summary Get the current state of addresses in an access registry
         * @param {OnchainDataApiGetAccessRegistryCurrentStateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRegistryCurrentState(requestParameters: OnchainDataApiGetAccessRegistryCurrentStateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccessRegistryCurrentStateResponse> {
            return localVarFp.getAccessRegistryCurrentState(requestParameters.baseAssetId, requestParameters.accessRegistryAddress, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sortBy, requestParameters.order, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a summary of the current state of the access registry for the specified baseAssetId and accessRegistryAddress.
         * @summary Summary of access registry state
         * @param {OnchainDataApiGetAccessRegistrySummaryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessRegistrySummary(requestParameters: OnchainDataApiGetAccessRegistrySummaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccessRegistrySummaryResponse> {
            return localVarFp.getAccessRegistrySummary(requestParameters.baseAssetId, requestParameters.accessRegistryAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of currently active roles for the specified baseAssetId and contractAddress.
         * @summary List of active roles for a given contract address and base asset ID
         * @param {OnchainDataApiGetActiveRolesForContractRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveRolesForContract(requestParameters: OnchainDataApiGetActiveRolesForContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<ActiveRolesResponse> {
            return localVarFp.getActiveRolesForContract(requestParameters.baseAssetId, requestParameters.contractAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the paginated balance history of the specified account in a contract with optional date range and interval filtering.
         * @summary Get historical balance data for a specific account in a contract
         * @param {OnchainDataApiGetContractBalanceHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractBalanceHistory(requestParameters: OnchainDataApiGetContractBalanceHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<BalanceHistoryPagedResponse> {
            return localVarFp.getContractBalanceHistory(requestParameters.baseAssetId, requestParameters.contractAddress, requestParameters.accountAddress, requestParameters.startDate, requestParameters.endDate, requestParameters.interval, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sortBy, requestParameters.order, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the total number of unique addresses holding balances and the total supply for the specified contract.
         * @summary Get summary for the token contract
         * @param {OnchainDataApiGetContractBalancesSummaryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractBalancesSummary(requestParameters: OnchainDataApiGetContractBalancesSummaryRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenContractSummaryResponse> {
            return localVarFp.getContractBalancesSummary(requestParameters.baseAssetId, requestParameters.contractAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the paginated total supply history of the specified contract with optional date range and interval filtering.
         * @summary Get historical total supply data for a contract
         * @param {OnchainDataApiGetContractTotalSupplyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractTotalSupply(requestParameters: OnchainDataApiGetContractTotalSupplyRequest, options?: RawAxiosRequestConfig): AxiosPromise<TotalSupplyPagedResponse> {
            return localVarFp.getContractTotalSupply(requestParameters.baseAssetId, requestParameters.contractAddress, requestParameters.startDate, requestParameters.endDate, requestParameters.interval, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sortBy, requestParameters.order, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the latest balance for each unique address with support for numeric balance sorting. The `prev` cursor is reserved for future support.
         * @summary Get latest balances for all addresses holding tokens from a contract
         * @param {OnchainDataApiGetLatestBalancesForContractRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBalancesForContract(requestParameters: OnchainDataApiGetLatestBalancesForContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddressBalancePagedResponse> {
            return localVarFp.getLatestBalancesForContract(requestParameters.baseAssetId, requestParameters.contractAddress, requestParameters.accountAddress, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sortBy, requestParameters.order, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of onchain transactions for the specified contract address and base asset ID, optionally filtered by date range.
         * @summary Fetch onchain transactions for a contract
         * @param {OnchainDataApiGetOnchainTransactionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnchainTransactions(requestParameters: OnchainDataApiGetOnchainTransactionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<OnchainTransactionsPagedResponse> {
            return localVarFp.getOnchainTransactions(requestParameters.baseAssetId, requestParameters.contractAddress, requestParameters.startDate, requestParameters.endDate, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sortBy, requestParameters.order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAccessRegistryCurrentState operation in OnchainDataApi.
 * @export
 * @interface OnchainDataApiGetAccessRegistryCurrentStateRequest
 */
export interface OnchainDataApiGetAccessRegistryCurrentStateRequest {
    /**
     * The blockchain base assetId
     * @type {string}
     * @memberof OnchainDataApiGetAccessRegistryCurrentState
     */
    readonly baseAssetId: string

    /**
     * The access registry address
     * @type {string}
     * @memberof OnchainDataApiGetAccessRegistryCurrentState
     */
    readonly accessRegistryAddress: string

    /**
     * Page cursor to get the next page\&quot;
     * @type {string}
     * @memberof OnchainDataApiGetAccessRegistryCurrentState
     */
    readonly pageCursor?: string

    /**
     * Number of items per page (max 100), requesting more then 100 will return 100 items
     * @type {number}
     * @memberof OnchainDataApiGetAccessRegistryCurrentState
     */
    readonly pageSize?: number

    /**
     * Sorting field (enum).
     * @type {'dateAdded' | 'address'}
     * @memberof OnchainDataApiGetAccessRegistryCurrentState
     */
    readonly sortBy?: GetAccessRegistryCurrentStateSortByEnum

    /**
     * ASC / DESC ordering (default DESC)
     * @type {'ASC' | 'DESC'}
     * @memberof OnchainDataApiGetAccessRegistryCurrentState
     */
    readonly order?: GetAccessRegistryCurrentStateOrderEnum
}

/**
 * Request parameters for getAccessRegistrySummary operation in OnchainDataApi.
 * @export
 * @interface OnchainDataApiGetAccessRegistrySummaryRequest
 */
export interface OnchainDataApiGetAccessRegistrySummaryRequest {
    /**
     * The blockchain base assetId
     * @type {string}
     * @memberof OnchainDataApiGetAccessRegistrySummary
     */
    readonly baseAssetId: string

    /**
     * The access registry address
     * @type {string}
     * @memberof OnchainDataApiGetAccessRegistrySummary
     */
    readonly accessRegistryAddress: string
}

/**
 * Request parameters for getActiveRolesForContract operation in OnchainDataApi.
 * @export
 * @interface OnchainDataApiGetActiveRolesForContractRequest
 */
export interface OnchainDataApiGetActiveRolesForContractRequest {
    /**
     * The blockchain base assetId
     * @type {string}
     * @memberof OnchainDataApiGetActiveRolesForContract
     */
    readonly baseAssetId: string

    /**
     * The contract address
     * @type {string}
     * @memberof OnchainDataApiGetActiveRolesForContract
     */
    readonly contractAddress: string
}

/**
 * Request parameters for getContractBalanceHistory operation in OnchainDataApi.
 * @export
 * @interface OnchainDataApiGetContractBalanceHistoryRequest
 */
export interface OnchainDataApiGetContractBalanceHistoryRequest {
    /**
     * The blockchain base assetId
     * @type {string}
     * @memberof OnchainDataApiGetContractBalanceHistory
     */
    readonly baseAssetId: string

    /**
     * The contract address
     * @type {string}
     * @memberof OnchainDataApiGetContractBalanceHistory
     */
    readonly contractAddress: string

    /**
     * The account address to get balance history for
     * @type {string}
     * @memberof OnchainDataApiGetContractBalanceHistory
     */
    readonly accountAddress: string

    /**
     * Start date of the time range in ISO 8601 format
     * @type {string}
     * @memberof OnchainDataApiGetContractBalanceHistory
     */
    readonly startDate?: string

    /**
     * End date of the time range in ISO 8601 format
     * @type {string}
     * @memberof OnchainDataApiGetContractBalanceHistory
     */
    readonly endDate?: string

    /**
     * Time interval for grouping data
     * @type {'hour' | 'day' | 'week' | 'month'}
     * @memberof OnchainDataApiGetContractBalanceHistory
     */
    readonly interval?: GetContractBalanceHistoryIntervalEnum

    /**
     * Page cursor to get the next page\&quot;
     * @type {string}
     * @memberof OnchainDataApiGetContractBalanceHistory
     */
    readonly pageCursor?: string

    /**
     * Number of items per page (max 100), requesting more then 100 will return 100 items
     * @type {number}
     * @memberof OnchainDataApiGetContractBalanceHistory
     */
    readonly pageSize?: number

    /**
     * Sorting field (enum). Sorting only supported by \&#39;blockTimestamp\&#39;
     * @type {'blockTimestamp'}
     * @memberof OnchainDataApiGetContractBalanceHistory
     */
    readonly sortBy?: GetContractBalanceHistorySortByEnum

    /**
     * ASC / DESC ordering (default DESC)
     * @type {'ASC' | 'DESC'}
     * @memberof OnchainDataApiGetContractBalanceHistory
     */
    readonly order?: GetContractBalanceHistoryOrderEnum
}

/**
 * Request parameters for getContractBalancesSummary operation in OnchainDataApi.
 * @export
 * @interface OnchainDataApiGetContractBalancesSummaryRequest
 */
export interface OnchainDataApiGetContractBalancesSummaryRequest {
    /**
     * The blockchain base assetId
     * @type {string}
     * @memberof OnchainDataApiGetContractBalancesSummary
     */
    readonly baseAssetId: string

    /**
     * The contract address
     * @type {string}
     * @memberof OnchainDataApiGetContractBalancesSummary
     */
    readonly contractAddress: string
}

/**
 * Request parameters for getContractTotalSupply operation in OnchainDataApi.
 * @export
 * @interface OnchainDataApiGetContractTotalSupplyRequest
 */
export interface OnchainDataApiGetContractTotalSupplyRequest {
    /**
     * The blockchain base assetId
     * @type {string}
     * @memberof OnchainDataApiGetContractTotalSupply
     */
    readonly baseAssetId: string

    /**
     * The contract address
     * @type {string}
     * @memberof OnchainDataApiGetContractTotalSupply
     */
    readonly contractAddress: string

    /**
     * Start date of the time range in ISO 8601 format
     * @type {string}
     * @memberof OnchainDataApiGetContractTotalSupply
     */
    readonly startDate?: string

    /**
     * End date of the time range in ISO 8601 format
     * @type {string}
     * @memberof OnchainDataApiGetContractTotalSupply
     */
    readonly endDate?: string

    /**
     * Time interval for grouping data
     * @type {'hour' | 'day' | 'week' | 'month'}
     * @memberof OnchainDataApiGetContractTotalSupply
     */
    readonly interval?: GetContractTotalSupplyIntervalEnum

    /**
     * Page cursor to get the next page\&quot;
     * @type {string}
     * @memberof OnchainDataApiGetContractTotalSupply
     */
    readonly pageCursor?: string

    /**
     * Number of items per page (max 100), requesting more then 100 will return 100 items
     * @type {number}
     * @memberof OnchainDataApiGetContractTotalSupply
     */
    readonly pageSize?: number

    /**
     * Sorting field (enum). Sorting only supported by \&#39;blockTimestamp\&#39;
     * @type {'blockTimestamp'}
     * @memberof OnchainDataApiGetContractTotalSupply
     */
    readonly sortBy?: GetContractTotalSupplySortByEnum

    /**
     * ASC / DESC ordering (default DESC)
     * @type {'ASC' | 'DESC'}
     * @memberof OnchainDataApiGetContractTotalSupply
     */
    readonly order?: GetContractTotalSupplyOrderEnum
}

/**
 * Request parameters for getLatestBalancesForContract operation in OnchainDataApi.
 * @export
 * @interface OnchainDataApiGetLatestBalancesForContractRequest
 */
export interface OnchainDataApiGetLatestBalancesForContractRequest {
    /**
     * The blockchain base assetId
     * @type {string}
     * @memberof OnchainDataApiGetLatestBalancesForContract
     */
    readonly baseAssetId: string

    /**
     * The contract address
     * @type {string}
     * @memberof OnchainDataApiGetLatestBalancesForContract
     */
    readonly contractAddress: string

    /**
     * Optional filter to get balance for a specific account address
     * @type {string}
     * @memberof OnchainDataApiGetLatestBalancesForContract
     */
    readonly accountAddress?: string

    /**
     * Page cursor to get the next page\&quot;
     * @type {string}
     * @memberof OnchainDataApiGetLatestBalancesForContract
     */
    readonly pageCursor?: string

    /**
     * Number of items per page (max 100), requesting more then 100 will return 100 items
     * @type {number}
     * @memberof OnchainDataApiGetLatestBalancesForContract
     */
    readonly pageSize?: number

    /**
     * Sorting field for balances
     * @type {'accountAddress' | 'blockTimestamp'}
     * @memberof OnchainDataApiGetLatestBalancesForContract
     */
    readonly sortBy?: GetLatestBalancesForContractSortByEnum

    /**
     * ASC / DESC ordering (default DESC)
     * @type {'ASC' | 'DESC'}
     * @memberof OnchainDataApiGetLatestBalancesForContract
     */
    readonly order?: GetLatestBalancesForContractOrderEnum
}

/**
 * Request parameters for getOnchainTransactions operation in OnchainDataApi.
 * @export
 * @interface OnchainDataApiGetOnchainTransactionsRequest
 */
export interface OnchainDataApiGetOnchainTransactionsRequest {
    /**
     * The blockchain base assetId
     * @type {string}
     * @memberof OnchainDataApiGetOnchainTransactions
     */
    readonly baseAssetId: string

    /**
     * The contract address
     * @type {string}
     * @memberof OnchainDataApiGetOnchainTransactions
     */
    readonly contractAddress: string

    /**
     * Start date of the time range in ISO 8601 format
     * @type {string}
     * @memberof OnchainDataApiGetOnchainTransactions
     */
    readonly startDate?: string

    /**
     * End date of the time range in ISO 8601 format
     * @type {string}
     * @memberof OnchainDataApiGetOnchainTransactions
     */
    readonly endDate?: string

    /**
     * Page cursor to get the next page\&quot;
     * @type {string}
     * @memberof OnchainDataApiGetOnchainTransactions
     */
    readonly pageCursor?: string

    /**
     * Number of items per page (max 100), requesting more then 100 will return 100 items
     * @type {number}
     * @memberof OnchainDataApiGetOnchainTransactions
     */
    readonly pageSize?: number

    /**
     * Sorting field (enum).
     * @type {'blockTimestamp' | 'blockNumber' | 'transactionHash'}
     * @memberof OnchainDataApiGetOnchainTransactions
     */
    readonly sortBy?: GetOnchainTransactionsSortByEnum

    /**
     * ASC / DESC ordering (default DESC)
     * @type {'ASC' | 'DESC'}
     * @memberof OnchainDataApiGetOnchainTransactions
     */
    readonly order?: GetOnchainTransactionsOrderEnum
}

/**
 * OnchainDataApi - object-oriented interface
 * @export
 * @class OnchainDataApi
 * @extends {BaseAPI}
 */
export class OnchainDataApi extends BaseAPI {
    /**
     * Returns the current state of addresses in the specified access registry. Only addresses that are currently active (added but not removed) are included.
     * @summary Get the current state of addresses in an access registry
     * @param {OnchainDataApiGetAccessRegistryCurrentStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnchainDataApi
     */
    public getAccessRegistryCurrentState(requestParameters: OnchainDataApiGetAccessRegistryCurrentStateRequest) {
        return OnchainDataApiFp(this.configuration).getAccessRegistryCurrentState(requestParameters.baseAssetId, requestParameters.accessRegistryAddress, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sortBy, requestParameters.order).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns a summary of the current state of the access registry for the specified baseAssetId and accessRegistryAddress.
     * @summary Summary of access registry state
     * @param {OnchainDataApiGetAccessRegistrySummaryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnchainDataApi
     */
    public getAccessRegistrySummary(requestParameters: OnchainDataApiGetAccessRegistrySummaryRequest) {
        return OnchainDataApiFp(this.configuration).getAccessRegistrySummary(requestParameters.baseAssetId, requestParameters.accessRegistryAddress).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns a list of currently active roles for the specified baseAssetId and contractAddress.
     * @summary List of active roles for a given contract address and base asset ID
     * @param {OnchainDataApiGetActiveRolesForContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnchainDataApi
     */
    public getActiveRolesForContract(requestParameters: OnchainDataApiGetActiveRolesForContractRequest) {
        return OnchainDataApiFp(this.configuration).getActiveRolesForContract(requestParameters.baseAssetId, requestParameters.contractAddress).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns the paginated balance history of the specified account in a contract with optional date range and interval filtering.
     * @summary Get historical balance data for a specific account in a contract
     * @param {OnchainDataApiGetContractBalanceHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnchainDataApi
     */
    public getContractBalanceHistory(requestParameters: OnchainDataApiGetContractBalanceHistoryRequest) {
        return OnchainDataApiFp(this.configuration).getContractBalanceHistory(requestParameters.baseAssetId, requestParameters.contractAddress, requestParameters.accountAddress, requestParameters.startDate, requestParameters.endDate, requestParameters.interval, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sortBy, requestParameters.order).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns the total number of unique addresses holding balances and the total supply for the specified contract.
     * @summary Get summary for the token contract
     * @param {OnchainDataApiGetContractBalancesSummaryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnchainDataApi
     */
    public getContractBalancesSummary(requestParameters: OnchainDataApiGetContractBalancesSummaryRequest) {
        return OnchainDataApiFp(this.configuration).getContractBalancesSummary(requestParameters.baseAssetId, requestParameters.contractAddress).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns the paginated total supply history of the specified contract with optional date range and interval filtering.
     * @summary Get historical total supply data for a contract
     * @param {OnchainDataApiGetContractTotalSupplyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnchainDataApi
     */
    public getContractTotalSupply(requestParameters: OnchainDataApiGetContractTotalSupplyRequest) {
        return OnchainDataApiFp(this.configuration).getContractTotalSupply(requestParameters.baseAssetId, requestParameters.contractAddress, requestParameters.startDate, requestParameters.endDate, requestParameters.interval, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sortBy, requestParameters.order).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns the latest balance for each unique address with support for numeric balance sorting. The `prev` cursor is reserved for future support.
     * @summary Get latest balances for all addresses holding tokens from a contract
     * @param {OnchainDataApiGetLatestBalancesForContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnchainDataApi
     */
    public getLatestBalancesForContract(requestParameters: OnchainDataApiGetLatestBalancesForContractRequest) {
        return OnchainDataApiFp(this.configuration).getLatestBalancesForContract(requestParameters.baseAssetId, requestParameters.contractAddress, requestParameters.accountAddress, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sortBy, requestParameters.order).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns a paginated list of onchain transactions for the specified contract address and base asset ID, optionally filtered by date range.
     * @summary Fetch onchain transactions for a contract
     * @param {OnchainDataApiGetOnchainTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnchainDataApi
     */
    public getOnchainTransactions(requestParameters: OnchainDataApiGetOnchainTransactionsRequest) {
        return OnchainDataApiFp(this.configuration).getOnchainTransactions(requestParameters.baseAssetId, requestParameters.contractAddress, requestParameters.startDate, requestParameters.endDate, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sortBy, requestParameters.order).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }
}

/**
 * @export
 */
export const GetAccessRegistryCurrentStateSortByEnum = {
    DateAdded: 'dateAdded',
    Address: 'address'
} as const;
export type GetAccessRegistryCurrentStateSortByEnum = typeof GetAccessRegistryCurrentStateSortByEnum[keyof typeof GetAccessRegistryCurrentStateSortByEnum];
/**
 * @export
 */
export const GetAccessRegistryCurrentStateOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type GetAccessRegistryCurrentStateOrderEnum = typeof GetAccessRegistryCurrentStateOrderEnum[keyof typeof GetAccessRegistryCurrentStateOrderEnum];
/**
 * @export
 */
export const GetContractBalanceHistoryIntervalEnum = {
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;
export type GetContractBalanceHistoryIntervalEnum = typeof GetContractBalanceHistoryIntervalEnum[keyof typeof GetContractBalanceHistoryIntervalEnum];
/**
 * @export
 */
export const GetContractBalanceHistorySortByEnum = {
    BlockTimestamp: 'blockTimestamp'
} as const;
export type GetContractBalanceHistorySortByEnum = typeof GetContractBalanceHistorySortByEnum[keyof typeof GetContractBalanceHistorySortByEnum];
/**
 * @export
 */
export const GetContractBalanceHistoryOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type GetContractBalanceHistoryOrderEnum = typeof GetContractBalanceHistoryOrderEnum[keyof typeof GetContractBalanceHistoryOrderEnum];
/**
 * @export
 */
export const GetContractTotalSupplyIntervalEnum = {
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;
export type GetContractTotalSupplyIntervalEnum = typeof GetContractTotalSupplyIntervalEnum[keyof typeof GetContractTotalSupplyIntervalEnum];
/**
 * @export
 */
export const GetContractTotalSupplySortByEnum = {
    BlockTimestamp: 'blockTimestamp'
} as const;
export type GetContractTotalSupplySortByEnum = typeof GetContractTotalSupplySortByEnum[keyof typeof GetContractTotalSupplySortByEnum];
/**
 * @export
 */
export const GetContractTotalSupplyOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type GetContractTotalSupplyOrderEnum = typeof GetContractTotalSupplyOrderEnum[keyof typeof GetContractTotalSupplyOrderEnum];
/**
 * @export
 */
export const GetLatestBalancesForContractSortByEnum = {
    AccountAddress: 'accountAddress',
    BlockTimestamp: 'blockTimestamp'
} as const;
export type GetLatestBalancesForContractSortByEnum = typeof GetLatestBalancesForContractSortByEnum[keyof typeof GetLatestBalancesForContractSortByEnum];
/**
 * @export
 */
export const GetLatestBalancesForContractOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type GetLatestBalancesForContractOrderEnum = typeof GetLatestBalancesForContractOrderEnum[keyof typeof GetLatestBalancesForContractOrderEnum];
/**
 * @export
 */
export const GetOnchainTransactionsSortByEnum = {
    BlockTimestamp: 'blockTimestamp',
    BlockNumber: 'blockNumber',
    TransactionHash: 'transactionHash'
} as const;
export type GetOnchainTransactionsSortByEnum = typeof GetOnchainTransactionsSortByEnum[keyof typeof GetOnchainTransactionsSortByEnum];
/**
 * @export
 */
export const GetOnchainTransactionsOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type GetOnchainTransactionsOrderEnum = typeof GetOnchainTransactionsOrderEnum[keyof typeof GetOnchainTransactionsOrderEnum];
