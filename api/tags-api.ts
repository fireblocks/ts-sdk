/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * Fireblocks provides a suite of applications to manage digital asset operations and a complete development platform to build your business on the blockchain.  - Visit our website for more information: [Fireblocks Website](https://fireblocks.com) - Visit our developer docs: [Fireblocks DevPortal](https://developers.fireblocks.com) 
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: developers@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import { convertToFireblocksResponse } from "../response/fireblocksResponse";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import { assertParamExistsAndNotEmpty } from '../utils/validation_utils';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { ApprovalRequest } from '../models';
// @ts-ignore
import { CreateTagRequest } from '../models';
// @ts-ignore
import { ErrorResponse } from '../models';
// @ts-ignore
import { ErrorSchema } from '../models';
// @ts-ignore
import { Tag } from '../models';
// @ts-ignore
import { TagsPagedResponse } from '../models';
// @ts-ignore
import { UpdateTagRequest } from '../models';
/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel an approval request by id. Can only cancel requests in PENDING status. Returns 202 Accepted when the cancellation is processed.
         * @summary Cancel an approval request by id
         * @param {string} id 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelApprovalRequest: async (id: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('cancelApprovalRequest', 'id', id)
            const localVarPath = `/tags/approval_requests/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new tag. Endpoint Permissions: For protected tags: ADMIN,NON_SIGNING_ADMIN,OWNER. For non protected tags: ADMIN,NON_SIGNING_ADMIN,OWNER,SIGNER,EDITOR,APPROVER.
         * @summary Create a new tag
         * @param {CreateTagRequest} createTagRequest 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (createTagRequest: CreateTagRequest, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('createTag', 'createTagRequest', createTagRequest)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified tag. Endpoint Permission: For protected tags: Owner, Admin, Non-Signing Admin. For non protected tags: Owner, Admin, Non-Signing Admin, Signer, Editor, Approver.
         * @summary Delete a tag
         * @param {string} tagId The ID of the tag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tagId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('deleteTag', 'tagId', tagId)
            const localVarPath = `/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an approval request by id
         * @summary Get an approval request by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalRequest: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getApprovalRequest', 'id', id)
            const localVarPath = `/tags/approval_requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an existing tag by ID.
         * @summary Get a tag
         * @param {string} tagId The ID of the tag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag: async (tagId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getTag', 'tagId', tagId)
            const localVarPath = `/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a paged list of all tags according to filters.
         * @summary Get list of tags
         * @param {string} [pageCursor] Page cursor to get the next page.
         * @param {number} [pageSize] Maximum number of items in the page
         * @param {string} [label] Label prefix to filter by.
         * @param {Array<string>} [tagIds] List of tag IDs to filter by.
         * @param {boolean} [includePendingApprovalsInfo] Whether to include pending approval requests info.
         * @param {boolean} [isProtected] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (pageCursor?: string, pageSize?: number, label?: string, tagIds?: Array<string>, includePendingApprovalsInfo?: boolean, isProtected?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (tagIds) {
                localVarQueryParameter['tagIds'] = tagIds;
            }

            if (includePendingApprovalsInfo !== undefined) {
                localVarQueryParameter['includePendingApprovalsInfo'] = includePendingApprovalsInfo;
            }

            if (isProtected !== undefined) {
                localVarQueryParameter['isProtected'] = isProtected;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing specified tag. Endpoint Permission: For protected tags: Owner, Admin, Non-Signing Admin. For non protected tags: Owner, Admin, Non-Signing Admin, Signer, Editor, Approver.
         * @summary Update a tag
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {string} tagId The ID of the tag to update
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (updateTagRequest: UpdateTagRequest, tagId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('updateTag', 'updateTagRequest', updateTagRequest)
            assertParamExistsAndNotEmpty('updateTag', 'tagId', tagId)
            const localVarPath = `/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel an approval request by id. Can only cancel requests in PENDING status. Returns 202 Accepted when the cancellation is processed.
         * @summary Cancel an approval request by id
         * @param {string} id 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelApprovalRequest(id: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelApprovalRequest(id, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TagsApi.cancelApprovalRequest']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a new tag. Endpoint Permissions: For protected tags: ADMIN,NON_SIGNING_ADMIN,OWNER. For non protected tags: ADMIN,NON_SIGNING_ADMIN,OWNER,SIGNER,EDITOR,APPROVER.
         * @summary Create a new tag
         * @param {CreateTagRequest} createTagRequest 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(createTagRequest: CreateTagRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(createTagRequest, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TagsApi.createTag']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete the specified tag. Endpoint Permission: For protected tags: Owner, Admin, Non-Signing Admin. For non protected tags: Owner, Admin, Non-Signing Admin, Signer, Editor, Approver.
         * @summary Delete a tag
         * @param {string} tagId The ID of the tag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tagId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tagId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TagsApi.deleteTag']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get an approval request by id
         * @summary Get an approval request by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApprovalRequest(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovalRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApprovalRequest(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TagsApi.getApprovalRequest']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve an existing tag by ID.
         * @summary Get a tag
         * @param {string} tagId The ID of the tag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTag(tagId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTag(tagId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TagsApi.getTag']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve a paged list of all tags according to filters.
         * @summary Get list of tags
         * @param {string} [pageCursor] Page cursor to get the next page.
         * @param {number} [pageSize] Maximum number of items in the page
         * @param {string} [label] Label prefix to filter by.
         * @param {Array<string>} [tagIds] List of tag IDs to filter by.
         * @param {boolean} [includePendingApprovalsInfo] Whether to include pending approval requests info.
         * @param {boolean} [isProtected] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(pageCursor?: string, pageSize?: number, label?: string, tagIds?: Array<string>, includePendingApprovalsInfo?: boolean, isProtected?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsPagedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(pageCursor, pageSize, label, tagIds, includePendingApprovalsInfo, isProtected, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TagsApi.getTags']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update an existing specified tag. Endpoint Permission: For protected tags: Owner, Admin, Non-Signing Admin. For non protected tags: Owner, Admin, Non-Signing Admin, Signer, Editor, Approver.
         * @summary Update a tag
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {string} tagId The ID of the tag to update
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(updateTagRequest: UpdateTagRequest, tagId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(updateTagRequest, tagId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TagsApi.updateTag']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Cancel an approval request by id. Can only cancel requests in PENDING status. Returns 202 Accepted when the cancellation is processed.
         * @summary Cancel an approval request by id
         * @param {TagsApiCancelApprovalRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelApprovalRequest(requestParameters: TagsApiCancelApprovalRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelApprovalRequest(requestParameters.id, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new tag. Endpoint Permissions: For protected tags: ADMIN,NON_SIGNING_ADMIN,OWNER. For non protected tags: ADMIN,NON_SIGNING_ADMIN,OWNER,SIGNER,EDITOR,APPROVER.
         * @summary Create a new tag
         * @param {TagsApiCreateTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(requestParameters: TagsApiCreateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.createTag(requestParameters.createTagRequest, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the specified tag. Endpoint Permission: For protected tags: Owner, Admin, Non-Signing Admin. For non protected tags: Owner, Admin, Non-Signing Admin, Signer, Editor, Approver.
         * @summary Delete a tag
         * @param {TagsApiDeleteTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(requestParameters: TagsApiDeleteTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTag(requestParameters.tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an approval request by id
         * @summary Get an approval request by id
         * @param {TagsApiGetApprovalRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalRequest(requestParameters: TagsApiGetApprovalRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApprovalRequest> {
            return localVarFp.getApprovalRequest(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an existing tag by ID.
         * @summary Get a tag
         * @param {TagsApiGetTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(requestParameters: TagsApiGetTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.getTag(requestParameters.tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a paged list of all tags according to filters.
         * @summary Get list of tags
         * @param {TagsApiGetTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(requestParameters: TagsApiGetTagsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<TagsPagedResponse> {
            return localVarFp.getTags(requestParameters.pageCursor, requestParameters.pageSize, requestParameters.label, requestParameters.tagIds, requestParameters.includePendingApprovalsInfo, requestParameters.isProtected, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing specified tag. Endpoint Permission: For protected tags: Owner, Admin, Non-Signing Admin. For non protected tags: Owner, Admin, Non-Signing Admin, Signer, Editor, Approver.
         * @summary Update a tag
         * @param {TagsApiUpdateTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(requestParameters: TagsApiUpdateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.updateTag(requestParameters.updateTagRequest, requestParameters.tagId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelApprovalRequest operation in TagsApi.
 * @export
 * @interface TagsApiCancelApprovalRequestRequest
 */
export interface TagsApiCancelApprovalRequestRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiCancelApprovalRequest
     */
    readonly id: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof TagsApiCancelApprovalRequest
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for createTag operation in TagsApi.
 * @export
 * @interface TagsApiCreateTagRequest
 */
export interface TagsApiCreateTagRequest {
    /**
     * 
     * @type {CreateTagRequest}
     * @memberof TagsApiCreateTag
     */
    readonly createTagRequest: CreateTagRequest

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof TagsApiCreateTag
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for deleteTag operation in TagsApi.
 * @export
 * @interface TagsApiDeleteTagRequest
 */
export interface TagsApiDeleteTagRequest {
    /**
     * The ID of the tag to retrieve
     * @type {string}
     * @memberof TagsApiDeleteTag
     */
    readonly tagId: string
}

/**
 * Request parameters for getApprovalRequest operation in TagsApi.
 * @export
 * @interface TagsApiGetApprovalRequestRequest
 */
export interface TagsApiGetApprovalRequestRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiGetApprovalRequest
     */
    readonly id: string
}

/**
 * Request parameters for getTag operation in TagsApi.
 * @export
 * @interface TagsApiGetTagRequest
 */
export interface TagsApiGetTagRequest {
    /**
     * The ID of the tag to retrieve
     * @type {string}
     * @memberof TagsApiGetTag
     */
    readonly tagId: string
}

/**
 * Request parameters for getTags operation in TagsApi.
 * @export
 * @interface TagsApiGetTagsRequest
 */
export interface TagsApiGetTagsRequest {
    /**
     * Page cursor to get the next page.
     * @type {string}
     * @memberof TagsApiGetTags
     */
    readonly pageCursor?: string

    /**
     * Maximum number of items in the page
     * @type {number}
     * @memberof TagsApiGetTags
     */
    readonly pageSize?: number

    /**
     * Label prefix to filter by.
     * @type {string}
     * @memberof TagsApiGetTags
     */
    readonly label?: string

    /**
     * List of tag IDs to filter by.
     * @type {Array<string>}
     * @memberof TagsApiGetTags
     */
    readonly tagIds?: Array<string>

    /**
     * Whether to include pending approval requests info.
     * @type {boolean}
     * @memberof TagsApiGetTags
     */
    readonly includePendingApprovalsInfo?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TagsApiGetTags
     */
    readonly isProtected?: boolean
}

/**
 * Request parameters for updateTag operation in TagsApi.
 * @export
 * @interface TagsApiUpdateTagRequest
 */
export interface TagsApiUpdateTagRequest {
    /**
     * 
     * @type {UpdateTagRequest}
     * @memberof TagsApiUpdateTag
     */
    readonly updateTagRequest: UpdateTagRequest

    /**
     * The ID of the tag to update
     * @type {string}
     * @memberof TagsApiUpdateTag
     */
    readonly tagId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof TagsApiUpdateTag
     */
    readonly idempotencyKey?: string
}

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Cancel an approval request by id. Can only cancel requests in PENDING status. Returns 202 Accepted when the cancellation is processed.
     * @summary Cancel an approval request by id
     * @param {TagsApiCancelApprovalRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public cancelApprovalRequest(requestParameters: TagsApiCancelApprovalRequestRequest) {
        return TagsApiFp(this.configuration).cancelApprovalRequest(requestParameters.id, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Create a new tag. Endpoint Permissions: For protected tags: ADMIN,NON_SIGNING_ADMIN,OWNER. For non protected tags: ADMIN,NON_SIGNING_ADMIN,OWNER,SIGNER,EDITOR,APPROVER.
     * @summary Create a new tag
     * @param {TagsApiCreateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public createTag(requestParameters: TagsApiCreateTagRequest) {
        return TagsApiFp(this.configuration).createTag(requestParameters.createTagRequest, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Delete the specified tag. Endpoint Permission: For protected tags: Owner, Admin, Non-Signing Admin. For non protected tags: Owner, Admin, Non-Signing Admin, Signer, Editor, Approver.
     * @summary Delete a tag
     * @param {TagsApiDeleteTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteTag(requestParameters: TagsApiDeleteTagRequest) {
        return TagsApiFp(this.configuration).deleteTag(requestParameters.tagId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Get an approval request by id
     * @summary Get an approval request by id
     * @param {TagsApiGetApprovalRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getApprovalRequest(requestParameters: TagsApiGetApprovalRequestRequest) {
        return TagsApiFp(this.configuration).getApprovalRequest(requestParameters.id).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Retrieve an existing tag by ID.
     * @summary Get a tag
     * @param {TagsApiGetTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTag(requestParameters: TagsApiGetTagRequest) {
        return TagsApiFp(this.configuration).getTag(requestParameters.tagId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Retrieve a paged list of all tags according to filters.
     * @summary Get list of tags
     * @param {TagsApiGetTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTags(requestParameters: TagsApiGetTagsRequest = {}) {
        return TagsApiFp(this.configuration).getTags(requestParameters.pageCursor, requestParameters.pageSize, requestParameters.label, requestParameters.tagIds, requestParameters.includePendingApprovalsInfo, requestParameters.isProtected).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Update an existing specified tag. Endpoint Permission: For protected tags: Owner, Admin, Non-Signing Admin. For non protected tags: Owner, Admin, Non-Signing Admin, Signer, Editor, Approver.
     * @summary Update a tag
     * @param {TagsApiUpdateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTag(requestParameters: TagsApiUpdateTagRequest) {
        return TagsApiFp(this.configuration).updateTag(requestParameters.updateTagRequest, requestParameters.tagId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }
}

