/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import { convertToFireblocksResponse } from "../response/fireblocksResponse";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import { assertParamExistsAndNotEmpty } from '../utils/validation_utils';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { CreateTagRequest } from '../models';
// @ts-ignore
import { Tag } from '../models';
// @ts-ignore
import { TagsPagedResponse } from '../models';
// @ts-ignore
import { UpdateTagRequest } from '../models';
/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new tag.
         * @summary Create a tag
         * @param {CreateTagRequest} createTagRequest 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (createTagRequest: CreateTagRequest, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('createTag', 'createTagRequest', createTagRequest)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified tag.
         * @summary Delete a tag
         * @param {string} tagId The ID of the tag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tagId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('deleteTag', 'tagId', tagId)
            const localVarPath = `/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an existing tag by ID.
         * @summary Get a tag
         * @param {string} tagId The ID of the tag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag: async (tagId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getTag', 'tagId', tagId)
            const localVarPath = `/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a paged list of all tags according to filters.
         * @summary Get list of tags
         * @param {string} [pageCursor] Page cursor to get the next page.
         * @param {number} [pageSize] Maximum number of items in the page
         * @param {string} [label] Label prefix to filter by.
         * @param {Array<string>} [tagIds] List of tag IDs to filter by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (pageCursor?: string, pageSize?: number, label?: string, tagIds?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (tagIds) {
                localVarQueryParameter['tagIds'] = tagIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing specified tag.
         * @summary Update a tag
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {string} tagId The ID of the tag to update
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (updateTagRequest: UpdateTagRequest, tagId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('updateTag', 'updateTagRequest', updateTagRequest)
            assertParamExistsAndNotEmpty('updateTag', 'tagId', tagId)
            const localVarPath = `/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new tag.
         * @summary Create a tag
         * @param {CreateTagRequest} createTagRequest 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(createTagRequest: CreateTagRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(createTagRequest, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TagsApi.createTag']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete the specified tag.
         * @summary Delete a tag
         * @param {string} tagId The ID of the tag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tagId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tagId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TagsApi.deleteTag']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve an existing tag by ID.
         * @summary Get a tag
         * @param {string} tagId The ID of the tag to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTag(tagId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTag(tagId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TagsApi.getTag']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve a paged list of all tags according to filters.
         * @summary Get list of tags
         * @param {string} [pageCursor] Page cursor to get the next page.
         * @param {number} [pageSize] Maximum number of items in the page
         * @param {string} [label] Label prefix to filter by.
         * @param {Array<string>} [tagIds] List of tag IDs to filter by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(pageCursor?: string, pageSize?: number, label?: string, tagIds?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsPagedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(pageCursor, pageSize, label, tagIds, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TagsApi.getTags']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update an existing specified tag.
         * @summary Update a tag
         * @param {UpdateTagRequest} updateTagRequest 
         * @param {string} tagId The ID of the tag to update
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(updateTagRequest: UpdateTagRequest, tagId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(updateTagRequest, tagId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TagsApi.updateTag']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Create a new tag.
         * @summary Create a tag
         * @param {TagsApiCreateTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(requestParameters: TagsApiCreateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.createTag(requestParameters.createTagRequest, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the specified tag.
         * @summary Delete a tag
         * @param {TagsApiDeleteTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(requestParameters: TagsApiDeleteTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTag(requestParameters.tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an existing tag by ID.
         * @summary Get a tag
         * @param {TagsApiGetTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(requestParameters: TagsApiGetTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.getTag(requestParameters.tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a paged list of all tags according to filters.
         * @summary Get list of tags
         * @param {TagsApiGetTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(requestParameters: TagsApiGetTagsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<TagsPagedResponse> {
            return localVarFp.getTags(requestParameters.pageCursor, requestParameters.pageSize, requestParameters.label, requestParameters.tagIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing specified tag.
         * @summary Update a tag
         * @param {TagsApiUpdateTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(requestParameters: TagsApiUpdateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.updateTag(requestParameters.updateTagRequest, requestParameters.tagId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTag operation in TagsApi.
 * @export
 * @interface TagsApiCreateTagRequest
 */
export interface TagsApiCreateTagRequest {
    /**
     * 
     * @type {CreateTagRequest}
     * @memberof TagsApiCreateTag
     */
    readonly createTagRequest: CreateTagRequest

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof TagsApiCreateTag
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for deleteTag operation in TagsApi.
 * @export
 * @interface TagsApiDeleteTagRequest
 */
export interface TagsApiDeleteTagRequest {
    /**
     * The ID of the tag to retrieve
     * @type {string}
     * @memberof TagsApiDeleteTag
     */
    readonly tagId: string
}

/**
 * Request parameters for getTag operation in TagsApi.
 * @export
 * @interface TagsApiGetTagRequest
 */
export interface TagsApiGetTagRequest {
    /**
     * The ID of the tag to retrieve
     * @type {string}
     * @memberof TagsApiGetTag
     */
    readonly tagId: string
}

/**
 * Request parameters for getTags operation in TagsApi.
 * @export
 * @interface TagsApiGetTagsRequest
 */
export interface TagsApiGetTagsRequest {
    /**
     * Page cursor to get the next page.
     * @type {string}
     * @memberof TagsApiGetTags
     */
    readonly pageCursor?: string

    /**
     * Maximum number of items in the page
     * @type {number}
     * @memberof TagsApiGetTags
     */
    readonly pageSize?: number

    /**
     * Label prefix to filter by.
     * @type {string}
     * @memberof TagsApiGetTags
     */
    readonly label?: string

    /**
     * List of tag IDs to filter by.
     * @type {Array<string>}
     * @memberof TagsApiGetTags
     */
    readonly tagIds?: Array<string>
}

/**
 * Request parameters for updateTag operation in TagsApi.
 * @export
 * @interface TagsApiUpdateTagRequest
 */
export interface TagsApiUpdateTagRequest {
    /**
     * 
     * @type {UpdateTagRequest}
     * @memberof TagsApiUpdateTag
     */
    readonly updateTagRequest: UpdateTagRequest

    /**
     * The ID of the tag to update
     * @type {string}
     * @memberof TagsApiUpdateTag
     */
    readonly tagId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof TagsApiUpdateTag
     */
    readonly idempotencyKey?: string
}

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Create a new tag.
     * @summary Create a tag
     * @param {TagsApiCreateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public createTag(requestParameters: TagsApiCreateTagRequest) {
        return TagsApiFp(this.configuration).createTag(requestParameters.createTagRequest, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Delete the specified tag.
     * @summary Delete a tag
     * @param {TagsApiDeleteTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteTag(requestParameters: TagsApiDeleteTagRequest) {
        return TagsApiFp(this.configuration).deleteTag(requestParameters.tagId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Retrieve an existing tag by ID.
     * @summary Get a tag
     * @param {TagsApiGetTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTag(requestParameters: TagsApiGetTagRequest) {
        return TagsApiFp(this.configuration).getTag(requestParameters.tagId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Retrieve a paged list of all tags according to filters.
     * @summary Get list of tags
     * @param {TagsApiGetTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTags(requestParameters: TagsApiGetTagsRequest = {}) {
        return TagsApiFp(this.configuration).getTags(requestParameters.pageCursor, requestParameters.pageSize, requestParameters.label, requestParameters.tagIds).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Update an existing specified tag.
     * @summary Update a tag
     * @param {TagsApiUpdateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTag(requestParameters: TagsApiUpdateTagRequest) {
        return TagsApiFp(this.configuration).updateTag(requestParameters.updateTagRequest, requestParameters.tagId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }
}

