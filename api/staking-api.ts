/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * Fireblocks provides a suite of applications to manage digital asset operations and a complete development platform to build your business on the blockchain.  - Visit our website for more information: [Fireblocks Website](https://fireblocks.com) - Visit our developer docs: [Fireblocks DevPortal](https://developers.fireblocks.com) 
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: developers@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import { convertToFireblocksResponse } from "../response/fireblocksResponse";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import { assertParamExistsAndNotEmpty } from '../utils/validation_utils';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { ChainDescriptor } from '../models';
// @ts-ignore
import { ChainInfoResponse } from '../models';
// @ts-ignore
import { ClaimRewardsRequest } from '../models';
// @ts-ignore
import { Delegation } from '../models';
// @ts-ignore
import { DelegationSummary } from '../models';
// @ts-ignore
import { ErrorSchema } from '../models';
// @ts-ignore
import { MergeStakeAccountsRequest } from '../models';
// @ts-ignore
import { MergeStakeAccountsResponse } from '../models';
// @ts-ignore
import { SplitRequest } from '../models';
// @ts-ignore
import { SplitResponse } from '../models';
// @ts-ignore
import { StakeRequest } from '../models';
// @ts-ignore
import { StakeResponse } from '../models';
// @ts-ignore
import { StakingGetAllDelegationsResponse } from '../models';
// @ts-ignore
import { StakingGetChainsResponse } from '../models';
// @ts-ignore
import { StakingGetProvidersResponse } from '../models';
// @ts-ignore
import { StakingGetSummaryByVaultResponse } from '../models';
// @ts-ignore
import { StakingProvider } from '../models';
// @ts-ignore
import { UnstakeRequest } from '../models';
// @ts-ignore
import { WithdrawRequest } from '../models';
/**
 * StakingApi - axios parameter creator
 * @export
 */
export const StakingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approves the provider\'s terms of service. Must be called once before performing any staking operation with this provider.
         * @summary Approve provider terms of service
         * @param {StakingProvider} providerId Unique identifier of the staking provider.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveTermsOfServiceByProviderId: async (providerId: StakingProvider, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('approveTermsOfServiceByProviderId', 'providerId', providerId)
            const localVarPath = `/staking/providers/{providerId}/approveTermsOfService`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Claims available staking rewards for the specified chain and vault. Supported chains: Solana and Polygon (Matic). Behavior depends on protocol reward distribution.
         * @summary Claim accrued rewards
         * @param {ClaimRewardsRequest} claimRewardsRequest 
         * @param {ClaimRewardsChainDescriptorEnum} chainDescriptor Protocol identifier for the claim rewards staking operation (e.g., MATIC/SOL).
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimRewards: async (claimRewardsRequest: ClaimRewardsRequest, chainDescriptor: ClaimRewardsChainDescriptorEnum, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('claimRewards', 'claimRewardsRequest', claimRewardsRequest)
            assertParamExistsAndNotEmpty('claimRewards', 'chainDescriptor', chainDescriptor)
            const localVarPath = `/staking/chains/{chainDescriptor}/claim_rewards`
                .replace(`{${"chainDescriptor"}}`, encodeURIComponent(String(chainDescriptor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(claimRewardsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all staking positions with core details: amounts, rewards, status, chain, and vault. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
         * @summary List staking positions
         * @param {ChainDescriptor} [chainDescriptor] Protocol identifier to filter positions (e.g., ATOM_COS/AXL/CELESTIA}). If omitted, positions across all supported chains are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDelegations: async (chainDescriptor?: ChainDescriptor, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (chainDescriptor !== undefined) {
                localVarQueryParameter['chainDescriptor'] = chainDescriptor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns chain-specific staking information such as epoch/slot cadence, lockup or unbonding periods, fee/reward mechanics, and other operational constraints.
         * @summary Get chain-level staking parameters
         * @param {ChainDescriptor} chainDescriptor Protocol identifier for the chain info staking operation (e.g., ETH/MATIC/SOL).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChainInfo: async (chainDescriptor: ChainDescriptor, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('getChainInfo', 'chainDescriptor', chainDescriptor)
            const localVarPath = `/staking/chains/{chainDescriptor}/chainInfo`
                .replace(`{${"chainDescriptor"}}`, encodeURIComponent(String(chainDescriptor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an alphabetical list of blockchains supported for staking by the current workspace context. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
         * @summary List supported staking chains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChains: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/chains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns full details for a single staking position: amounts, rewards, status, chain, and vault.
         * @summary Get position details
         * @param {string} id Unique identifier of the staking position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegationById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getDelegationById', 'id', id)
            const localVarPath = `/staking/positions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all available staking providers with metadata such as name, ID, and supported chains. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
         * @summary List staking providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an aggregated cross-vault summary: active/inactive counts, total staked, and total rewards per chain.
         * @summary Get positions summary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummary: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/positions/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns per-vault aggregates: status breakdown, total staked, and total rewards per chain.
         * @summary Get positions summary by vault
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummaryByVault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/positions/summary/vaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Merges the source stake account into the destination, consolidating the balance into the destination and closing the source account once complete. Both accounts must be from the same validator provider and of same vault account.. Supported chains: Solana (SOL). </br>Endpoint Permission: Owner, Admin, Non-Signing Admin, Signer, Approver, Editor.
         * @summary Merge staking positions
         * @param {MergeStakeAccountsRequest} mergeStakeAccountsRequest 
         * @param {MergeStakeAccountsChainDescriptorEnum} chainDescriptor Protocol identifier for the merge staking operation (e.g., SOL).
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeStakeAccounts: async (mergeStakeAccountsRequest: MergeStakeAccountsRequest, chainDescriptor: MergeStakeAccountsChainDescriptorEnum, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('mergeStakeAccounts', 'mergeStakeAccountsRequest', mergeStakeAccountsRequest)
            assertParamExistsAndNotEmpty('mergeStakeAccounts', 'chainDescriptor', chainDescriptor)
            const localVarPath = `/staking/chains/{chainDescriptor}/merge`
                .replace(`{${"chainDescriptor"}}`, encodeURIComponent(String(chainDescriptor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mergeStakeAccountsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Splits a staking position by creating a new stake account with the requested amount, while keeping the original account with the remaining balance. Supported chains: Solana (SOL).
         * @summary Split a staking position
         * @param {SplitRequest} splitRequest 
         * @param {SplitChainDescriptorEnum} chainDescriptor Protocol identifier for the staking operation (e.g., SOL).
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        split: async (splitRequest: SplitRequest, chainDescriptor: SplitChainDescriptorEnum, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('split', 'splitRequest', splitRequest)
            assertParamExistsAndNotEmpty('split', 'chainDescriptor', chainDescriptor)
            const localVarPath = `/staking/chains/{chainDescriptor}/split`
                .replace(`{${"chainDescriptor"}}`, encodeURIComponent(String(chainDescriptor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(splitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new staking position and returns its unique ID. For Ethereum compounding validator (EIP-7251): when the \'id\' of an existing compounding validator position is provided, adds to that position; otherwise creates a new position. For Ethereum legacy validator: creates a new position regardless of existing delegations. For Cosmos chains and Ethereum liquid staking (Lido): automatically add to existing positions for the same validator provider and same vault account if one exists, otherwise create a new position. For Solana and Polygon: always create new positions regardless of existing delegations.
         * @summary Initiate or add to existing stake
         * @param {StakeRequest} stakeRequest 
         * @param {ChainDescriptor} chainDescriptor Protocol identifier for the stake staking operation (e.g., ATOM_COS/AXL/CELESTIA).
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stake: async (stakeRequest: StakeRequest, chainDescriptor: ChainDescriptor, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('stake', 'stakeRequest', stakeRequest)
            assertParamExists('stake', 'chainDescriptor', chainDescriptor)
            const localVarPath = `/staking/chains/{chainDescriptor}/stake`
                .replace(`{${"chainDescriptor"}}`, encodeURIComponent(String(chainDescriptor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stakeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a chain-specific unstake request.
         * @summary Initiate unstake
         * @param {UnstakeRequest} unstakeRequest 
         * @param {ChainDescriptor} chainDescriptor Protocol identifier for the unstake staking operation (e.g., SOL/SOL_TEST/MATIC).
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstake: async (unstakeRequest: UnstakeRequest, chainDescriptor: ChainDescriptor, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('unstake', 'unstakeRequest', unstakeRequest)
            assertParamExists('unstake', 'chainDescriptor', chainDescriptor)
            const localVarPath = `/staking/chains/{chainDescriptor}/unstake`
                .replace(`{${"chainDescriptor"}}`, encodeURIComponent(String(chainDescriptor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unstakeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Withdraws funds that have completed the unbonding period. Typically requires the position to be deactivated first (unstake → unbond → withdraw). Amount and timing vary by chain protocol.
         * @summary Withdraw staked funds
         * @param {WithdrawRequest} withdrawRequest 
         * @param {ChainDescriptor} chainDescriptor Protocol identifier for the withdraw staking operation (e.g., ATOM_COS/ETH/STETH_ETH).
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdraw: async (withdrawRequest: WithdrawRequest, chainDescriptor: ChainDescriptor, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('withdraw', 'withdrawRequest', withdrawRequest)
            assertParamExists('withdraw', 'chainDescriptor', chainDescriptor)
            const localVarPath = `/staking/chains/{chainDescriptor}/withdraw`
                .replace(`{${"chainDescriptor"}}`, encodeURIComponent(String(chainDescriptor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StakingApi - functional programming interface
 * @export
 */
export const StakingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StakingApiAxiosParamCreator(configuration)
    return {
        /**
         * Approves the provider\'s terms of service. Must be called once before performing any staking operation with this provider.
         * @summary Approve provider terms of service
         * @param {StakingProvider} providerId Unique identifier of the staking provider.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveTermsOfServiceByProviderId(providerId: StakingProvider, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveTermsOfServiceByProviderId(providerId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.approveTermsOfServiceByProviderId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Claims available staking rewards for the specified chain and vault. Supported chains: Solana and Polygon (Matic). Behavior depends on protocol reward distribution.
         * @summary Claim accrued rewards
         * @param {ClaimRewardsRequest} claimRewardsRequest 
         * @param {ClaimRewardsChainDescriptorEnum} chainDescriptor Protocol identifier for the claim rewards staking operation (e.g., MATIC/SOL).
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claimRewards(claimRewardsRequest: ClaimRewardsRequest, chainDescriptor: ClaimRewardsChainDescriptorEnum, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claimRewards(claimRewardsRequest, chainDescriptor, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.claimRewards']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns all staking positions with core details: amounts, rewards, status, chain, and vault. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
         * @summary List staking positions
         * @param {ChainDescriptor} [chainDescriptor] Protocol identifier to filter positions (e.g., ATOM_COS/AXL/CELESTIA}). If omitted, positions across all supported chains are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDelegations(chainDescriptor?: ChainDescriptor, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingGetAllDelegationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDelegations(chainDescriptor, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.getAllDelegations']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns chain-specific staking information such as epoch/slot cadence, lockup or unbonding periods, fee/reward mechanics, and other operational constraints.
         * @summary Get chain-level staking parameters
         * @param {ChainDescriptor} chainDescriptor Protocol identifier for the chain info staking operation (e.g., ETH/MATIC/SOL).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChainInfo(chainDescriptor: ChainDescriptor, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChainInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChainInfo(chainDescriptor, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.getChainInfo']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns an alphabetical list of blockchains supported for staking by the current workspace context. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
         * @summary List supported staking chains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChains(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingGetChainsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChains(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.getChains']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns full details for a single staking position: amounts, rewards, status, chain, and vault.
         * @summary Get position details
         * @param {string} id Unique identifier of the staking position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDelegationById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Delegation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDelegationById(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.getDelegationById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns all available staking providers with metadata such as name, ID, and supported chains. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
         * @summary List staking providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProviders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingGetProvidersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProviders(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.getProviders']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns an aggregated cross-vault summary: active/inactive counts, total staked, and total rewards per chain.
         * @summary Get positions summary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSummary(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelegationSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSummary(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.getSummary']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns per-vault aggregates: status breakdown, total staked, and total rewards per chain.
         * @summary Get positions summary by vault
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSummaryByVault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingGetSummaryByVaultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSummaryByVault(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.getSummaryByVault']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Merges the source stake account into the destination, consolidating the balance into the destination and closing the source account once complete. Both accounts must be from the same validator provider and of same vault account.. Supported chains: Solana (SOL). </br>Endpoint Permission: Owner, Admin, Non-Signing Admin, Signer, Approver, Editor.
         * @summary Merge staking positions
         * @param {MergeStakeAccountsRequest} mergeStakeAccountsRequest 
         * @param {MergeStakeAccountsChainDescriptorEnum} chainDescriptor Protocol identifier for the merge staking operation (e.g., SOL).
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeStakeAccounts(mergeStakeAccountsRequest: MergeStakeAccountsRequest, chainDescriptor: MergeStakeAccountsChainDescriptorEnum, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MergeStakeAccountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeStakeAccounts(mergeStakeAccountsRequest, chainDescriptor, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.mergeStakeAccounts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Splits a staking position by creating a new stake account with the requested amount, while keeping the original account with the remaining balance. Supported chains: Solana (SOL).
         * @summary Split a staking position
         * @param {SplitRequest} splitRequest 
         * @param {SplitChainDescriptorEnum} chainDescriptor Protocol identifier for the staking operation (e.g., SOL).
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async split(splitRequest: SplitRequest, chainDescriptor: SplitChainDescriptorEnum, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SplitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.split(splitRequest, chainDescriptor, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.split']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a new staking position and returns its unique ID. For Ethereum compounding validator (EIP-7251): when the \'id\' of an existing compounding validator position is provided, adds to that position; otherwise creates a new position. For Ethereum legacy validator: creates a new position regardless of existing delegations. For Cosmos chains and Ethereum liquid staking (Lido): automatically add to existing positions for the same validator provider and same vault account if one exists, otherwise create a new position. For Solana and Polygon: always create new positions regardless of existing delegations.
         * @summary Initiate or add to existing stake
         * @param {StakeRequest} stakeRequest 
         * @param {ChainDescriptor} chainDescriptor Protocol identifier for the stake staking operation (e.g., ATOM_COS/AXL/CELESTIA).
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stake(stakeRequest: StakeRequest, chainDescriptor: ChainDescriptor, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stake(stakeRequest, chainDescriptor, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.stake']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Submits a chain-specific unstake request.
         * @summary Initiate unstake
         * @param {UnstakeRequest} unstakeRequest 
         * @param {ChainDescriptor} chainDescriptor Protocol identifier for the unstake staking operation (e.g., SOL/SOL_TEST/MATIC).
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unstake(unstakeRequest: UnstakeRequest, chainDescriptor: ChainDescriptor, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unstake(unstakeRequest, chainDescriptor, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.unstake']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Withdraws funds that have completed the unbonding period. Typically requires the position to be deactivated first (unstake → unbond → withdraw). Amount and timing vary by chain protocol.
         * @summary Withdraw staked funds
         * @param {WithdrawRequest} withdrawRequest 
         * @param {ChainDescriptor} chainDescriptor Protocol identifier for the withdraw staking operation (e.g., ATOM_COS/ETH/STETH_ETH).
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdraw(withdrawRequest: WithdrawRequest, chainDescriptor: ChainDescriptor, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdraw(withdrawRequest, chainDescriptor, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.withdraw']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * StakingApi - factory interface
 * @export
 */
export const StakingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StakingApiFp(configuration)
    return {
        /**
         * Approves the provider\'s terms of service. Must be called once before performing any staking operation with this provider.
         * @summary Approve provider terms of service
         * @param {StakingApiApproveTermsOfServiceByProviderIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveTermsOfServiceByProviderId(requestParameters: StakingApiApproveTermsOfServiceByProviderIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.approveTermsOfServiceByProviderId(requestParameters.providerId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Claims available staking rewards for the specified chain and vault. Supported chains: Solana and Polygon (Matic). Behavior depends on protocol reward distribution.
         * @summary Claim accrued rewards
         * @param {StakingApiClaimRewardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimRewards(requestParameters: StakingApiClaimRewardsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.claimRewards(requestParameters.claimRewardsRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all staking positions with core details: amounts, rewards, status, chain, and vault. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
         * @summary List staking positions
         * @param {StakingApiGetAllDelegationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDelegations(requestParameters: StakingApiGetAllDelegationsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<StakingGetAllDelegationsResponse> {
            return localVarFp.getAllDelegations(requestParameters.chainDescriptor, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns chain-specific staking information such as epoch/slot cadence, lockup or unbonding periods, fee/reward mechanics, and other operational constraints.
         * @summary Get chain-level staking parameters
         * @param {StakingApiGetChainInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChainInfo(requestParameters: StakingApiGetChainInfoRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChainInfoResponse> {
            return localVarFp.getChainInfo(requestParameters.chainDescriptor, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an alphabetical list of blockchains supported for staking by the current workspace context. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
         * @summary List supported staking chains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChains(options?: RawAxiosRequestConfig): AxiosPromise<StakingGetChainsResponse> {
            return localVarFp.getChains(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns full details for a single staking position: amounts, rewards, status, chain, and vault.
         * @summary Get position details
         * @param {StakingApiGetDelegationByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegationById(requestParameters: StakingApiGetDelegationByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<Delegation> {
            return localVarFp.getDelegationById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all available staking providers with metadata such as name, ID, and supported chains. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
         * @summary List staking providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders(options?: RawAxiosRequestConfig): AxiosPromise<StakingGetProvidersResponse> {
            return localVarFp.getProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an aggregated cross-vault summary: active/inactive counts, total staked, and total rewards per chain.
         * @summary Get positions summary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummary(options?: RawAxiosRequestConfig): AxiosPromise<DelegationSummary> {
            return localVarFp.getSummary(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns per-vault aggregates: status breakdown, total staked, and total rewards per chain.
         * @summary Get positions summary by vault
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummaryByVault(options?: RawAxiosRequestConfig): AxiosPromise<StakingGetSummaryByVaultResponse> {
            return localVarFp.getSummaryByVault(options).then((request) => request(axios, basePath));
        },
        /**
         * Merges the source stake account into the destination, consolidating the balance into the destination and closing the source account once complete. Both accounts must be from the same validator provider and of same vault account.. Supported chains: Solana (SOL). </br>Endpoint Permission: Owner, Admin, Non-Signing Admin, Signer, Approver, Editor.
         * @summary Merge staking positions
         * @param {StakingApiMergeStakeAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeStakeAccounts(requestParameters: StakingApiMergeStakeAccountsRequest, options?: RawAxiosRequestConfig): AxiosPromise<MergeStakeAccountsResponse> {
            return localVarFp.mergeStakeAccounts(requestParameters.mergeStakeAccountsRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Splits a staking position by creating a new stake account with the requested amount, while keeping the original account with the remaining balance. Supported chains: Solana (SOL).
         * @summary Split a staking position
         * @param {StakingApiSplitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        split(requestParameters: StakingApiSplitRequest, options?: RawAxiosRequestConfig): AxiosPromise<SplitResponse> {
            return localVarFp.split(requestParameters.splitRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new staking position and returns its unique ID. For Ethereum compounding validator (EIP-7251): when the \'id\' of an existing compounding validator position is provided, adds to that position; otherwise creates a new position. For Ethereum legacy validator: creates a new position regardless of existing delegations. For Cosmos chains and Ethereum liquid staking (Lido): automatically add to existing positions for the same validator provider and same vault account if one exists, otherwise create a new position. For Solana and Polygon: always create new positions regardless of existing delegations.
         * @summary Initiate or add to existing stake
         * @param {StakingApiStakeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stake(requestParameters: StakingApiStakeRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakeResponse> {
            return localVarFp.stake(requestParameters.stakeRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a chain-specific unstake request.
         * @summary Initiate unstake
         * @param {StakingApiUnstakeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstake(requestParameters: StakingApiUnstakeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unstake(requestParameters.unstakeRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Withdraws funds that have completed the unbonding period. Typically requires the position to be deactivated first (unstake → unbond → withdraw). Amount and timing vary by chain protocol.
         * @summary Withdraw staked funds
         * @param {StakingApiWithdrawRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdraw(requestParameters: StakingApiWithdrawRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.withdraw(requestParameters.withdrawRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveTermsOfServiceByProviderId operation in StakingApi.
 * @export
 * @interface StakingApiApproveTermsOfServiceByProviderIdRequest
 */
export interface StakingApiApproveTermsOfServiceByProviderIdRequest {
    /**
     * Unique identifier of the staking provider.
     * @type {StakingProvider}
     * @memberof StakingApiApproveTermsOfServiceByProviderId
     */
    readonly providerId: StakingProvider

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof StakingApiApproveTermsOfServiceByProviderId
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for claimRewards operation in StakingApi.
 * @export
 * @interface StakingApiClaimRewardsRequest
 */
export interface StakingApiClaimRewardsRequest {
    /**
     * 
     * @type {ClaimRewardsRequest}
     * @memberof StakingApiClaimRewards
     */
    readonly claimRewardsRequest: ClaimRewardsRequest

    /**
     * Protocol identifier for the claim rewards staking operation (e.g., MATIC/SOL).
     * @type {'SOL' | 'SOL_TEST' | 'MATIC'}
     * @memberof StakingApiClaimRewards
     */
    readonly chainDescriptor: ClaimRewardsChainDescriptorEnum

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof StakingApiClaimRewards
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for getAllDelegations operation in StakingApi.
 * @export
 * @interface StakingApiGetAllDelegationsRequest
 */
export interface StakingApiGetAllDelegationsRequest {
    /**
     * Protocol identifier to filter positions (e.g., ATOM_COS/AXL/CELESTIA}). If omitted, positions across all supported chains are returned.
     * @type {ChainDescriptor}
     * @memberof StakingApiGetAllDelegations
     */
    readonly chainDescriptor?: ChainDescriptor
}

/**
 * Request parameters for getChainInfo operation in StakingApi.
 * @export
 * @interface StakingApiGetChainInfoRequest
 */
export interface StakingApiGetChainInfoRequest {
    /**
     * Protocol identifier for the chain info staking operation (e.g., ETH/MATIC/SOL).
     * @type {ChainDescriptor}
     * @memberof StakingApiGetChainInfo
     */
    readonly chainDescriptor: ChainDescriptor
}

/**
 * Request parameters for getDelegationById operation in StakingApi.
 * @export
 * @interface StakingApiGetDelegationByIdRequest
 */
export interface StakingApiGetDelegationByIdRequest {
    /**
     * Unique identifier of the staking position.
     * @type {string}
     * @memberof StakingApiGetDelegationById
     */
    readonly id: string
}

/**
 * Request parameters for mergeStakeAccounts operation in StakingApi.
 * @export
 * @interface StakingApiMergeStakeAccountsRequest
 */
export interface StakingApiMergeStakeAccountsRequest {
    /**
     * 
     * @type {MergeStakeAccountsRequest}
     * @memberof StakingApiMergeStakeAccounts
     */
    readonly mergeStakeAccountsRequest: MergeStakeAccountsRequest

    /**
     * Protocol identifier for the merge staking operation (e.g., SOL).
     * @type {'SOL' | 'SOL_TEST'}
     * @memberof StakingApiMergeStakeAccounts
     */
    readonly chainDescriptor: MergeStakeAccountsChainDescriptorEnum

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof StakingApiMergeStakeAccounts
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for split operation in StakingApi.
 * @export
 * @interface StakingApiSplitRequest
 */
export interface StakingApiSplitRequest {
    /**
     * 
     * @type {SplitRequest}
     * @memberof StakingApiSplit
     */
    readonly splitRequest: SplitRequest

    /**
     * Protocol identifier for the staking operation (e.g., SOL).
     * @type {'SOL' | 'SOL_TEST'}
     * @memberof StakingApiSplit
     */
    readonly chainDescriptor: SplitChainDescriptorEnum

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof StakingApiSplit
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for stake operation in StakingApi.
 * @export
 * @interface StakingApiStakeRequest
 */
export interface StakingApiStakeRequest {
    /**
     * 
     * @type {StakeRequest}
     * @memberof StakingApiStake
     */
    readonly stakeRequest: StakeRequest

    /**
     * Protocol identifier for the stake staking operation (e.g., ATOM_COS/AXL/CELESTIA).
     * @type {ChainDescriptor}
     * @memberof StakingApiStake
     */
    readonly chainDescriptor: ChainDescriptor

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof StakingApiStake
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for unstake operation in StakingApi.
 * @export
 * @interface StakingApiUnstakeRequest
 */
export interface StakingApiUnstakeRequest {
    /**
     * 
     * @type {UnstakeRequest}
     * @memberof StakingApiUnstake
     */
    readonly unstakeRequest: UnstakeRequest

    /**
     * Protocol identifier for the unstake staking operation (e.g., SOL/SOL_TEST/MATIC).
     * @type {ChainDescriptor}
     * @memberof StakingApiUnstake
     */
    readonly chainDescriptor: ChainDescriptor

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof StakingApiUnstake
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for withdraw operation in StakingApi.
 * @export
 * @interface StakingApiWithdrawRequest
 */
export interface StakingApiWithdrawRequest {
    /**
     * 
     * @type {WithdrawRequest}
     * @memberof StakingApiWithdraw
     */
    readonly withdrawRequest: WithdrawRequest

    /**
     * Protocol identifier for the withdraw staking operation (e.g., ATOM_COS/ETH/STETH_ETH).
     * @type {ChainDescriptor}
     * @memberof StakingApiWithdraw
     */
    readonly chainDescriptor: ChainDescriptor

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof StakingApiWithdraw
     */
    readonly idempotencyKey?: string
}

/**
 * StakingApi - object-oriented interface
 * @export
 * @class StakingApi
 * @extends {BaseAPI}
 */
export class StakingApi extends BaseAPI {
    /**
     * Approves the provider\'s terms of service. Must be called once before performing any staking operation with this provider.
     * @summary Approve provider terms of service
     * @param {StakingApiApproveTermsOfServiceByProviderIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public approveTermsOfServiceByProviderId(requestParameters: StakingApiApproveTermsOfServiceByProviderIdRequest) {
        return StakingApiFp(this.configuration).approveTermsOfServiceByProviderId(requestParameters.providerId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Claims available staking rewards for the specified chain and vault. Supported chains: Solana and Polygon (Matic). Behavior depends on protocol reward distribution.
     * @summary Claim accrued rewards
     * @param {StakingApiClaimRewardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public claimRewards(requestParameters: StakingApiClaimRewardsRequest) {
        return StakingApiFp(this.configuration).claimRewards(requestParameters.claimRewardsRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns all staking positions with core details: amounts, rewards, status, chain, and vault. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
     * @summary List staking positions
     * @param {StakingApiGetAllDelegationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getAllDelegations(requestParameters: StakingApiGetAllDelegationsRequest = {}) {
        return StakingApiFp(this.configuration).getAllDelegations(requestParameters.chainDescriptor).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns chain-specific staking information such as epoch/slot cadence, lockup or unbonding periods, fee/reward mechanics, and other operational constraints.
     * @summary Get chain-level staking parameters
     * @param {StakingApiGetChainInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getChainInfo(requestParameters: StakingApiGetChainInfoRequest) {
        return StakingApiFp(this.configuration).getChainInfo(requestParameters.chainDescriptor).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns an alphabetical list of blockchains supported for staking by the current workspace context. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
     * @summary List supported staking chains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getChains() {
        return StakingApiFp(this.configuration).getChains().then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns full details for a single staking position: amounts, rewards, status, chain, and vault.
     * @summary Get position details
     * @param {StakingApiGetDelegationByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getDelegationById(requestParameters: StakingApiGetDelegationByIdRequest) {
        return StakingApiFp(this.configuration).getDelegationById(requestParameters.id).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns all available staking providers with metadata such as name, ID, and supported chains. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
     * @summary List staking providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getProviders() {
        return StakingApiFp(this.configuration).getProviders().then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns an aggregated cross-vault summary: active/inactive counts, total staked, and total rewards per chain.
     * @summary Get positions summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getSummary() {
        return StakingApiFp(this.configuration).getSummary().then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns per-vault aggregates: status breakdown, total staked, and total rewards per chain.
     * @summary Get positions summary by vault
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getSummaryByVault() {
        return StakingApiFp(this.configuration).getSummaryByVault().then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Merges the source stake account into the destination, consolidating the balance into the destination and closing the source account once complete. Both accounts must be from the same validator provider and of same vault account.. Supported chains: Solana (SOL). </br>Endpoint Permission: Owner, Admin, Non-Signing Admin, Signer, Approver, Editor.
     * @summary Merge staking positions
     * @param {StakingApiMergeStakeAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public mergeStakeAccounts(requestParameters: StakingApiMergeStakeAccountsRequest) {
        return StakingApiFp(this.configuration).mergeStakeAccounts(requestParameters.mergeStakeAccountsRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Splits a staking position by creating a new stake account with the requested amount, while keeping the original account with the remaining balance. Supported chains: Solana (SOL).
     * @summary Split a staking position
     * @param {StakingApiSplitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public split(requestParameters: StakingApiSplitRequest) {
        return StakingApiFp(this.configuration).split(requestParameters.splitRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Creates a new staking position and returns its unique ID. For Ethereum compounding validator (EIP-7251): when the \'id\' of an existing compounding validator position is provided, adds to that position; otherwise creates a new position. For Ethereum legacy validator: creates a new position regardless of existing delegations. For Cosmos chains and Ethereum liquid staking (Lido): automatically add to existing positions for the same validator provider and same vault account if one exists, otherwise create a new position. For Solana and Polygon: always create new positions regardless of existing delegations.
     * @summary Initiate or add to existing stake
     * @param {StakingApiStakeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stake(requestParameters: StakingApiStakeRequest) {
        return StakingApiFp(this.configuration).stake(requestParameters.stakeRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Submits a chain-specific unstake request.
     * @summary Initiate unstake
     * @param {StakingApiUnstakeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public unstake(requestParameters: StakingApiUnstakeRequest) {
        return StakingApiFp(this.configuration).unstake(requestParameters.unstakeRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Withdraws funds that have completed the unbonding period. Typically requires the position to be deactivated first (unstake → unbond → withdraw). Amount and timing vary by chain protocol.
     * @summary Withdraw staked funds
     * @param {StakingApiWithdrawRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public withdraw(requestParameters: StakingApiWithdrawRequest) {
        return StakingApiFp(this.configuration).withdraw(requestParameters.withdrawRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }
}

/**
 * @export
 */
export const ClaimRewardsChainDescriptorEnum = {
    Sol: 'SOL',
    SolTest: 'SOL_TEST',
    Matic: 'MATIC'
} as const;
export type ClaimRewardsChainDescriptorEnum = typeof ClaimRewardsChainDescriptorEnum[keyof typeof ClaimRewardsChainDescriptorEnum];
/**
 * @export
 */
export const MergeStakeAccountsChainDescriptorEnum = {
    Sol: 'SOL',
    SolTest: 'SOL_TEST'
} as const;
export type MergeStakeAccountsChainDescriptorEnum = typeof MergeStakeAccountsChainDescriptorEnum[keyof typeof MergeStakeAccountsChainDescriptorEnum];
/**
 * @export
 */
export const SplitChainDescriptorEnum = {
    Sol: 'SOL',
    SolTest: 'SOL_TEST'
} as const;
export type SplitChainDescriptorEnum = typeof SplitChainDescriptorEnum[keyof typeof SplitChainDescriptorEnum];
