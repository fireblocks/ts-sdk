/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import { convertToFireblocksResponse } from "../response/fireblocksResponse";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import { assertParamExistsAndNotEmpty } from '../utils/validation_utils';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { ChainDescriptor } from '../models';
// @ts-ignore
import { ChainInfoResponse } from '../models';
// @ts-ignore
import { ClaimRewardsRequest } from '../models';
// @ts-ignore
import { Delegation } from '../models';
// @ts-ignore
import { DelegationSummary } from '../models';
// @ts-ignore
import { ErrorSchema } from '../models';
// @ts-ignore
import { MergeStakeAccountsRequest } from '../models';
// @ts-ignore
import { MergeStakeAccountsResponse } from '../models';
// @ts-ignore
import { SplitRequest } from '../models';
// @ts-ignore
import { SplitResponse } from '../models';
// @ts-ignore
import { StakeRequest } from '../models';
// @ts-ignore
import { StakeResponse } from '../models';
// @ts-ignore
import { StakingGetAllDelegationsResponse } from '../models';
// @ts-ignore
import { StakingGetChainsResponse } from '../models';
// @ts-ignore
import { StakingGetProvidersResponse } from '../models';
// @ts-ignore
import { StakingGetSummaryByVaultResponse } from '../models';
// @ts-ignore
import { StakingProvider } from '../models';
// @ts-ignore
import { UnstakeRequest } from '../models';
// @ts-ignore
import { WithdrawRequest } from '../models';
/**
 * StakingApi - axios parameter creator
 * @export
 */
export const StakingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approve the terms of service of the staking provider. This must be called before performing a staking action for the first time with this provider.
         * @summary Approve staking terms of service
         * @param {StakingProvider} providerId The unique identifier of the staking provider
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveTermsOfServiceByProviderId: async (providerId: StakingProvider, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('approveTermsOfServiceByProviderId', 'providerId', providerId)
            const localVarPath = `/staking/providers/{providerId}/approveTermsOfService`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a chain-specific Claim Rewards.
         * @summary Execute a Claim Rewards operation
         * @param {ClaimRewardsRequest} claimRewardsRequest 
         * @param {ClaimRewardsChainDescriptorEnum} chainDescriptor The protocol identifier (e.g. \&quot;MATIC\&quot;/\&quot;SOL\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimRewards: async (claimRewardsRequest: ClaimRewardsRequest, chainDescriptor: ClaimRewardsChainDescriptorEnum, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('claimRewards', 'claimRewardsRequest', claimRewardsRequest)
            assertParamExistsAndNotEmpty('claimRewards', 'chainDescriptor', chainDescriptor)
            const localVarPath = `/staking/chains/{chainDescriptor}/claim_rewards`
                .replace(`{${"chainDescriptor"}}`, encodeURIComponent(String(chainDescriptor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(claimRewardsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return detailed information on all staking positions, including the staked amount, rewards, status and more.
         * @summary List staking positions details
         * @param {ChainDescriptor} [chainDescriptor] Use \&quot;ETH\&quot; / \&quot;SOL\&quot; / \&quot;MATIC\&quot; / \&quot;STETH_ETH\&quot; in order to obtain information related to the specific blockchain network or retrieve information about all chains that have data available by providing no argument.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDelegations: async (chainDescriptor?: ChainDescriptor, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (chainDescriptor !== undefined) {
                localVarQueryParameter['chainDescriptor'] = chainDescriptor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return chain-specific, staking-related information summary (e.g. epoch details, lockup durations, estimated rewards, etc.)
         * @summary Get chain-specific staking summary
         * @param {ChainDescriptor} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;/\&quot;STETH_ETH\&quot;) to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChainInfo: async (chainDescriptor: ChainDescriptor, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('getChainInfo', 'chainDescriptor', chainDescriptor)
            const localVarPath = `/staking/chains/{chainDescriptor}/chainInfo`
                .replace(`{${"chainDescriptor"}}`, encodeURIComponent(String(chainDescriptor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return an alphabetical list of supported chains.
         * @summary List staking supported chains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChains: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/chains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return detailed information on a staking position, including the staked amount, rewards, status and more.
         * @summary Get staking position details
         * @param {string} id The unique identifier of the staking position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegationById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getDelegationById', 'id', id)
            const localVarPath = `/staking/positions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return information on all the available staking providers.
         * @summary List staking providers details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a summary of all vaults, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary Get staking summary details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummary: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/positions/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a summary for each vault, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary Get staking summary details by vault
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummaryByVault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/positions/summary/vaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a Solana Merge of two active stake accounts into one.  Endpoint Permission: Owner, Admin, Non-Signing Admin, Signer, Approver, Editor, Viewer.
         * @summary Merge Solana on stake accounts
         * @param {MergeStakeAccountsRequest} mergeStakeAccountsRequest 
         * @param {MergeStakeAccountsChainDescriptorEnum} chainDescriptor The protocol identifier (e.g. \&quot;SOL\&quot;/\&quot;SOL_TEST\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeStakeAccounts: async (mergeStakeAccountsRequest: MergeStakeAccountsRequest, chainDescriptor: MergeStakeAccountsChainDescriptorEnum, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('mergeStakeAccounts', 'mergeStakeAccountsRequest', mergeStakeAccountsRequest)
            assertParamExistsAndNotEmpty('mergeStakeAccounts', 'chainDescriptor', chainDescriptor)
            const localVarPath = `/staking/chains/{chainDescriptor}/merge`
                .replace(`{${"chainDescriptor"}}`, encodeURIComponent(String(chainDescriptor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mergeStakeAccountsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a Solana Split stake account.
         * @summary Execute a Split operation on SOL/SOL_TEST stake account
         * @param {SplitRequest} splitRequest 
         * @param {SplitChainDescriptorEnum} chainDescriptor The protocol identifier (e.g. \&quot;SOL\&quot;/\&quot;SOL_TEST\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        split: async (splitRequest: SplitRequest, chainDescriptor: SplitChainDescriptorEnum, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('split', 'splitRequest', splitRequest)
            assertParamExistsAndNotEmpty('split', 'chainDescriptor', chainDescriptor)
            const localVarPath = `/staking/chains/{chainDescriptor}/split`
                .replace(`{${"chainDescriptor"}}`, encodeURIComponent(String(chainDescriptor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(splitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a chain-specific Stake.
         * @summary Initiate Stake Operation
         * @param {StakeRequest} stakeRequest 
         * @param {ChainDescriptor} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stake: async (stakeRequest: StakeRequest, chainDescriptor: ChainDescriptor, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('stake', 'stakeRequest', stakeRequest)
            assertParamExists('stake', 'chainDescriptor', chainDescriptor)
            const localVarPath = `/staking/chains/{chainDescriptor}/stake`
                .replace(`{${"chainDescriptor"}}`, encodeURIComponent(String(chainDescriptor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stakeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute an Unstake operation
         * @summary Execute an Unstake operation
         * @param {UnstakeRequest} unstakeRequest 
         * @param {ChainDescriptor} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstake: async (unstakeRequest: UnstakeRequest, chainDescriptor: ChainDescriptor, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('unstake', 'unstakeRequest', unstakeRequest)
            assertParamExists('unstake', 'chainDescriptor', chainDescriptor)
            const localVarPath = `/staking/chains/{chainDescriptor}/unstake`
                .replace(`{${"chainDescriptor"}}`, encodeURIComponent(String(chainDescriptor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unstakeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a chain-specific Withdraw.
         * @summary Execute a Withdraw operation
         * @param {WithdrawRequest} withdrawRequest 
         * @param {ChainDescriptor} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdraw: async (withdrawRequest: WithdrawRequest, chainDescriptor: ChainDescriptor, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('withdraw', 'withdrawRequest', withdrawRequest)
            assertParamExists('withdraw', 'chainDescriptor', chainDescriptor)
            const localVarPath = `/staking/chains/{chainDescriptor}/withdraw`
                .replace(`{${"chainDescriptor"}}`, encodeURIComponent(String(chainDescriptor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StakingApi - functional programming interface
 * @export
 */
export const StakingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StakingApiAxiosParamCreator(configuration)
    return {
        /**
         * Approve the terms of service of the staking provider. This must be called before performing a staking action for the first time with this provider.
         * @summary Approve staking terms of service
         * @param {StakingProvider} providerId The unique identifier of the staking provider
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveTermsOfServiceByProviderId(providerId: StakingProvider, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveTermsOfServiceByProviderId(providerId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.approveTermsOfServiceByProviderId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Perform a chain-specific Claim Rewards.
         * @summary Execute a Claim Rewards operation
         * @param {ClaimRewardsRequest} claimRewardsRequest 
         * @param {ClaimRewardsChainDescriptorEnum} chainDescriptor The protocol identifier (e.g. \&quot;MATIC\&quot;/\&quot;SOL\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claimRewards(claimRewardsRequest: ClaimRewardsRequest, chainDescriptor: ClaimRewardsChainDescriptorEnum, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claimRewards(claimRewardsRequest, chainDescriptor, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.claimRewards']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return detailed information on all staking positions, including the staked amount, rewards, status and more.
         * @summary List staking positions details
         * @param {ChainDescriptor} [chainDescriptor] Use \&quot;ETH\&quot; / \&quot;SOL\&quot; / \&quot;MATIC\&quot; / \&quot;STETH_ETH\&quot; in order to obtain information related to the specific blockchain network or retrieve information about all chains that have data available by providing no argument.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDelegations(chainDescriptor?: ChainDescriptor, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingGetAllDelegationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDelegations(chainDescriptor, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.getAllDelegations']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return chain-specific, staking-related information summary (e.g. epoch details, lockup durations, estimated rewards, etc.)
         * @summary Get chain-specific staking summary
         * @param {ChainDescriptor} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;/\&quot;STETH_ETH\&quot;) to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChainInfo(chainDescriptor: ChainDescriptor, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChainInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChainInfo(chainDescriptor, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.getChainInfo']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return an alphabetical list of supported chains.
         * @summary List staking supported chains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChains(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingGetChainsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChains(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.getChains']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return detailed information on a staking position, including the staked amount, rewards, status and more.
         * @summary Get staking position details
         * @param {string} id The unique identifier of the staking position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDelegationById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Delegation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDelegationById(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.getDelegationById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return information on all the available staking providers.
         * @summary List staking providers details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProviders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingGetProvidersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProviders(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.getProviders']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return a summary of all vaults, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary Get staking summary details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSummary(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelegationSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSummary(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.getSummary']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return a summary for each vault, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary Get staking summary details by vault
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSummaryByVault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingGetSummaryByVaultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSummaryByVault(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.getSummaryByVault']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Perform a Solana Merge of two active stake accounts into one.  Endpoint Permission: Owner, Admin, Non-Signing Admin, Signer, Approver, Editor, Viewer.
         * @summary Merge Solana on stake accounts
         * @param {MergeStakeAccountsRequest} mergeStakeAccountsRequest 
         * @param {MergeStakeAccountsChainDescriptorEnum} chainDescriptor The protocol identifier (e.g. \&quot;SOL\&quot;/\&quot;SOL_TEST\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeStakeAccounts(mergeStakeAccountsRequest: MergeStakeAccountsRequest, chainDescriptor: MergeStakeAccountsChainDescriptorEnum, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MergeStakeAccountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeStakeAccounts(mergeStakeAccountsRequest, chainDescriptor, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.mergeStakeAccounts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Perform a Solana Split stake account.
         * @summary Execute a Split operation on SOL/SOL_TEST stake account
         * @param {SplitRequest} splitRequest 
         * @param {SplitChainDescriptorEnum} chainDescriptor The protocol identifier (e.g. \&quot;SOL\&quot;/\&quot;SOL_TEST\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async split(splitRequest: SplitRequest, chainDescriptor: SplitChainDescriptorEnum, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SplitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.split(splitRequest, chainDescriptor, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.split']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Perform a chain-specific Stake.
         * @summary Initiate Stake Operation
         * @param {StakeRequest} stakeRequest 
         * @param {ChainDescriptor} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stake(stakeRequest: StakeRequest, chainDescriptor: ChainDescriptor, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stake(stakeRequest, chainDescriptor, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.stake']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Execute an Unstake operation
         * @summary Execute an Unstake operation
         * @param {UnstakeRequest} unstakeRequest 
         * @param {ChainDescriptor} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unstake(unstakeRequest: UnstakeRequest, chainDescriptor: ChainDescriptor, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unstake(unstakeRequest, chainDescriptor, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.unstake']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Perform a chain-specific Withdraw.
         * @summary Execute a Withdraw operation
         * @param {WithdrawRequest} withdrawRequest 
         * @param {ChainDescriptor} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdraw(withdrawRequest: WithdrawRequest, chainDescriptor: ChainDescriptor, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdraw(withdrawRequest, chainDescriptor, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingApi.withdraw']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * StakingApi - factory interface
 * @export
 */
export const StakingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StakingApiFp(configuration)
    return {
        /**
         * Approve the terms of service of the staking provider. This must be called before performing a staking action for the first time with this provider.
         * @summary Approve staking terms of service
         * @param {StakingApiApproveTermsOfServiceByProviderIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveTermsOfServiceByProviderId(requestParameters: StakingApiApproveTermsOfServiceByProviderIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.approveTermsOfServiceByProviderId(requestParameters.providerId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a chain-specific Claim Rewards.
         * @summary Execute a Claim Rewards operation
         * @param {StakingApiClaimRewardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimRewards(requestParameters: StakingApiClaimRewardsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.claimRewards(requestParameters.claimRewardsRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Return detailed information on all staking positions, including the staked amount, rewards, status and more.
         * @summary List staking positions details
         * @param {StakingApiGetAllDelegationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDelegations(requestParameters: StakingApiGetAllDelegationsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<StakingGetAllDelegationsResponse> {
            return localVarFp.getAllDelegations(requestParameters.chainDescriptor, options).then((request) => request(axios, basePath));
        },
        /**
         * Return chain-specific, staking-related information summary (e.g. epoch details, lockup durations, estimated rewards, etc.)
         * @summary Get chain-specific staking summary
         * @param {StakingApiGetChainInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChainInfo(requestParameters: StakingApiGetChainInfoRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChainInfoResponse> {
            return localVarFp.getChainInfo(requestParameters.chainDescriptor, options).then((request) => request(axios, basePath));
        },
        /**
         * Return an alphabetical list of supported chains.
         * @summary List staking supported chains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChains(options?: RawAxiosRequestConfig): AxiosPromise<StakingGetChainsResponse> {
            return localVarFp.getChains(options).then((request) => request(axios, basePath));
        },
        /**
         * Return detailed information on a staking position, including the staked amount, rewards, status and more.
         * @summary Get staking position details
         * @param {StakingApiGetDelegationByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegationById(requestParameters: StakingApiGetDelegationByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<Delegation> {
            return localVarFp.getDelegationById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return information on all the available staking providers.
         * @summary List staking providers details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders(options?: RawAxiosRequestConfig): AxiosPromise<StakingGetProvidersResponse> {
            return localVarFp.getProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * Return a summary of all vaults, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary Get staking summary details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummary(options?: RawAxiosRequestConfig): AxiosPromise<DelegationSummary> {
            return localVarFp.getSummary(options).then((request) => request(axios, basePath));
        },
        /**
         * Return a summary for each vault, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary Get staking summary details by vault
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummaryByVault(options?: RawAxiosRequestConfig): AxiosPromise<StakingGetSummaryByVaultResponse> {
            return localVarFp.getSummaryByVault(options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a Solana Merge of two active stake accounts into one.  Endpoint Permission: Owner, Admin, Non-Signing Admin, Signer, Approver, Editor, Viewer.
         * @summary Merge Solana on stake accounts
         * @param {StakingApiMergeStakeAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeStakeAccounts(requestParameters: StakingApiMergeStakeAccountsRequest, options?: RawAxiosRequestConfig): AxiosPromise<MergeStakeAccountsResponse> {
            return localVarFp.mergeStakeAccounts(requestParameters.mergeStakeAccountsRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a Solana Split stake account.
         * @summary Execute a Split operation on SOL/SOL_TEST stake account
         * @param {StakingApiSplitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        split(requestParameters: StakingApiSplitRequest, options?: RawAxiosRequestConfig): AxiosPromise<SplitResponse> {
            return localVarFp.split(requestParameters.splitRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a chain-specific Stake.
         * @summary Initiate Stake Operation
         * @param {StakingApiStakeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stake(requestParameters: StakingApiStakeRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakeResponse> {
            return localVarFp.stake(requestParameters.stakeRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute an Unstake operation
         * @summary Execute an Unstake operation
         * @param {StakingApiUnstakeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstake(requestParameters: StakingApiUnstakeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unstake(requestParameters.unstakeRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a chain-specific Withdraw.
         * @summary Execute a Withdraw operation
         * @param {StakingApiWithdrawRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdraw(requestParameters: StakingApiWithdrawRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.withdraw(requestParameters.withdrawRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveTermsOfServiceByProviderId operation in StakingApi.
 * @export
 * @interface StakingApiApproveTermsOfServiceByProviderIdRequest
 */
export interface StakingApiApproveTermsOfServiceByProviderIdRequest {
    /**
     * The unique identifier of the staking provider
     * @type {StakingProvider}
     * @memberof StakingApiApproveTermsOfServiceByProviderId
     */
    readonly providerId: StakingProvider

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof StakingApiApproveTermsOfServiceByProviderId
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for claimRewards operation in StakingApi.
 * @export
 * @interface StakingApiClaimRewardsRequest
 */
export interface StakingApiClaimRewardsRequest {
    /**
     * 
     * @type {ClaimRewardsRequest}
     * @memberof StakingApiClaimRewards
     */
    readonly claimRewardsRequest: ClaimRewardsRequest

    /**
     * The protocol identifier (e.g. \&quot;MATIC\&quot;/\&quot;SOL\&quot;) to use
     * @type {'MATIC' | 'SOL' | 'SOL_TEST'}
     * @memberof StakingApiClaimRewards
     */
    readonly chainDescriptor: ClaimRewardsChainDescriptorEnum

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof StakingApiClaimRewards
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for getAllDelegations operation in StakingApi.
 * @export
 * @interface StakingApiGetAllDelegationsRequest
 */
export interface StakingApiGetAllDelegationsRequest {
    /**
     * Use \&quot;ETH\&quot; / \&quot;SOL\&quot; / \&quot;MATIC\&quot; / \&quot;STETH_ETH\&quot; in order to obtain information related to the specific blockchain network or retrieve information about all chains that have data available by providing no argument.
     * @type {ChainDescriptor}
     * @memberof StakingApiGetAllDelegations
     */
    readonly chainDescriptor?: ChainDescriptor
}

/**
 * Request parameters for getChainInfo operation in StakingApi.
 * @export
 * @interface StakingApiGetChainInfoRequest
 */
export interface StakingApiGetChainInfoRequest {
    /**
     * The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;/\&quot;STETH_ETH\&quot;) to use
     * @type {ChainDescriptor}
     * @memberof StakingApiGetChainInfo
     */
    readonly chainDescriptor: ChainDescriptor
}

/**
 * Request parameters for getDelegationById operation in StakingApi.
 * @export
 * @interface StakingApiGetDelegationByIdRequest
 */
export interface StakingApiGetDelegationByIdRequest {
    /**
     * The unique identifier of the staking position
     * @type {string}
     * @memberof StakingApiGetDelegationById
     */
    readonly id: string
}

/**
 * Request parameters for mergeStakeAccounts operation in StakingApi.
 * @export
 * @interface StakingApiMergeStakeAccountsRequest
 */
export interface StakingApiMergeStakeAccountsRequest {
    /**
     * 
     * @type {MergeStakeAccountsRequest}
     * @memberof StakingApiMergeStakeAccounts
     */
    readonly mergeStakeAccountsRequest: MergeStakeAccountsRequest

    /**
     * The protocol identifier (e.g. \&quot;SOL\&quot;/\&quot;SOL_TEST\&quot;) to use
     * @type {'SOL' | 'SOL_TEST'}
     * @memberof StakingApiMergeStakeAccounts
     */
    readonly chainDescriptor: MergeStakeAccountsChainDescriptorEnum

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof StakingApiMergeStakeAccounts
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for split operation in StakingApi.
 * @export
 * @interface StakingApiSplitRequest
 */
export interface StakingApiSplitRequest {
    /**
     * 
     * @type {SplitRequest}
     * @memberof StakingApiSplit
     */
    readonly splitRequest: SplitRequest

    /**
     * The protocol identifier (e.g. \&quot;SOL\&quot;/\&quot;SOL_TEST\&quot;) to use
     * @type {'SOL' | 'SOL_TEST'}
     * @memberof StakingApiSplit
     */
    readonly chainDescriptor: SplitChainDescriptorEnum

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof StakingApiSplit
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for stake operation in StakingApi.
 * @export
 * @interface StakingApiStakeRequest
 */
export interface StakingApiStakeRequest {
    /**
     * 
     * @type {StakeRequest}
     * @memberof StakingApiStake
     */
    readonly stakeRequest: StakeRequest

    /**
     * The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;) to use
     * @type {ChainDescriptor}
     * @memberof StakingApiStake
     */
    readonly chainDescriptor: ChainDescriptor

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof StakingApiStake
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for unstake operation in StakingApi.
 * @export
 * @interface StakingApiUnstakeRequest
 */
export interface StakingApiUnstakeRequest {
    /**
     * 
     * @type {UnstakeRequest}
     * @memberof StakingApiUnstake
     */
    readonly unstakeRequest: UnstakeRequest

    /**
     * The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;) to use
     * @type {ChainDescriptor}
     * @memberof StakingApiUnstake
     */
    readonly chainDescriptor: ChainDescriptor

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof StakingApiUnstake
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for withdraw operation in StakingApi.
 * @export
 * @interface StakingApiWithdrawRequest
 */
export interface StakingApiWithdrawRequest {
    /**
     * 
     * @type {WithdrawRequest}
     * @memberof StakingApiWithdraw
     */
    readonly withdrawRequest: WithdrawRequest

    /**
     * The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;) to use
     * @type {ChainDescriptor}
     * @memberof StakingApiWithdraw
     */
    readonly chainDescriptor: ChainDescriptor

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof StakingApiWithdraw
     */
    readonly idempotencyKey?: string
}

/**
 * StakingApi - object-oriented interface
 * @export
 * @class StakingApi
 * @extends {BaseAPI}
 */
export class StakingApi extends BaseAPI {
    /**
     * Approve the terms of service of the staking provider. This must be called before performing a staking action for the first time with this provider.
     * @summary Approve staking terms of service
     * @param {StakingApiApproveTermsOfServiceByProviderIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public approveTermsOfServiceByProviderId(requestParameters: StakingApiApproveTermsOfServiceByProviderIdRequest) {
        return StakingApiFp(this.configuration).approveTermsOfServiceByProviderId(requestParameters.providerId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Perform a chain-specific Claim Rewards.
     * @summary Execute a Claim Rewards operation
     * @param {StakingApiClaimRewardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public claimRewards(requestParameters: StakingApiClaimRewardsRequest) {
        return StakingApiFp(this.configuration).claimRewards(requestParameters.claimRewardsRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return detailed information on all staking positions, including the staked amount, rewards, status and more.
     * @summary List staking positions details
     * @param {StakingApiGetAllDelegationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getAllDelegations(requestParameters: StakingApiGetAllDelegationsRequest = {}) {
        return StakingApiFp(this.configuration).getAllDelegations(requestParameters.chainDescriptor).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return chain-specific, staking-related information summary (e.g. epoch details, lockup durations, estimated rewards, etc.)
     * @summary Get chain-specific staking summary
     * @param {StakingApiGetChainInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getChainInfo(requestParameters: StakingApiGetChainInfoRequest) {
        return StakingApiFp(this.configuration).getChainInfo(requestParameters.chainDescriptor).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return an alphabetical list of supported chains.
     * @summary List staking supported chains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getChains() {
        return StakingApiFp(this.configuration).getChains().then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return detailed information on a staking position, including the staked amount, rewards, status and more.
     * @summary Get staking position details
     * @param {StakingApiGetDelegationByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getDelegationById(requestParameters: StakingApiGetDelegationByIdRequest) {
        return StakingApiFp(this.configuration).getDelegationById(requestParameters.id).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return information on all the available staking providers.
     * @summary List staking providers details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getProviders() {
        return StakingApiFp(this.configuration).getProviders().then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return a summary of all vaults, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
     * @summary Get staking summary details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getSummary() {
        return StakingApiFp(this.configuration).getSummary().then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return a summary for each vault, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
     * @summary Get staking summary details by vault
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public getSummaryByVault() {
        return StakingApiFp(this.configuration).getSummaryByVault().then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Perform a Solana Merge of two active stake accounts into one.  Endpoint Permission: Owner, Admin, Non-Signing Admin, Signer, Approver, Editor, Viewer.
     * @summary Merge Solana on stake accounts
     * @param {StakingApiMergeStakeAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public mergeStakeAccounts(requestParameters: StakingApiMergeStakeAccountsRequest) {
        return StakingApiFp(this.configuration).mergeStakeAccounts(requestParameters.mergeStakeAccountsRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Perform a Solana Split stake account.
     * @summary Execute a Split operation on SOL/SOL_TEST stake account
     * @param {StakingApiSplitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public split(requestParameters: StakingApiSplitRequest) {
        return StakingApiFp(this.configuration).split(requestParameters.splitRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Perform a chain-specific Stake.
     * @summary Initiate Stake Operation
     * @param {StakingApiStakeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public stake(requestParameters: StakingApiStakeRequest) {
        return StakingApiFp(this.configuration).stake(requestParameters.stakeRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Execute an Unstake operation
     * @summary Execute an Unstake operation
     * @param {StakingApiUnstakeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public unstake(requestParameters: StakingApiUnstakeRequest) {
        return StakingApiFp(this.configuration).unstake(requestParameters.unstakeRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Perform a chain-specific Withdraw.
     * @summary Execute a Withdraw operation
     * @param {StakingApiWithdrawRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    public withdraw(requestParameters: StakingApiWithdrawRequest) {
        return StakingApiFp(this.configuration).withdraw(requestParameters.withdrawRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }
}

/**
 * @export
 */
export const ClaimRewardsChainDescriptorEnum = {
    Matic: 'MATIC',
    Sol: 'SOL',
    SolTest: 'SOL_TEST'
} as const;
export type ClaimRewardsChainDescriptorEnum = typeof ClaimRewardsChainDescriptorEnum[keyof typeof ClaimRewardsChainDescriptorEnum];
/**
 * @export
 */
export const MergeStakeAccountsChainDescriptorEnum = {
    Sol: 'SOL',
    SolTest: 'SOL_TEST'
} as const;
export type MergeStakeAccountsChainDescriptorEnum = typeof MergeStakeAccountsChainDescriptorEnum[keyof typeof MergeStakeAccountsChainDescriptorEnum];
/**
 * @export
 */
export const SplitChainDescriptorEnum = {
    Sol: 'SOL',
    SolTest: 'SOL_TEST'
} as const;
export type SplitChainDescriptorEnum = typeof SplitChainDescriptorEnum[keyof typeof SplitChainDescriptorEnum];
