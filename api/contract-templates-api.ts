/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import { convertToFireblocksResponse } from "../response/fireblocksResponse";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import { assertParamExistsAndNotEmpty } from '../utils/validation_utils';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { AbiFunction } from '../models';
// @ts-ignore
import { ContractDeployRequest } from '../models';
// @ts-ignore
import { ContractDeployResponse } from '../models';
// @ts-ignore
import { ContractTemplateDto } from '../models';
// @ts-ignore
import { ContractUploadRequest } from '../models';
// @ts-ignore
import { ErrorSchema } from '../models';
// @ts-ignore
import { HttpContractDoesNotExistError } from '../models';
// @ts-ignore
import { TemplatesPaginatedResponse } from '../models';
/**
 * ContractTemplatesApi - axios parameter creator
 * @export
 */
export const ContractTemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a contract by id. allowed only for private contract templates. Notice: it is irreversible!
         * @summary Delete a contract template by id
         * @param {string} contractTemplateId The Contract Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContractTemplateById: async (contractTemplateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('deleteContractTemplateById', 'contractTemplateId', contractTemplateId)
            const localVarPath = `/tokenization/templates/{contractTemplateId}`
                .replace(`{${"contractTemplateId"}}`, encodeURIComponent(String(contractTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new contract by contract template id. If you wish to deploy a token (ERC20, ERC721 etc), and create asset please use POST /tokenization
         * @summary Deploy contract
         * @param {ContractDeployRequest} contractDeployRequest 
         * @param {string} contractTemplateId The Contract Template identifier
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContract: async (contractDeployRequest: ContractDeployRequest, contractTemplateId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('deployContract', 'contractDeployRequest', contractDeployRequest)
            assertParamExistsAndNotEmpty('deployContract', 'contractTemplateId', contractTemplateId)
            const localVarPath = `/tokenization/templates/{contractTemplateId}/deploy`
                .replace(`{${"contractTemplateId"}}`, encodeURIComponent(String(contractTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractDeployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return contract template\'s constructor ABI
         * @summary Return contract template\'s constructor
         * @param {string} contractTemplateId The Contract Template identifier
         * @param {boolean} [withDocs] true if you want to get the abi with its docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConstructorByContractTemplateId: async (contractTemplateId: string, withDocs?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getConstructorByContractTemplateId', 'contractTemplateId', contractTemplateId)
            const localVarPath = `/tokenization/templates/{contractTemplateId}/constructor`
                .replace(`{${"contractTemplateId"}}`, encodeURIComponent(String(contractTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withDocs !== undefined) {
                localVarQueryParameter['withDocs'] = withDocs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return detailed information about the contract template
         * @summary Return contract template by id
         * @param {string} contractTemplateId The Contract Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractTemplateById: async (contractTemplateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getContractTemplateById', 'contractTemplateId', contractTemplateId)
            const localVarPath = `/tokenization/templates/{contractTemplateId}`
                .replace(`{${"contractTemplateId"}}`, encodeURIComponent(String(contractTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return minimal representation of all the contract templates available for the workspace
         * @summary List all contract templates
         * @param {number} [limit] Items per page (max 100)
         * @param {number} [offset] Paging offset
         * @param {string} [pageCursor] Page cursor to get the next page
         * @param {number} [pageSize] Number of items per page, requesting more then max will return max items
         * @param {GetContractTemplatesTypeEnum} [type] The type of the contract templates you wish to retrieve. Can accept one type, more or none
         * @param {GetContractTemplatesInitializationPhaseEnum} [initializationPhase] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractTemplates: async (limit?: number, offset?: number, pageCursor?: string, pageSize?: number, type?: GetContractTemplatesTypeEnum, initializationPhase?: GetContractTemplatesInitializationPhaseEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokenization/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (initializationPhase !== undefined) {
                localVarQueryParameter['initializationPhase'] = initializationPhase;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return contract template`s function ABI by signature
         * @summary Return contract template\'s function
         * @param {string} contractTemplateId The Contract Template identifier
         * @param {string} functionSignature 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFunctionAbiByContractTemplateId: async (contractTemplateId: string, functionSignature: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getFunctionAbiByContractTemplateId', 'contractTemplateId', contractTemplateId)
            assertParamExistsAndNotEmpty('getFunctionAbiByContractTemplateId', 'functionSignature', functionSignature)
            const localVarPath = `/tokenization/templates/{contractTemplateId}/function`
                .replace(`{${"contractTemplateId"}}`, encodeURIComponent(String(contractTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (functionSignature !== undefined) {
                localVarQueryParameter['functionSignature'] = functionSignature;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a new contract template. This contract template will be available for the workspace
         * @summary Upload contract template
         * @param {ContractUploadRequest} contractUploadRequest 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadContractTemplate: async (contractUploadRequest: ContractUploadRequest, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('uploadContractTemplate', 'contractUploadRequest', contractUploadRequest)
            const localVarPath = `/tokenization/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractUploadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractTemplatesApi - functional programming interface
 * @export
 */
export const ContractTemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractTemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a contract by id. allowed only for private contract templates. Notice: it is irreversible!
         * @summary Delete a contract template by id
         * @param {string} contractTemplateId The Contract Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContractTemplateById(contractTemplateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContractTemplateById(contractTemplateId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContractTemplatesApi.deleteContractTemplateById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deploy a new contract by contract template id. If you wish to deploy a token (ERC20, ERC721 etc), and create asset please use POST /tokenization
         * @summary Deploy contract
         * @param {ContractDeployRequest} contractDeployRequest 
         * @param {string} contractTemplateId The Contract Template identifier
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployContract(contractDeployRequest: ContractDeployRequest, contractTemplateId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractDeployResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployContract(contractDeployRequest, contractTemplateId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContractTemplatesApi.deployContract']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return contract template\'s constructor ABI
         * @summary Return contract template\'s constructor
         * @param {string} contractTemplateId The Contract Template identifier
         * @param {boolean} [withDocs] true if you want to get the abi with its docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConstructorByContractTemplateId(contractTemplateId: string, withDocs?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AbiFunction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConstructorByContractTemplateId(contractTemplateId, withDocs, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContractTemplatesApi.getConstructorByContractTemplateId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return detailed information about the contract template
         * @summary Return contract template by id
         * @param {string} contractTemplateId The Contract Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractTemplateById(contractTemplateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractTemplateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractTemplateById(contractTemplateId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContractTemplatesApi.getContractTemplateById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return minimal representation of all the contract templates available for the workspace
         * @summary List all contract templates
         * @param {number} [limit] Items per page (max 100)
         * @param {number} [offset] Paging offset
         * @param {string} [pageCursor] Page cursor to get the next page
         * @param {number} [pageSize] Number of items per page, requesting more then max will return max items
         * @param {GetContractTemplatesTypeEnum} [type] The type of the contract templates you wish to retrieve. Can accept one type, more or none
         * @param {GetContractTemplatesInitializationPhaseEnum} [initializationPhase] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractTemplates(limit?: number, offset?: number, pageCursor?: string, pageSize?: number, type?: GetContractTemplatesTypeEnum, initializationPhase?: GetContractTemplatesInitializationPhaseEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractTemplates(limit, offset, pageCursor, pageSize, type, initializationPhase, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContractTemplatesApi.getContractTemplates']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return contract template`s function ABI by signature
         * @summary Return contract template\'s function
         * @param {string} contractTemplateId The Contract Template identifier
         * @param {string} functionSignature 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFunctionAbiByContractTemplateId(contractTemplateId: string, functionSignature: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AbiFunction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFunctionAbiByContractTemplateId(contractTemplateId, functionSignature, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContractTemplatesApi.getFunctionAbiByContractTemplateId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Upload a new contract template. This contract template will be available for the workspace
         * @summary Upload contract template
         * @param {ContractUploadRequest} contractUploadRequest 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadContractTemplate(contractUploadRequest: ContractUploadRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractTemplateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadContractTemplate(contractUploadRequest, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ContractTemplatesApi.uploadContractTemplate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ContractTemplatesApi - factory interface
 * @export
 */
export const ContractTemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractTemplatesApiFp(configuration)
    return {
        /**
         * Delete a contract by id. allowed only for private contract templates. Notice: it is irreversible!
         * @summary Delete a contract template by id
         * @param {ContractTemplatesApiDeleteContractTemplateByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContractTemplateById(requestParameters: ContractTemplatesApiDeleteContractTemplateByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteContractTemplateById(requestParameters.contractTemplateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy a new contract by contract template id. If you wish to deploy a token (ERC20, ERC721 etc), and create asset please use POST /tokenization
         * @summary Deploy contract
         * @param {ContractTemplatesApiDeployContractRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployContract(requestParameters: ContractTemplatesApiDeployContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractDeployResponse> {
            return localVarFp.deployContract(requestParameters.contractDeployRequest, requestParameters.contractTemplateId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Return contract template\'s constructor ABI
         * @summary Return contract template\'s constructor
         * @param {ContractTemplatesApiGetConstructorByContractTemplateIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConstructorByContractTemplateId(requestParameters: ContractTemplatesApiGetConstructorByContractTemplateIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<AbiFunction> {
            return localVarFp.getConstructorByContractTemplateId(requestParameters.contractTemplateId, requestParameters.withDocs, options).then((request) => request(axios, basePath));
        },
        /**
         * Return detailed information about the contract template
         * @summary Return contract template by id
         * @param {ContractTemplatesApiGetContractTemplateByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractTemplateById(requestParameters: ContractTemplatesApiGetContractTemplateByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractTemplateDto> {
            return localVarFp.getContractTemplateById(requestParameters.contractTemplateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return minimal representation of all the contract templates available for the workspace
         * @summary List all contract templates
         * @param {ContractTemplatesApiGetContractTemplatesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractTemplates(requestParameters: ContractTemplatesApiGetContractTemplatesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<TemplatesPaginatedResponse> {
            return localVarFp.getContractTemplates(requestParameters.limit, requestParameters.offset, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.type, requestParameters.initializationPhase, options).then((request) => request(axios, basePath));
        },
        /**
         * Return contract template`s function ABI by signature
         * @summary Return contract template\'s function
         * @param {ContractTemplatesApiGetFunctionAbiByContractTemplateIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFunctionAbiByContractTemplateId(requestParameters: ContractTemplatesApiGetFunctionAbiByContractTemplateIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<AbiFunction> {
            return localVarFp.getFunctionAbiByContractTemplateId(requestParameters.contractTemplateId, requestParameters.functionSignature, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a new contract template. This contract template will be available for the workspace
         * @summary Upload contract template
         * @param {ContractTemplatesApiUploadContractTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadContractTemplate(requestParameters: ContractTemplatesApiUploadContractTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractTemplateDto> {
            return localVarFp.uploadContractTemplate(requestParameters.contractUploadRequest, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteContractTemplateById operation in ContractTemplatesApi.
 * @export
 * @interface ContractTemplatesApiDeleteContractTemplateByIdRequest
 */
export interface ContractTemplatesApiDeleteContractTemplateByIdRequest {
    /**
     * The Contract Template identifier
     * @type {string}
     * @memberof ContractTemplatesApiDeleteContractTemplateById
     */
    readonly contractTemplateId: string
}

/**
 * Request parameters for deployContract operation in ContractTemplatesApi.
 * @export
 * @interface ContractTemplatesApiDeployContractRequest
 */
export interface ContractTemplatesApiDeployContractRequest {
    /**
     * 
     * @type {ContractDeployRequest}
     * @memberof ContractTemplatesApiDeployContract
     */
    readonly contractDeployRequest: ContractDeployRequest

    /**
     * The Contract Template identifier
     * @type {string}
     * @memberof ContractTemplatesApiDeployContract
     */
    readonly contractTemplateId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof ContractTemplatesApiDeployContract
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for getConstructorByContractTemplateId operation in ContractTemplatesApi.
 * @export
 * @interface ContractTemplatesApiGetConstructorByContractTemplateIdRequest
 */
export interface ContractTemplatesApiGetConstructorByContractTemplateIdRequest {
    /**
     * The Contract Template identifier
     * @type {string}
     * @memberof ContractTemplatesApiGetConstructorByContractTemplateId
     */
    readonly contractTemplateId: string

    /**
     * true if you want to get the abi with its docs
     * @type {boolean}
     * @memberof ContractTemplatesApiGetConstructorByContractTemplateId
     */
    readonly withDocs?: boolean
}

/**
 * Request parameters for getContractTemplateById operation in ContractTemplatesApi.
 * @export
 * @interface ContractTemplatesApiGetContractTemplateByIdRequest
 */
export interface ContractTemplatesApiGetContractTemplateByIdRequest {
    /**
     * The Contract Template identifier
     * @type {string}
     * @memberof ContractTemplatesApiGetContractTemplateById
     */
    readonly contractTemplateId: string
}

/**
 * Request parameters for getContractTemplates operation in ContractTemplatesApi.
 * @export
 * @interface ContractTemplatesApiGetContractTemplatesRequest
 */
export interface ContractTemplatesApiGetContractTemplatesRequest {
    /**
     * Items per page (max 100)
     * @type {number}
     * @memberof ContractTemplatesApiGetContractTemplates
     */
    readonly limit?: number

    /**
     * Paging offset
     * @type {number}
     * @memberof ContractTemplatesApiGetContractTemplates
     */
    readonly offset?: number

    /**
     * Page cursor to get the next page
     * @type {string}
     * @memberof ContractTemplatesApiGetContractTemplates
     */
    readonly pageCursor?: string

    /**
     * Number of items per page, requesting more then max will return max items
     * @type {number}
     * @memberof ContractTemplatesApiGetContractTemplates
     */
    readonly pageSize?: number

    /**
     * The type of the contract templates you wish to retrieve. Can accept one type, more or none
     * @type {'FUNGIBLE_TOKEN' | 'NON_FUNGIBLE_TOKEN' | 'TOKEN_UTILITY'}
     * @memberof ContractTemplatesApiGetContractTemplates
     */
    readonly type?: GetContractTemplatesTypeEnum

    /**
     * 
     * @type {'ON_DEPLOYMENT' | 'POST_DEPLOYMENT'}
     * @memberof ContractTemplatesApiGetContractTemplates
     */
    readonly initializationPhase?: GetContractTemplatesInitializationPhaseEnum
}

/**
 * Request parameters for getFunctionAbiByContractTemplateId operation in ContractTemplatesApi.
 * @export
 * @interface ContractTemplatesApiGetFunctionAbiByContractTemplateIdRequest
 */
export interface ContractTemplatesApiGetFunctionAbiByContractTemplateIdRequest {
    /**
     * The Contract Template identifier
     * @type {string}
     * @memberof ContractTemplatesApiGetFunctionAbiByContractTemplateId
     */
    readonly contractTemplateId: string

    /**
     * 
     * @type {string}
     * @memberof ContractTemplatesApiGetFunctionAbiByContractTemplateId
     */
    readonly functionSignature: string
}

/**
 * Request parameters for uploadContractTemplate operation in ContractTemplatesApi.
 * @export
 * @interface ContractTemplatesApiUploadContractTemplateRequest
 */
export interface ContractTemplatesApiUploadContractTemplateRequest {
    /**
     * 
     * @type {ContractUploadRequest}
     * @memberof ContractTemplatesApiUploadContractTemplate
     */
    readonly contractUploadRequest: ContractUploadRequest

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof ContractTemplatesApiUploadContractTemplate
     */
    readonly idempotencyKey?: string
}

/**
 * ContractTemplatesApi - object-oriented interface
 * @export
 * @class ContractTemplatesApi
 * @extends {BaseAPI}
 */
export class ContractTemplatesApi extends BaseAPI {
    /**
     * Delete a contract by id. allowed only for private contract templates. Notice: it is irreversible!
     * @summary Delete a contract template by id
     * @param {ContractTemplatesApiDeleteContractTemplateByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractTemplatesApi
     */
    public deleteContractTemplateById(requestParameters: ContractTemplatesApiDeleteContractTemplateByIdRequest) {
        return ContractTemplatesApiFp(this.configuration).deleteContractTemplateById(requestParameters.contractTemplateId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Deploy a new contract by contract template id. If you wish to deploy a token (ERC20, ERC721 etc), and create asset please use POST /tokenization
     * @summary Deploy contract
     * @param {ContractTemplatesApiDeployContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractTemplatesApi
     */
    public deployContract(requestParameters: ContractTemplatesApiDeployContractRequest) {
        return ContractTemplatesApiFp(this.configuration).deployContract(requestParameters.contractDeployRequest, requestParameters.contractTemplateId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return contract template\'s constructor ABI
     * @summary Return contract template\'s constructor
     * @param {ContractTemplatesApiGetConstructorByContractTemplateIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractTemplatesApi
     */
    public getConstructorByContractTemplateId(requestParameters: ContractTemplatesApiGetConstructorByContractTemplateIdRequest) {
        return ContractTemplatesApiFp(this.configuration).getConstructorByContractTemplateId(requestParameters.contractTemplateId, requestParameters.withDocs).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return detailed information about the contract template
     * @summary Return contract template by id
     * @param {ContractTemplatesApiGetContractTemplateByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractTemplatesApi
     */
    public getContractTemplateById(requestParameters: ContractTemplatesApiGetContractTemplateByIdRequest) {
        return ContractTemplatesApiFp(this.configuration).getContractTemplateById(requestParameters.contractTemplateId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return minimal representation of all the contract templates available for the workspace
     * @summary List all contract templates
     * @param {ContractTemplatesApiGetContractTemplatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractTemplatesApi
     */
    public getContractTemplates(requestParameters: ContractTemplatesApiGetContractTemplatesRequest = {}) {
        return ContractTemplatesApiFp(this.configuration).getContractTemplates(requestParameters.limit, requestParameters.offset, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.type, requestParameters.initializationPhase).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return contract template`s function ABI by signature
     * @summary Return contract template\'s function
     * @param {ContractTemplatesApiGetFunctionAbiByContractTemplateIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractTemplatesApi
     */
    public getFunctionAbiByContractTemplateId(requestParameters: ContractTemplatesApiGetFunctionAbiByContractTemplateIdRequest) {
        return ContractTemplatesApiFp(this.configuration).getFunctionAbiByContractTemplateId(requestParameters.contractTemplateId, requestParameters.functionSignature).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Upload a new contract template. This contract template will be available for the workspace
     * @summary Upload contract template
     * @param {ContractTemplatesApiUploadContractTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractTemplatesApi
     */
    public uploadContractTemplate(requestParameters: ContractTemplatesApiUploadContractTemplateRequest) {
        return ContractTemplatesApiFp(this.configuration).uploadContractTemplate(requestParameters.contractUploadRequest, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }
}

/**
 * @export
 */
export const GetContractTemplatesTypeEnum = {
    FungibleToken: 'FUNGIBLE_TOKEN',
    NonFungibleToken: 'NON_FUNGIBLE_TOKEN',
    TokenUtility: 'TOKEN_UTILITY'
} as const;
export type GetContractTemplatesTypeEnum = typeof GetContractTemplatesTypeEnum[keyof typeof GetContractTemplatesTypeEnum];
/**
 * @export
 */
export const GetContractTemplatesInitializationPhaseEnum = {
    OnDeployment: 'ON_DEPLOYMENT',
    PostDeployment: 'POST_DEPLOYMENT'
} as const;
export type GetContractTemplatesInitializationPhaseEnum = typeof GetContractTemplatesInitializationPhaseEnum[keyof typeof GetContractTemplatesInitializationPhaseEnum];
