/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.5.5
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

    import { CancelTransactionResponse } from '../model/cancelTransactionResponse';
    import { CreateTransactionResponse } from '../model/createTransactionResponse';
    import { DropTransactionRequest } from '../model/dropTransactionRequest';
    import { DropTransactionResponse } from '../model/dropTransactionResponse';
    import { EstimatedNetworkFeeResponse } from '../model/estimatedNetworkFeeResponse';
    import { EstimatedTransactionFeeResponse } from '../model/estimatedTransactionFeeResponse';
    import { FreezeTransactionResponse } from '../model/freezeTransactionResponse';
    import { SetConfirmationsThresholdRequest } from '../model/setConfirmationsThresholdRequest';
    import { SetConfirmationsThresholdResponse } from '../model/setConfirmationsThresholdResponse';
    import { TransactionRequest } from '../model/transactionRequest';
    import { TransactionResponse } from '../model/transactionResponse';
    import { UnfreezeTransactionResponse } from '../model/unfreezeTransactionResponse';
    import { ValidateAddressResponse } from '../model/validateAddressResponse';
import {HttpClient} from '../utils/http-client';
import {Configuration, ConfigurationParameters} from '../utils/types/configuration';
import {ObjectSerializer} from "../model/models";
import { AxiosRequestConfig, AxiosResponse } from 'axios';


    export class TransactionsApi {
        private  configuration: Configuration;
        private  httpClient: HttpClient;

        constructor(private configurationParameters:ConfigurationParameters = {}) {
            this.configuration = new Configuration(configurationParameters)
            this.httpClient = new HttpClient(this.configuration);
        }

            /**
            * Gets the estimated required fee for an asset. For UTXO based assets, the response will contain the suggested fee per byte, for ETH/ETC based assets, the suggested gas price, and for XRP/XLM, the transaction fee.
                * @summary Estimate the required fee for an asset
                * @param assetId The asset for which to estimate the fee
            */
        public async estimateNetworkFeeGet (assetId: string, ) : Promise<EstimatedNetworkFeeResponse> {
                const path = this.configuration.basePath + '/estimate_network_fee';
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling estimateNetworkFeeGet.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }
                    if (assetId !== undefined) {
                        params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<EstimatedNetworkFeeResponse>(requestOptions);
        }
            /**
            * Estimates the transaction fee for a transaction request.
                * @summary Estimate transaction fee
                * @param transactionRequest 
            */
        public async transactionsEstimateFeePost (transactionRequest?: TransactionRequest, ) : Promise<EstimatedTransactionFeeResponse> {
                const path = this.configuration.basePath + '/transactions/estimate_fee';
                let params: any = {};
                let headers: any = {}

                    if (typeof transactionRequest === 'object') {
                        for( const [key,value] of Object.entries(transactionRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['TransactionRequest'] = ObjectSerializer.serialize(transactionRequest, "TransactionRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<EstimatedTransactionFeeResponse>(requestOptions);
        }
            /**
            * Returns transaction by external transaction ID.
                * @summary Find a specific transaction by external transaction ID
                * @param externalTxId The external ID of the transaction to return
            */
        public async transactionsExternalTxIdExternalTxIdGet (externalTxId: string, ) : Promise<TransactionResponse> {
                const path = this.configuration.basePath + '/transactions/external_tx_id/{externalTxId}/'
                .replace('{' + 'externalTxId' + '}', encodeURIComponent(String(externalTxId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'externalTxId' is not null or undefined
                        if (externalTxId === null || externalTxId === undefined) {
                        throw new Error('Required parameter externalTxId was null or undefined when calling transactionsExternalTxIdExternalTxIdGet.');
                        }


                    if (typeof externalTxId === 'object') {
                        for( const [key,value] of Object.entries(externalTxId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['externalTxId'] = ObjectSerializer.serialize(externalTxId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<TransactionResponse>(requestOptions);
        }
            /**
            * Lists the transaction history for your workspace.
                * @summary List transaction history
                * @param before Unix timestamp in milliseconds. Returns only transactions created before the specified date
                * @param after Unix timestamp in milliseconds. Returns only transactions created after the specified date
                * @param status You can filter by one of the statuses.
                * @param orderBy The field to order the results by
                * @param sort The direction to order the results by
                * @param limit Limits the number of results. If not provided, a limit of 200 will be used. The maximum allowed limit is 500
                * @param sourceType The source type of the transaction
                * @param sourceId The source ID of the transaction
                * @param destType The destination type of the transaction
                * @param destId The destination ID of the transaction
                * @param assets A list of assets to filter by, seperated by commas
                * @param txHash Returns only results with a specified txHash
            */
        public async transactionsGet (before?: string, after?: string, status?: string, orderBy?: 'createdAt' | 'lastUpdated', sort?: 'ASC' | 'DESC', limit?: number, sourceType?: 'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'UNKNOWN' | 'GAS_STATION' | 'OEC_PARTNER', sourceId?: string, destType?: 'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'ONE_TIME_ADDRESS' | 'OEC_PARTNER', destId?: string, assets?: string, txHash?: string, ) : Promise<Array<TransactionResponse>> {
                const path = this.configuration.basePath + '/transactions';
                let params: any = {};
                let headers: any = {}

                    if (typeof before === 'object') {
                        for( const [key,value] of Object.entries(before)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['before'] = ObjectSerializer.serialize(before, "string");
                    }

                    if (typeof after === 'object') {
                        for( const [key,value] of Object.entries(after)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['after'] = ObjectSerializer.serialize(after, "string");
                    }

                    if (typeof status === 'object') {
                        for( const [key,value] of Object.entries(status)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['status'] = ObjectSerializer.serialize(status, "string");
                    }

                    if (typeof orderBy === 'object') {
                        for( const [key,value] of Object.entries(orderBy)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['orderBy'] = ObjectSerializer.serialize(orderBy, "'createdAt' | 'lastUpdated'");
                    }

                    if (typeof sort === 'object') {
                        for( const [key,value] of Object.entries(sort)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['sort'] = ObjectSerializer.serialize(sort, "'ASC' | 'DESC'");
                    }

                    if (typeof limit === 'object') {
                        for( const [key,value] of Object.entries(limit)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['limit'] = ObjectSerializer.serialize(limit, "number");
                    }

                    if (typeof sourceType === 'object') {
                        for( const [key,value] of Object.entries(sourceType)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['sourceType'] = ObjectSerializer.serialize(sourceType, "'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'UNKNOWN' | 'GAS_STATION' | 'OEC_PARTNER'");
                    }

                    if (typeof sourceId === 'object') {
                        for( const [key,value] of Object.entries(sourceId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['sourceId'] = ObjectSerializer.serialize(sourceId, "string");
                    }

                    if (typeof destType === 'object') {
                        for( const [key,value] of Object.entries(destType)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['destType'] = ObjectSerializer.serialize(destType, "'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'ONE_TIME_ADDRESS' | 'OEC_PARTNER'");
                    }

                    if (typeof destId === 'object') {
                        for( const [key,value] of Object.entries(destId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['destId'] = ObjectSerializer.serialize(destId, "string");
                    }

                    if (typeof assets === 'object') {
                        for( const [key,value] of Object.entries(assets)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assets'] = ObjectSerializer.serialize(assets, "string");
                    }

                    if (typeof txHash === 'object') {
                        for( const [key,value] of Object.entries(txHash)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['txHash'] = ObjectSerializer.serialize(txHash, "string");
                    }
                    if (before !== undefined) {
                        params['before'] = ObjectSerializer.serialize(before, "string");
                    }
                    if (after !== undefined) {
                        params['after'] = ObjectSerializer.serialize(after, "string");
                    }
                    if (status !== undefined) {
                        params['status'] = ObjectSerializer.serialize(status, "string");
                    }
                    if (orderBy !== undefined) {
                        params['orderBy'] = ObjectSerializer.serialize(orderBy, "'createdAt' | 'lastUpdated'");
                    }
                    if (sort !== undefined) {
                        params['sort'] = ObjectSerializer.serialize(sort, "'ASC' | 'DESC'");
                    }
                    if (limit !== undefined) {
                        params['limit'] = ObjectSerializer.serialize(limit, "number");
                    }
                    if (sourceType !== undefined) {
                        params['sourceType'] = ObjectSerializer.serialize(sourceType, "'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'UNKNOWN' | 'GAS_STATION' | 'OEC_PARTNER'");
                    }
                    if (sourceId !== undefined) {
                        params['sourceId'] = ObjectSerializer.serialize(sourceId, "string");
                    }
                    if (destType !== undefined) {
                        params['destType'] = ObjectSerializer.serialize(destType, "'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'ONE_TIME_ADDRESS' | 'OEC_PARTNER'");
                    }
                    if (destId !== undefined) {
                        params['destId'] = ObjectSerializer.serialize(destId, "string");
                    }
                    if (assets !== undefined) {
                        params['assets'] = ObjectSerializer.serialize(assets, "string");
                    }
                    if (txHash !== undefined) {
                        params['txHash'] = ObjectSerializer.serialize(txHash, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<Array<TransactionResponse>>(requestOptions);
        }
            /**
            * Creates a new transaction.
                * @summary Create a new transaction
                * @param transactionRequest 
            */
        public async transactionsPost (transactionRequest?: TransactionRequest, ) : Promise<CreateTransactionResponse> {
                const path = this.configuration.basePath + '/transactions';
                let params: any = {};
                let headers: any = {}

                    if (typeof transactionRequest === 'object') {
                        for( const [key,value] of Object.entries(transactionRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['TransactionRequest'] = ObjectSerializer.serialize(transactionRequest, "TransactionRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<CreateTransactionResponse>(requestOptions);
        }
            /**
            * Cancels a transaction by ID.
                * @summary Cancel a transaction
                * @param txId The ID of the transaction to cancel
            */
        public async transactionsTxIdCancelPost (txId: string, ) : Promise<CancelTransactionResponse> {
                const path = this.configuration.basePath + '/transactions/{txId}/cancel'
                .replace('{' + 'txId' + '}', encodeURIComponent(String(txId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'txId' is not null or undefined
                        if (txId === null || txId === undefined) {
                        throw new Error('Required parameter txId was null or undefined when calling transactionsTxIdCancelPost.');
                        }


                    if (typeof txId === 'object') {
                        for( const [key,value] of Object.entries(txId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['txId'] = ObjectSerializer.serialize(txId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                };
                return this.httpClient.request<CancelTransactionResponse>(requestOptions);
        }
            /**
            * Drops a stuck ETH transaction and creates a replacement transaction.
                * @summary Drop ETH transaction by ID
                * @param txId The ID of the transaction
                * @param dropTransactionRequest 
            */
        public async transactionsTxIdDropPost (txId: string, dropTransactionRequest?: DropTransactionRequest, ) : Promise<DropTransactionResponse> {
                const path = this.configuration.basePath + '/transactions/{txId}/drop'
                .replace('{' + 'txId' + '}', encodeURIComponent(String(txId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'txId' is not null or undefined
                        if (txId === null || txId === undefined) {
                        throw new Error('Required parameter txId was null or undefined when calling transactionsTxIdDropPost.');
                        }


                    if (typeof txId === 'object') {
                        for( const [key,value] of Object.entries(txId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['txId'] = ObjectSerializer.serialize(txId, "string");
                    }

                    if (typeof dropTransactionRequest === 'object') {
                        for( const [key,value] of Object.entries(dropTransactionRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['DropTransactionRequest'] = ObjectSerializer.serialize(dropTransactionRequest, "DropTransactionRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<DropTransactionResponse>(requestOptions);
        }
            /**
            * Freezes a transaction by ID.
                * @summary Freeze a transaction
                * @param txId The ID of the transaction to freeze
            */
        public async transactionsTxIdFreezePost (txId: string, ) : Promise<FreezeTransactionResponse> {
                const path = this.configuration.basePath + '/transactions/{txId}/freeze'
                .replace('{' + 'txId' + '}', encodeURIComponent(String(txId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'txId' is not null or undefined
                        if (txId === null || txId === undefined) {
                        throw new Error('Required parameter txId was null or undefined when calling transactionsTxIdFreezePost.');
                        }


                    if (typeof txId === 'object') {
                        for( const [key,value] of Object.entries(txId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['txId'] = ObjectSerializer.serialize(txId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                };
                return this.httpClient.request<FreezeTransactionResponse>(requestOptions);
        }
            /**
            * Returns a transaction by ID.
                * @summary Find a specific transaction
                * @param txId The ID of the transaction to return
            */
        public async transactionsTxIdGet (txId: string, ) : Promise<TransactionResponse> {
                const path = this.configuration.basePath + '/transactions/{txId}'
                .replace('{' + 'txId' + '}', encodeURIComponent(String(txId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'txId' is not null or undefined
                        if (txId === null || txId === undefined) {
                        throw new Error('Required parameter txId was null or undefined when calling transactionsTxIdGet.');
                        }


                    if (typeof txId === 'object') {
                        for( const [key,value] of Object.entries(txId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['txId'] = ObjectSerializer.serialize(txId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<TransactionResponse>(requestOptions);
        }
            /**
            * Overrides the required number of confirmations for transaction completion by transaction ID.
                * @summary Set confirmation threshold by transaction ID
                * @param txId The ID of the transaction
                * @param setConfirmationsThresholdRequest 
            */
        public async transactionsTxIdSetConfirmationThresholdPost (txId: string, setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest, ) : Promise<SetConfirmationsThresholdResponse> {
                const path = this.configuration.basePath + '/transactions/{txId}/set_confirmation_threshold'
                .replace('{' + 'txId' + '}', encodeURIComponent(String(txId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'txId' is not null or undefined
                        if (txId === null || txId === undefined) {
                        throw new Error('Required parameter txId was null or undefined when calling transactionsTxIdSetConfirmationThresholdPost.');
                        }


                    if (typeof txId === 'object') {
                        for( const [key,value] of Object.entries(txId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['txId'] = ObjectSerializer.serialize(txId, "string");
                    }

                    if (typeof setConfirmationsThresholdRequest === 'object') {
                        for( const [key,value] of Object.entries(setConfirmationsThresholdRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['SetConfirmationsThresholdRequest'] = ObjectSerializer.serialize(setConfirmationsThresholdRequest, "SetConfirmationsThresholdRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<SetConfirmationsThresholdResponse>(requestOptions);
        }
            /**
            * Unfreezes a transaction by ID and makes the transaction available again.
                * @summary Unfreeze a transaction
                * @param txId The ID of the transaction to unfreeze
            */
        public async transactionsTxIdUnfreezePost (txId: string, ) : Promise<UnfreezeTransactionResponse> {
                const path = this.configuration.basePath + '/transactions/{txId}/unfreeze'
                .replace('{' + 'txId' + '}', encodeURIComponent(String(txId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'txId' is not null or undefined
                        if (txId === null || txId === undefined) {
                        throw new Error('Required parameter txId was null or undefined when calling transactionsTxIdUnfreezePost.');
                        }


                    if (typeof txId === 'object') {
                        for( const [key,value] of Object.entries(txId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['txId'] = ObjectSerializer.serialize(txId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                };
                return this.httpClient.request<UnfreezeTransactionResponse>(requestOptions);
        }
            /**
            * Checks if an address is valid (for XRP, DOT, XLM, and EOS).
                * @summary Validate destination address
                * @param assetId The asset of the address
                * @param address The address to validate
            */
        public async transactionsValidateAddressAssetIdAddressGet (assetId: string, address: string, ) : Promise<ValidateAddressResponse> {
                const path = this.configuration.basePath + '/transactions/validate_address/{assetId}/{address}'
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)))
                .replace('{' + 'address' + '}', encodeURIComponent(String(address)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling transactionsValidateAddressAssetIdAddressGet.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }
                        // verify required parameter 'address' is not null or undefined
                        if (address === null || address === undefined) {
                        throw new Error('Required parameter address was null or undefined when calling transactionsValidateAddressAssetIdAddressGet.');
                        }


                    if (typeof address === 'object') {
                        for( const [key,value] of Object.entries(address)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['address'] = ObjectSerializer.serialize(address, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<ValidateAddressResponse>(requestOptions);
        }
            /**
            * Overrides the required number of confirmations for transaction completion by transaction hash.
                * @summary Set confirmation threshold by transaction hash
                * @param txHash The TxHash
                * @param setConfirmationsThresholdRequest 
            */
        public async txHashTxHashSetConfirmationThresholdPost (txHash: string, setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest, ) : Promise<SetConfirmationsThresholdResponse> {
                const path = this.configuration.basePath + '/txHash/{txHash}/set_confirmation_threshold'
                .replace('{' + 'txHash' + '}', encodeURIComponent(String(txHash)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'txHash' is not null or undefined
                        if (txHash === null || txHash === undefined) {
                        throw new Error('Required parameter txHash was null or undefined when calling txHashTxHashSetConfirmationThresholdPost.');
                        }


                    if (typeof txHash === 'object') {
                        for( const [key,value] of Object.entries(txHash)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['txHash'] = ObjectSerializer.serialize(txHash, "string");
                    }

                    if (typeof setConfirmationsThresholdRequest === 'object') {
                        for( const [key,value] of Object.entries(setConfirmationsThresholdRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['SetConfirmationsThresholdRequest'] = ObjectSerializer.serialize(setConfirmationsThresholdRequest, "SetConfirmationsThresholdRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<SetConfirmationsThresholdResponse>(requestOptions);
        }
        }
