/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import { convertToFireblocksResponse } from "../response/fireblocksResponse";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import { assertParamExistsAndNotEmpty } from '../utils/validation_utils';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { CreateWebhookRequest } from '../models';
// @ts-ignore
import { ErrorSchema } from '../models';
// @ts-ignore
import { NotificationPaginatedResponse } from '../models';
// @ts-ignore
import { NotificationStatus } from '../models';
// @ts-ignore
import { NotificationWithData } from '../models';
// @ts-ignore
import { ResendNotificationsByResourceIdRequest } from '../models';
// @ts-ignore
import { UpdateWebhookRequest } from '../models';
// @ts-ignore
import { Webhook } from '../models';
// @ts-ignore
import { WebhookEvent } from '../models';
// @ts-ignore
import { WebhookPaginatedResponse } from '../models';
/**
 * WebhooksV2BetaApi - axios parameter creator
 * @export
 */
export const WebhooksV2BetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new webhook, which will be triggered on the specified events **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Create new webhook
         * @param {CreateWebhookRequest} createWebhookRequest 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (createWebhookRequest: CreateWebhookRequest, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('createWebhook', 'createWebhookRequest', createWebhookRequest)
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook by its id **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Delete webhook
         * @param {string} webhookId The unique identifier of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('deleteWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get notification by id **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Get notification by id
         * @param {string} webhookId The ID of the webhook to fetch
         * @param {string} notificationId The ID of the notification to fetch
         * @param {boolean} [includeData] Include the data of the notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotification: async (webhookId: string, notificationId: string, includeData?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getNotification', 'webhookId', webhookId)
            assertParamExistsAndNotEmpty('getNotification', 'notificationId', notificationId)
            const localVarPath = `/webhooks/{webhookId}/notifications/{notificationId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeData !== undefined) {
                localVarQueryParameter['includeData'] = includeData;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all notifications by webhook id (paginated) **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Get all notifications by webhook id
         * @param {string} webhookId 
         * @param {GetNotificationsOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {string} [pageCursor] Cursor of the required page
         * @param {number} [pageSize] Maximum number of items in the page
         * @param {string} [createdStartDate] sort by start date
         * @param {string} [createdEndDate] sort by end date
         * @param {Array<NotificationStatus>} [statuses] Filter by Notification statues
         * @param {Array<WebhookEvent>} [eventTypes] Filter by Notification eventTypes
         * @param {string} [resourceId] Filter by resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (webhookId: string, order?: GetNotificationsOrderEnum, pageCursor?: string, pageSize?: number, createdStartDate?: string, createdEndDate?: string, statuses?: Array<NotificationStatus>, eventTypes?: Array<WebhookEvent>, resourceId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getNotifications', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}/notifications`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (createdStartDate !== undefined) {
                localVarQueryParameter['createdStartDate'] = createdStartDate;
            }

            if (createdEndDate !== undefined) {
                localVarQueryParameter['createdEndDate'] = createdEndDate;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (eventTypes) {
                localVarQueryParameter['eventTypes'] = eventTypes;
            }

            if (resourceId !== undefined) {
                localVarQueryParameter['resourceId'] = resourceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a webhook by its id **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Get webhook by id
         * @param {string} webhookId The unique identifier of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all webhooks (paginated) **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Get all webhooks
         * @param {GetWebhooksOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {string} [pageCursor] Cursor of the required page
         * @param {number} [pageSize] Maximum number of items in the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: async (order?: GetWebhooksOrderEnum, pageCursor?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend notification by ID **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Resend notification by id
         * @param {string} webhookId The ID of the webhook
         * @param {string} notificationId The ID of the notification
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendNotificationById: async (webhookId: string, notificationId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('resendNotificationById', 'webhookId', webhookId)
            assertParamExistsAndNotEmpty('resendNotificationById', 'notificationId', notificationId)
            const localVarPath = `/webhooks/{webhookId}/notifications/{notificationId}/resend`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)))
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend notifications by resource Id **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Resend notifications by resource Id
         * @param {ResendNotificationsByResourceIdRequest} resendNotificationsByResourceIdRequest 
         * @param {string} webhookId The ID of the webhook
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendNotificationsByResourceId: async (resendNotificationsByResourceIdRequest: ResendNotificationsByResourceIdRequest, webhookId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('resendNotificationsByResourceId', 'resendNotificationsByResourceIdRequest', resendNotificationsByResourceIdRequest)
            assertParamExistsAndNotEmpty('resendNotificationsByResourceId', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}/notifications/resend_by_resource`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendNotificationsByResourceIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a webhook by its id **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Update webhook
         * @param {UpdateWebhookRequest} updateWebhookRequest 
         * @param {string} webhookId The unique identifier of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (updateWebhookRequest: UpdateWebhookRequest, webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('updateWebhook', 'updateWebhookRequest', updateWebhookRequest)
            assertParamExistsAndNotEmpty('updateWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksV2BetaApi - functional programming interface
 * @export
 */
export const WebhooksV2BetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksV2BetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new webhook, which will be triggered on the specified events **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Create new webhook
         * @param {CreateWebhookRequest} createWebhookRequest 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(createWebhookRequest: CreateWebhookRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(createWebhookRequest, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2BetaApi.createWebhook']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a webhook by its id **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Delete webhook
         * @param {string} webhookId The unique identifier of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2BetaApi.deleteWebhook']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get notification by id **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Get notification by id
         * @param {string} webhookId The ID of the webhook to fetch
         * @param {string} notificationId The ID of the notification to fetch
         * @param {boolean} [includeData] Include the data of the notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotification(webhookId: string, notificationId: string, includeData?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationWithData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotification(webhookId, notificationId, includeData, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2BetaApi.getNotification']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get all notifications by webhook id (paginated) **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Get all notifications by webhook id
         * @param {string} webhookId 
         * @param {GetNotificationsOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {string} [pageCursor] Cursor of the required page
         * @param {number} [pageSize] Maximum number of items in the page
         * @param {string} [createdStartDate] sort by start date
         * @param {string} [createdEndDate] sort by end date
         * @param {Array<NotificationStatus>} [statuses] Filter by Notification statues
         * @param {Array<WebhookEvent>} [eventTypes] Filter by Notification eventTypes
         * @param {string} [resourceId] Filter by resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(webhookId: string, order?: GetNotificationsOrderEnum, pageCursor?: string, pageSize?: number, createdStartDate?: string, createdEndDate?: string, statuses?: Array<NotificationStatus>, eventTypes?: Array<WebhookEvent>, resourceId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotifications(webhookId, order, pageCursor, pageSize, createdStartDate, createdEndDate, statuses, eventTypes, resourceId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2BetaApi.getNotifications']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieve a webhook by its id **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Get webhook by id
         * @param {string} webhookId The unique identifier of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(webhookId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2BetaApi.getWebhook']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get all webhooks (paginated) **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Get all webhooks
         * @param {GetWebhooksOrderEnum} [order] ASC / DESC ordering (default DESC)
         * @param {string} [pageCursor] Cursor of the required page
         * @param {number} [pageSize] Maximum number of items in the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhooks(order?: GetWebhooksOrderEnum, pageCursor?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooks(order, pageCursor, pageSize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2BetaApi.getWebhooks']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Resend notification by ID **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Resend notification by id
         * @param {string} webhookId The ID of the webhook
         * @param {string} notificationId The ID of the notification
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendNotificationById(webhookId: string, notificationId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendNotificationById(webhookId, notificationId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2BetaApi.resendNotificationById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Resend notifications by resource Id **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Resend notifications by resource Id
         * @param {ResendNotificationsByResourceIdRequest} resendNotificationsByResourceIdRequest 
         * @param {string} webhookId The ID of the webhook
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendNotificationsByResourceId(resendNotificationsByResourceIdRequest: ResendNotificationsByResourceIdRequest, webhookId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendNotificationsByResourceId(resendNotificationsByResourceIdRequest, webhookId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2BetaApi.resendNotificationsByResourceId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update a webhook by its id **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Update webhook
         * @param {UpdateWebhookRequest} updateWebhookRequest 
         * @param {string} webhookId The unique identifier of the webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(updateWebhookRequest: UpdateWebhookRequest, webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(updateWebhookRequest, webhookId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['WebhooksV2BetaApi.updateWebhook']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * WebhooksV2BetaApi - factory interface
 * @export
 */
export const WebhooksV2BetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksV2BetaApiFp(configuration)
    return {
        /**
         * Creates a new webhook, which will be triggered on the specified events **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Create new webhook
         * @param {WebhooksV2BetaApiCreateWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(requestParameters: WebhooksV2BetaApiCreateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.createWebhook(requestParameters.createWebhookRequest, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a webhook by its id **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Delete webhook
         * @param {WebhooksV2BetaApiDeleteWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(requestParameters: WebhooksV2BetaApiDeleteWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.deleteWebhook(requestParameters.webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get notification by id **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Get notification by id
         * @param {WebhooksV2BetaApiGetNotificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotification(requestParameters: WebhooksV2BetaApiGetNotificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<NotificationWithData> {
            return localVarFp.getNotification(requestParameters.webhookId, requestParameters.notificationId, requestParameters.includeData, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all notifications by webhook id (paginated) **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Get all notifications by webhook id
         * @param {WebhooksV2BetaApiGetNotificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(requestParameters: WebhooksV2BetaApiGetNotificationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<NotificationPaginatedResponse> {
            return localVarFp.getNotifications(requestParameters.webhookId, requestParameters.order, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.createdStartDate, requestParameters.createdEndDate, requestParameters.statuses, requestParameters.eventTypes, requestParameters.resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a webhook by its id **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Get webhook by id
         * @param {WebhooksV2BetaApiGetWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(requestParameters: WebhooksV2BetaApiGetWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.getWebhook(requestParameters.webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all webhooks (paginated) **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Get all webhooks
         * @param {WebhooksV2BetaApiGetWebhooksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(requestParameters: WebhooksV2BetaApiGetWebhooksRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<WebhookPaginatedResponse> {
            return localVarFp.getWebhooks(requestParameters.order, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend notification by ID **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Resend notification by id
         * @param {WebhooksV2BetaApiResendNotificationByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendNotificationById(requestParameters: WebhooksV2BetaApiResendNotificationByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resendNotificationById(requestParameters.webhookId, requestParameters.notificationId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend notifications by resource Id **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Resend notifications by resource Id
         * @param {WebhooksV2BetaApiResendNotificationsByResourceIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendNotificationsByResourceId(requestParameters: WebhooksV2BetaApiResendNotificationsByResourceIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resendNotificationsByResourceId(requestParameters.resendNotificationsByResourceIdRequest, requestParameters.webhookId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a webhook by its id **Note:** These endpoints are currently in beta and might be subject to changes. 
         * @summary Update webhook
         * @param {WebhooksV2BetaApiUpdateWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(requestParameters: WebhooksV2BetaApiUpdateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.updateWebhook(requestParameters.updateWebhookRequest, requestParameters.webhookId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createWebhook operation in WebhooksV2BetaApi.
 * @export
 * @interface WebhooksV2BetaApiCreateWebhookRequest
 */
export interface WebhooksV2BetaApiCreateWebhookRequest {
    /**
     * 
     * @type {CreateWebhookRequest}
     * @memberof WebhooksV2BetaApiCreateWebhook
     */
    readonly createWebhookRequest: CreateWebhookRequest

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof WebhooksV2BetaApiCreateWebhook
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for deleteWebhook operation in WebhooksV2BetaApi.
 * @export
 * @interface WebhooksV2BetaApiDeleteWebhookRequest
 */
export interface WebhooksV2BetaApiDeleteWebhookRequest {
    /**
     * The unique identifier of the webhook
     * @type {string}
     * @memberof WebhooksV2BetaApiDeleteWebhook
     */
    readonly webhookId: string
}

/**
 * Request parameters for getNotification operation in WebhooksV2BetaApi.
 * @export
 * @interface WebhooksV2BetaApiGetNotificationRequest
 */
export interface WebhooksV2BetaApiGetNotificationRequest {
    /**
     * The ID of the webhook to fetch
     * @type {string}
     * @memberof WebhooksV2BetaApiGetNotification
     */
    readonly webhookId: string

    /**
     * The ID of the notification to fetch
     * @type {string}
     * @memberof WebhooksV2BetaApiGetNotification
     */
    readonly notificationId: string

    /**
     * Include the data of the notification
     * @type {boolean}
     * @memberof WebhooksV2BetaApiGetNotification
     */
    readonly includeData?: boolean
}

/**
 * Request parameters for getNotifications operation in WebhooksV2BetaApi.
 * @export
 * @interface WebhooksV2BetaApiGetNotificationsRequest
 */
export interface WebhooksV2BetaApiGetNotificationsRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhooksV2BetaApiGetNotifications
     */
    readonly webhookId: string

    /**
     * ASC / DESC ordering (default DESC)
     * @type {'ASC' | 'DESC'}
     * @memberof WebhooksV2BetaApiGetNotifications
     */
    readonly order?: GetNotificationsOrderEnum

    /**
     * Cursor of the required page
     * @type {string}
     * @memberof WebhooksV2BetaApiGetNotifications
     */
    readonly pageCursor?: string

    /**
     * Maximum number of items in the page
     * @type {number}
     * @memberof WebhooksV2BetaApiGetNotifications
     */
    readonly pageSize?: number

    /**
     * sort by start date
     * @type {string}
     * @memberof WebhooksV2BetaApiGetNotifications
     */
    readonly createdStartDate?: string

    /**
     * sort by end date
     * @type {string}
     * @memberof WebhooksV2BetaApiGetNotifications
     */
    readonly createdEndDate?: string

    /**
     * Filter by Notification statues
     * @type {Array<NotificationStatus>}
     * @memberof WebhooksV2BetaApiGetNotifications
     */
    readonly statuses?: Array<NotificationStatus>

    /**
     * Filter by Notification eventTypes
     * @type {Array<WebhookEvent>}
     * @memberof WebhooksV2BetaApiGetNotifications
     */
    readonly eventTypes?: Array<WebhookEvent>

    /**
     * Filter by resourceId
     * @type {string}
     * @memberof WebhooksV2BetaApiGetNotifications
     */
    readonly resourceId?: string
}

/**
 * Request parameters for getWebhook operation in WebhooksV2BetaApi.
 * @export
 * @interface WebhooksV2BetaApiGetWebhookRequest
 */
export interface WebhooksV2BetaApiGetWebhookRequest {
    /**
     * The unique identifier of the webhook
     * @type {string}
     * @memberof WebhooksV2BetaApiGetWebhook
     */
    readonly webhookId: string
}

/**
 * Request parameters for getWebhooks operation in WebhooksV2BetaApi.
 * @export
 * @interface WebhooksV2BetaApiGetWebhooksRequest
 */
export interface WebhooksV2BetaApiGetWebhooksRequest {
    /**
     * ASC / DESC ordering (default DESC)
     * @type {'ASC' | 'DESC'}
     * @memberof WebhooksV2BetaApiGetWebhooks
     */
    readonly order?: GetWebhooksOrderEnum

    /**
     * Cursor of the required page
     * @type {string}
     * @memberof WebhooksV2BetaApiGetWebhooks
     */
    readonly pageCursor?: string

    /**
     * Maximum number of items in the page
     * @type {number}
     * @memberof WebhooksV2BetaApiGetWebhooks
     */
    readonly pageSize?: number
}

/**
 * Request parameters for resendNotificationById operation in WebhooksV2BetaApi.
 * @export
 * @interface WebhooksV2BetaApiResendNotificationByIdRequest
 */
export interface WebhooksV2BetaApiResendNotificationByIdRequest {
    /**
     * The ID of the webhook
     * @type {string}
     * @memberof WebhooksV2BetaApiResendNotificationById
     */
    readonly webhookId: string

    /**
     * The ID of the notification
     * @type {string}
     * @memberof WebhooksV2BetaApiResendNotificationById
     */
    readonly notificationId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof WebhooksV2BetaApiResendNotificationById
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for resendNotificationsByResourceId operation in WebhooksV2BetaApi.
 * @export
 * @interface WebhooksV2BetaApiResendNotificationsByResourceIdRequest
 */
export interface WebhooksV2BetaApiResendNotificationsByResourceIdRequest {
    /**
     * 
     * @type {ResendNotificationsByResourceIdRequest}
     * @memberof WebhooksV2BetaApiResendNotificationsByResourceId
     */
    readonly resendNotificationsByResourceIdRequest: ResendNotificationsByResourceIdRequest

    /**
     * The ID of the webhook
     * @type {string}
     * @memberof WebhooksV2BetaApiResendNotificationsByResourceId
     */
    readonly webhookId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof WebhooksV2BetaApiResendNotificationsByResourceId
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for updateWebhook operation in WebhooksV2BetaApi.
 * @export
 * @interface WebhooksV2BetaApiUpdateWebhookRequest
 */
export interface WebhooksV2BetaApiUpdateWebhookRequest {
    /**
     * 
     * @type {UpdateWebhookRequest}
     * @memberof WebhooksV2BetaApiUpdateWebhook
     */
    readonly updateWebhookRequest: UpdateWebhookRequest

    /**
     * The unique identifier of the webhook
     * @type {string}
     * @memberof WebhooksV2BetaApiUpdateWebhook
     */
    readonly webhookId: string
}

/**
 * WebhooksV2BetaApi - object-oriented interface
 * @export
 * @class WebhooksV2BetaApi
 * @extends {BaseAPI}
 */
export class WebhooksV2BetaApi extends BaseAPI {
    /**
     * Creates a new webhook, which will be triggered on the specified events **Note:** These endpoints are currently in beta and might be subject to changes. 
     * @summary Create new webhook
     * @param {WebhooksV2BetaApiCreateWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2BetaApi
     */
    public createWebhook(requestParameters: WebhooksV2BetaApiCreateWebhookRequest) {
        return WebhooksV2BetaApiFp(this.configuration).createWebhook(requestParameters.createWebhookRequest, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Delete a webhook by its id **Note:** These endpoints are currently in beta and might be subject to changes. 
     * @summary Delete webhook
     * @param {WebhooksV2BetaApiDeleteWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2BetaApi
     */
    public deleteWebhook(requestParameters: WebhooksV2BetaApiDeleteWebhookRequest) {
        return WebhooksV2BetaApiFp(this.configuration).deleteWebhook(requestParameters.webhookId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Get notification by id **Note:** These endpoints are currently in beta and might be subject to changes. 
     * @summary Get notification by id
     * @param {WebhooksV2BetaApiGetNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2BetaApi
     */
    public getNotification(requestParameters: WebhooksV2BetaApiGetNotificationRequest) {
        return WebhooksV2BetaApiFp(this.configuration).getNotification(requestParameters.webhookId, requestParameters.notificationId, requestParameters.includeData).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Get all notifications by webhook id (paginated) **Note:** These endpoints are currently in beta and might be subject to changes. 
     * @summary Get all notifications by webhook id
     * @param {WebhooksV2BetaApiGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2BetaApi
     */
    public getNotifications(requestParameters: WebhooksV2BetaApiGetNotificationsRequest) {
        return WebhooksV2BetaApiFp(this.configuration).getNotifications(requestParameters.webhookId, requestParameters.order, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.createdStartDate, requestParameters.createdEndDate, requestParameters.statuses, requestParameters.eventTypes, requestParameters.resourceId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Retrieve a webhook by its id **Note:** These endpoints are currently in beta and might be subject to changes. 
     * @summary Get webhook by id
     * @param {WebhooksV2BetaApiGetWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2BetaApi
     */
    public getWebhook(requestParameters: WebhooksV2BetaApiGetWebhookRequest) {
        return WebhooksV2BetaApiFp(this.configuration).getWebhook(requestParameters.webhookId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Get all webhooks (paginated) **Note:** These endpoints are currently in beta and might be subject to changes. 
     * @summary Get all webhooks
     * @param {WebhooksV2BetaApiGetWebhooksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2BetaApi
     */
    public getWebhooks(requestParameters: WebhooksV2BetaApiGetWebhooksRequest = {}) {
        return WebhooksV2BetaApiFp(this.configuration).getWebhooks(requestParameters.order, requestParameters.pageCursor, requestParameters.pageSize).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Resend notification by ID **Note:** These endpoints are currently in beta and might be subject to changes. 
     * @summary Resend notification by id
     * @param {WebhooksV2BetaApiResendNotificationByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2BetaApi
     */
    public resendNotificationById(requestParameters: WebhooksV2BetaApiResendNotificationByIdRequest) {
        return WebhooksV2BetaApiFp(this.configuration).resendNotificationById(requestParameters.webhookId, requestParameters.notificationId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Resend notifications by resource Id **Note:** These endpoints are currently in beta and might be subject to changes. 
     * @summary Resend notifications by resource Id
     * @param {WebhooksV2BetaApiResendNotificationsByResourceIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2BetaApi
     */
    public resendNotificationsByResourceId(requestParameters: WebhooksV2BetaApiResendNotificationsByResourceIdRequest) {
        return WebhooksV2BetaApiFp(this.configuration).resendNotificationsByResourceId(requestParameters.resendNotificationsByResourceIdRequest, requestParameters.webhookId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Update a webhook by its id **Note:** These endpoints are currently in beta and might be subject to changes. 
     * @summary Update webhook
     * @param {WebhooksV2BetaApiUpdateWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksV2BetaApi
     */
    public updateWebhook(requestParameters: WebhooksV2BetaApiUpdateWebhookRequest) {
        return WebhooksV2BetaApiFp(this.configuration).updateWebhook(requestParameters.updateWebhookRequest, requestParameters.webhookId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }
}

/**
 * @export
 */
export const GetNotificationsOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type GetNotificationsOrderEnum = typeof GetNotificationsOrderEnum[keyof typeof GetNotificationsOrderEnum];
/**
 * @export
 */
export const GetWebhooksOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type GetWebhooksOrderEnum = typeof GetWebhooksOrderEnum[keyof typeof GetWebhooksOrderEnum];
