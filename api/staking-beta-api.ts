/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import { convertToFireblocksResponse } from "../response/fireblocksResponse";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import { assertParamExistsAndNotEmpty } from '../utils/validation_utils';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { ChainInfoResponseDto } from '../models';
// @ts-ignore
import { DelegationDto } from '../models';
// @ts-ignore
import { DelegationSummaryDto } from '../models';
// @ts-ignore
import { ExecuteActionRequest } from '../models';
// @ts-ignore
import { ExecuteActionResponse } from '../models';
// @ts-ignore
import { StakingGetAllDelegationsResponse } from '../models';
// @ts-ignore
import { StakingGetChainsResponse } from '../models';
// @ts-ignore
import { StakingGetProvidersResponse } from '../models';
// @ts-ignore
import { StakingGetSummaryByVaultResponse } from '../models';
/**
 * StakingBetaApi - axios parameter creator
 * @export
 */
export const StakingBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approve the terms of service of the staking provider. This must be called before performing a staking action for the first time with this provider.
         * @summary 
         * @param {ApproveTermsOfServiceByProviderIdProviderIdEnum} providerId The unique identifier of the staking provider
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveTermsOfServiceByProviderId: async (providerId: ApproveTermsOfServiceByProviderIdProviderIdEnum, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('approveTermsOfServiceByProviderId', 'providerId', providerId)
            const localVarPath = `/staking/providers/{providerId}/approveTermsOfService`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a chain-specific staking action (e.g. stake, unstake, withdraw).
         * @summary 
         * @param {ExecuteActionRequest} executeActionRequest 
         * @param {ExecuteActionChainDescriptorEnum} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;) to use
         * @param {ExecuteActionActionIdEnum} actionId The operation that can be executed on a vault/position
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeAction: async (executeActionRequest: ExecuteActionRequest, chainDescriptor: ExecuteActionChainDescriptorEnum, actionId: ExecuteActionActionIdEnum, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('executeAction', 'executeActionRequest', executeActionRequest)
            assertParamExistsAndNotEmpty('executeAction', 'chainDescriptor', chainDescriptor)
            assertParamExistsAndNotEmpty('executeAction', 'actionId', actionId)
            const localVarPath = `/staking/chains/{chainDescriptor}/{actionId}`
                .replace(`{${"chainDescriptor"}}`, encodeURIComponent(String(chainDescriptor)))
                .replace(`{${"actionId"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return detailed information on all staking positions, including the staked amount, rewards, status and more.
         * @summary 
         * @param {string} [chainDescriptor] Use \&quot;ETH\&quot; / \&quot;SOL\&quot; in order to obtain information related to the specific blockchain network or retrieve information about all chains that have data available by providing no argument.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDelegations: async (chainDescriptor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (chainDescriptor !== undefined) {
                localVarQueryParameter['chainDescriptor'] = chainDescriptor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return chain-specific, staking-related information summary (e.g. epoch details, lockup durations, estimated rewards, etc.)
         * @summary 
         * @param {GetChainInfoChainDescriptorEnum} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;) to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChainInfo: async (chainDescriptor: GetChainInfoChainDescriptorEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getChainInfo', 'chainDescriptor', chainDescriptor)
            const localVarPath = `/staking/chains/{chainDescriptor}/chainInfo`
                .replace(`{${"chainDescriptor"}}`, encodeURIComponent(String(chainDescriptor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return an alphabetical list of supported chains.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChains: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/chains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return detailed information on a staking position, including the staked amount, rewards, status and more.
         * @summary 
         * @param {string} id The unique identifier of the staking position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegationById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getDelegationById', 'id', id)
            const localVarPath = `/staking/positions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return information on all the available staking providers.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a summary of all vaults, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummary: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/positions/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a summary for each vault, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummaryByVault: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/staking/positions/summary/vaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StakingBetaApi - functional programming interface
 * @export
 */
export const StakingBetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StakingBetaApiAxiosParamCreator(configuration)
    return {
        /**
         * Approve the terms of service of the staking provider. This must be called before performing a staking action for the first time with this provider.
         * @summary 
         * @param {ApproveTermsOfServiceByProviderIdProviderIdEnum} providerId The unique identifier of the staking provider
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveTermsOfServiceByProviderId(providerId: ApproveTermsOfServiceByProviderIdProviderIdEnum, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveTermsOfServiceByProviderId(providerId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingBetaApi.approveTermsOfServiceByProviderId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Perform a chain-specific staking action (e.g. stake, unstake, withdraw).
         * @summary 
         * @param {ExecuteActionRequest} executeActionRequest 
         * @param {ExecuteActionChainDescriptorEnum} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;) to use
         * @param {ExecuteActionActionIdEnum} actionId The operation that can be executed on a vault/position
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeAction(executeActionRequest: ExecuteActionRequest, chainDescriptor: ExecuteActionChainDescriptorEnum, actionId: ExecuteActionActionIdEnum, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteActionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeAction(executeActionRequest, chainDescriptor, actionId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingBetaApi.executeAction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return detailed information on all staking positions, including the staked amount, rewards, status and more.
         * @summary 
         * @param {string} [chainDescriptor] Use \&quot;ETH\&quot; / \&quot;SOL\&quot; in order to obtain information related to the specific blockchain network or retrieve information about all chains that have data available by providing no argument.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDelegations(chainDescriptor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingGetAllDelegationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDelegations(chainDescriptor, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingBetaApi.getAllDelegations']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return chain-specific, staking-related information summary (e.g. epoch details, lockup durations, estimated rewards, etc.)
         * @summary 
         * @param {GetChainInfoChainDescriptorEnum} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;) to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChainInfo(chainDescriptor: GetChainInfoChainDescriptorEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChainInfoResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChainInfo(chainDescriptor, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingBetaApi.getChainInfo']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return an alphabetical list of supported chains.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChains(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingGetChainsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChains(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingBetaApi.getChains']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return detailed information on a staking position, including the staked amount, rewards, status and more.
         * @summary 
         * @param {string} id The unique identifier of the staking position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDelegationById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelegationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDelegationById(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingBetaApi.getDelegationById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return information on all the available staking providers.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProviders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingGetProvidersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProviders(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingBetaApi.getProviders']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return a summary of all vaults, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSummary(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelegationSummaryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSummary(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingBetaApi.getSummary']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return a summary for each vault, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSummaryByVault(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingGetSummaryByVaultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSummaryByVault(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StakingBetaApi.getSummaryByVault']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * StakingBetaApi - factory interface
 * @export
 */
export const StakingBetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StakingBetaApiFp(configuration)
    return {
        /**
         * Approve the terms of service of the staking provider. This must be called before performing a staking action for the first time with this provider.
         * @summary 
         * @param {StakingBetaApiApproveTermsOfServiceByProviderIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveTermsOfServiceByProviderId(requestParameters: StakingBetaApiApproveTermsOfServiceByProviderIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.approveTermsOfServiceByProviderId(requestParameters.providerId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a chain-specific staking action (e.g. stake, unstake, withdraw).
         * @summary 
         * @param {StakingBetaApiExecuteActionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeAction(requestParameters: StakingBetaApiExecuteActionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExecuteActionResponse> {
            return localVarFp.executeAction(requestParameters.executeActionRequest, requestParameters.chainDescriptor, requestParameters.actionId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Return detailed information on all staking positions, including the staked amount, rewards, status and more.
         * @summary 
         * @param {StakingBetaApiGetAllDelegationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDelegations(requestParameters: StakingBetaApiGetAllDelegationsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<StakingGetAllDelegationsResponse> {
            return localVarFp.getAllDelegations(requestParameters.chainDescriptor, options).then((request) => request(axios, basePath));
        },
        /**
         * Return chain-specific, staking-related information summary (e.g. epoch details, lockup durations, estimated rewards, etc.)
         * @summary 
         * @param {StakingBetaApiGetChainInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChainInfo(requestParameters: StakingBetaApiGetChainInfoRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChainInfoResponseDto> {
            return localVarFp.getChainInfo(requestParameters.chainDescriptor, options).then((request) => request(axios, basePath));
        },
        /**
         * Return an alphabetical list of supported chains.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChains(options?: RawAxiosRequestConfig): AxiosPromise<StakingGetChainsResponse> {
            return localVarFp.getChains(options).then((request) => request(axios, basePath));
        },
        /**
         * Return detailed information on a staking position, including the staked amount, rewards, status and more.
         * @summary 
         * @param {StakingBetaApiGetDelegationByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegationById(requestParameters: StakingBetaApiGetDelegationByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<DelegationDto> {
            return localVarFp.getDelegationById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return information on all the available staking providers.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders(options?: RawAxiosRequestConfig): AxiosPromise<StakingGetProvidersResponse> {
            return localVarFp.getProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * Return a summary of all vaults, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummary(options?: RawAxiosRequestConfig): AxiosPromise<DelegationSummaryDto> {
            return localVarFp.getSummary(options).then((request) => request(axios, basePath));
        },
        /**
         * Return a summary for each vault, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummaryByVault(options?: RawAxiosRequestConfig): AxiosPromise<StakingGetSummaryByVaultResponse> {
            return localVarFp.getSummaryByVault(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approveTermsOfServiceByProviderId operation in StakingBetaApi.
 * @export
 * @interface StakingBetaApiApproveTermsOfServiceByProviderIdRequest
 */
export interface StakingBetaApiApproveTermsOfServiceByProviderIdRequest {
    /**
     * The unique identifier of the staking provider
     * @type {'kiln' | 'figment'}
     * @memberof StakingBetaApiApproveTermsOfServiceByProviderId
     */
    readonly providerId: ApproveTermsOfServiceByProviderIdProviderIdEnum

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof StakingBetaApiApproveTermsOfServiceByProviderId
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for executeAction operation in StakingBetaApi.
 * @export
 * @interface StakingBetaApiExecuteActionRequest
 */
export interface StakingBetaApiExecuteActionRequest {
    /**
     * 
     * @type {ExecuteActionRequest}
     * @memberof StakingBetaApiExecuteAction
     */
    readonly executeActionRequest: ExecuteActionRequest

    /**
     * The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;) to use
     * @type {'ETH' | 'SOL' | 'ETH_TEST3' | 'SOL_TEST'}
     * @memberof StakingBetaApiExecuteAction
     */
    readonly chainDescriptor: ExecuteActionChainDescriptorEnum

    /**
     * The operation that can be executed on a vault/position
     * @type {'stake' | 'unstake' | 'withdraw'}
     * @memberof StakingBetaApiExecuteAction
     */
    readonly actionId: ExecuteActionActionIdEnum

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof StakingBetaApiExecuteAction
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for getAllDelegations operation in StakingBetaApi.
 * @export
 * @interface StakingBetaApiGetAllDelegationsRequest
 */
export interface StakingBetaApiGetAllDelegationsRequest {
    /**
     * Use \&quot;ETH\&quot; / \&quot;SOL\&quot; in order to obtain information related to the specific blockchain network or retrieve information about all chains that have data available by providing no argument.
     * @type {string}
     * @memberof StakingBetaApiGetAllDelegations
     */
    readonly chainDescriptor?: string
}

/**
 * Request parameters for getChainInfo operation in StakingBetaApi.
 * @export
 * @interface StakingBetaApiGetChainInfoRequest
 */
export interface StakingBetaApiGetChainInfoRequest {
    /**
     * The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;) to use
     * @type {'ETH' | 'SOL' | 'ETH_TEST3' | 'SOL_TEST'}
     * @memberof StakingBetaApiGetChainInfo
     */
    readonly chainDescriptor: GetChainInfoChainDescriptorEnum
}

/**
 * Request parameters for getDelegationById operation in StakingBetaApi.
 * @export
 * @interface StakingBetaApiGetDelegationByIdRequest
 */
export interface StakingBetaApiGetDelegationByIdRequest {
    /**
     * The unique identifier of the staking position
     * @type {string}
     * @memberof StakingBetaApiGetDelegationById
     */
    readonly id: string
}

/**
 * StakingBetaApi - object-oriented interface
 * @export
 * @class StakingBetaApi
 * @extends {BaseAPI}
 */
export class StakingBetaApi extends BaseAPI {
    /**
     * Approve the terms of service of the staking provider. This must be called before performing a staking action for the first time with this provider.
     * @summary 
     * @param {StakingBetaApiApproveTermsOfServiceByProviderIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingBetaApi
     */
    public approveTermsOfServiceByProviderId(requestParameters: StakingBetaApiApproveTermsOfServiceByProviderIdRequest) {
        return StakingBetaApiFp(this.configuration).approveTermsOfServiceByProviderId(requestParameters.providerId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Perform a chain-specific staking action (e.g. stake, unstake, withdraw).
     * @summary 
     * @param {StakingBetaApiExecuteActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingBetaApi
     */
    public executeAction(requestParameters: StakingBetaApiExecuteActionRequest) {
        return StakingBetaApiFp(this.configuration).executeAction(requestParameters.executeActionRequest, requestParameters.chainDescriptor, requestParameters.actionId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return detailed information on all staking positions, including the staked amount, rewards, status and more.
     * @summary 
     * @param {StakingBetaApiGetAllDelegationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingBetaApi
     */
    public getAllDelegations(requestParameters: StakingBetaApiGetAllDelegationsRequest = {}) {
        return StakingBetaApiFp(this.configuration).getAllDelegations(requestParameters.chainDescriptor).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return chain-specific, staking-related information summary (e.g. epoch details, lockup durations, estimated rewards, etc.)
     * @summary 
     * @param {StakingBetaApiGetChainInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingBetaApi
     */
    public getChainInfo(requestParameters: StakingBetaApiGetChainInfoRequest) {
        return StakingBetaApiFp(this.configuration).getChainInfo(requestParameters.chainDescriptor).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return an alphabetical list of supported chains.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingBetaApi
     */
    public getChains() {
        return StakingBetaApiFp(this.configuration).getChains().then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return detailed information on a staking position, including the staked amount, rewards, status and more.
     * @summary 
     * @param {StakingBetaApiGetDelegationByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingBetaApi
     */
    public getDelegationById(requestParameters: StakingBetaApiGetDelegationByIdRequest) {
        return StakingBetaApiFp(this.configuration).getDelegationById(requestParameters.id).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return information on all the available staking providers.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingBetaApi
     */
    public getProviders() {
        return StakingBetaApiFp(this.configuration).getProviders().then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return a summary of all vaults, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingBetaApi
     */
    public getSummary() {
        return StakingBetaApiFp(this.configuration).getSummary().then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return a summary for each vault, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingBetaApi
     */
    public getSummaryByVault() {
        return StakingBetaApiFp(this.configuration).getSummaryByVault().then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }
}

/**
 * @export
 */
export const ApproveTermsOfServiceByProviderIdProviderIdEnum = {
    Kiln: 'kiln',
    Figment: 'figment'
} as const;
export type ApproveTermsOfServiceByProviderIdProviderIdEnum = typeof ApproveTermsOfServiceByProviderIdProviderIdEnum[keyof typeof ApproveTermsOfServiceByProviderIdProviderIdEnum];
/**
 * @export
 */
export const ExecuteActionChainDescriptorEnum = {
    Eth: 'ETH',
    Sol: 'SOL',
    EthTest3: 'ETH_TEST3',
    SolTest: 'SOL_TEST'
} as const;
export type ExecuteActionChainDescriptorEnum = typeof ExecuteActionChainDescriptorEnum[keyof typeof ExecuteActionChainDescriptorEnum];
/**
 * @export
 */
export const ExecuteActionActionIdEnum = {
    Stake: 'stake',
    Unstake: 'unstake',
    Withdraw: 'withdraw'
} as const;
export type ExecuteActionActionIdEnum = typeof ExecuteActionActionIdEnum[keyof typeof ExecuteActionActionIdEnum];
/**
 * @export
 */
export const GetChainInfoChainDescriptorEnum = {
    Eth: 'ETH',
    Sol: 'SOL',
    EthTest3: 'ETH_TEST3',
    SolTest: 'SOL_TEST'
} as const;
export type GetChainInfoChainDescriptorEnum = typeof GetChainInfoChainDescriptorEnum[keyof typeof GetChainInfoChainDescriptorEnum];
