/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {AxiosInstance, AxiosPromise, AxiosRequestConfig} from 'axios';
import {Configuration} from "../configuration";
import {RequestOptions} from "../models/request-options";
import {HttpClient} from "../utils/http-client";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';


// Some imports not used depending on template conditions
// @ts-ignore
import { assertParamExists, setSearchParams, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';

// @ts-ignore
import { CancelTransactionResponse } from '../models';
// @ts-ignore
import { CreateTransactionResponse } from '../models';
// @ts-ignore
import { DropTransactionRequest } from '../models';
// @ts-ignore
import { DropTransactionResponse } from '../models';
// @ts-ignore
import { EstimatedNetworkFeeResponse } from '../models';
// @ts-ignore
import { EstimatedTransactionFeeResponse } from '../models';
// @ts-ignore
import { FreezeTransactionResponse } from '../models';
// @ts-ignore
import { SetConfirmationsThresholdRequest } from '../models';
// @ts-ignore
import { SetConfirmationsThresholdResponse } from '../models';
// @ts-ignore
import { TransactionRequest } from '../models';
// @ts-ignore
import { TransactionResponse } from '../models';
// @ts-ignore
import { UnfreezeTransactionResponse } from '../models';
// @ts-ignore
import { ValidateAddressResponse } from '../models';



    /**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration, requestOptions?:RequestOptions) {
    return {
        /**
         * Cancels a transaction by ID.
         * @summary Cancel a transaction
         * @param {string} txId The ID of the transaction to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransaction: async (txId: string,  requestOptions?: RequestOptions): Promise<AxiosRequestConfig> => {
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('cancelTransaction', 'txId', txId)
            const localVarPath = `/transactions/{txId}/cancel`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const idempotencyKey = requestOptions?.idempotencyKey;
            if (idempotencyKey) {
                localVarHeaderParameter["Idempotency-Key"] = idempotencyKey;
            }

            const ncwWalletId = requestOptions?.ncw?.walletId;
            if (ncwWalletId) {
                localVarHeaderParameter["X-End-User-Wallet-Id"] = ncwWalletId;
            }
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Creates a new transaction.
         * @summary Create a new transaction
         * @param {TransactionRequest} [transactionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction: async (transactionRequest?: TransactionRequest,  requestOptions?: RequestOptions): Promise<AxiosRequestConfig> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.data = transactionRequest as any;
            if (localVarRequestOptions.data?.source?.type === 'END_USER_WALLET' && !requestOptions?.ncw?.walletId) {
                const { walletId } = localVarRequestOptions.data?.source;
                requestOptions.ncw = { ...requestOptions.ncw, walletId };
            }
            const idempotencyKey = requestOptions?.idempotencyKey;
            if (idempotencyKey) {
                localVarHeaderParameter["Idempotency-Key"] = idempotencyKey;
            }

            const ncwWalletId = requestOptions?.ncw?.walletId;
            if (ncwWalletId) {
                localVarHeaderParameter["X-End-User-Wallet-Id"] = ncwWalletId;
            }
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Drops a stuck ETH transaction and creates a replacement transaction.
         * @summary Drop ETH transaction by ID
         * @param {string} txId The ID of the transaction
         * @param {DropTransactionRequest} [dropTransactionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropTransaction: async (txId: string, dropTransactionRequest?: DropTransactionRequest,  requestOptions?: RequestOptions): Promise<AxiosRequestConfig> => {
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('dropTransaction', 'txId', txId)
            const localVarPath = `/transactions/{txId}/drop`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.data = dropTransactionRequest as any;
            const idempotencyKey = requestOptions?.idempotencyKey;
            if (idempotencyKey) {
                localVarHeaderParameter["Idempotency-Key"] = idempotencyKey;
            }

            const ncwWalletId = requestOptions?.ncw?.walletId;
            if (ncwWalletId) {
                localVarHeaderParameter["X-End-User-Wallet-Id"] = ncwWalletId;
            }
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Gets the estimated required fee for an asset. For UTXO based assets, the response will contain the suggested fee per byte, for ETH/ETC based assets, the suggested gas price, and for XRP/XLM, the transaction fee.
         * @summary Estimate the required fee for an asset
         * @param {string} assetId The asset for which to estimate the fee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateNetworkFee: async (assetId: string,  requestOptions?: RequestOptions): Promise<AxiosRequestConfig> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('estimateNetworkFee', 'assetId', assetId)
            const localVarPath = `/estimate_network_fee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (assetId !== undefined) {
                localVarQueryParameter['assetId'] = assetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const idempotencyKey = requestOptions?.idempotencyKey;
            if (idempotencyKey) {
                localVarHeaderParameter["Idempotency-Key"] = idempotencyKey;
            }

            const ncwWalletId = requestOptions?.ncw?.walletId;
            if (ncwWalletId) {
                localVarHeaderParameter["X-End-User-Wallet-Id"] = ncwWalletId;
            }
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Estimates the transaction fee for a transaction request. * Note: Supports all Fireblocks assets except ZCash (ZEC).
         * @summary Estimate transaction fee
         * @param {TransactionRequest} [transactionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateTransactionFee: async (transactionRequest?: TransactionRequest,  requestOptions?: RequestOptions): Promise<AxiosRequestConfig> => {
            const localVarPath = `/transactions/estimate_fee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.data = transactionRequest as any;
            const idempotencyKey = requestOptions?.idempotencyKey;
            if (idempotencyKey) {
                localVarHeaderParameter["Idempotency-Key"] = idempotencyKey;
            }

            const ncwWalletId = requestOptions?.ncw?.walletId;
            if (ncwWalletId) {
                localVarHeaderParameter["X-End-User-Wallet-Id"] = ncwWalletId;
            }
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Freezes a transaction by ID.
         * @summary Freeze a transaction
         * @param {string} txId The ID of the transaction to freeze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        freezeTransaction: async (txId: string,  requestOptions?: RequestOptions): Promise<AxiosRequestConfig> => {
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('freezeTransaction', 'txId', txId)
            const localVarPath = `/transactions/{txId}/freeze`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const idempotencyKey = requestOptions?.idempotencyKey;
            if (idempotencyKey) {
                localVarHeaderParameter["Idempotency-Key"] = idempotencyKey;
            }

            const ncwWalletId = requestOptions?.ncw?.walletId;
            if (ncwWalletId) {
                localVarHeaderParameter["X-End-User-Wallet-Id"] = ncwWalletId;
            }
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns transaction by external transaction ID.
         * @summary Find a specific transaction by external transaction ID
         * @param {string} externalTxId The external ID of the transaction to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByExternalId: async (externalTxId: string,  requestOptions?: RequestOptions): Promise<AxiosRequestConfig> => {
            // verify required parameter 'externalTxId' is not null or undefined
            assertParamExists('getTransactionByExternalId', 'externalTxId', externalTxId)
            const localVarPath = `/transactions/external_tx_id/{externalTxId}/`
                .replace(`{${"externalTxId"}}`, encodeURIComponent(String(externalTxId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const idempotencyKey = requestOptions?.idempotencyKey;
            if (idempotencyKey) {
                localVarHeaderParameter["Idempotency-Key"] = idempotencyKey;
            }

            const ncwWalletId = requestOptions?.ncw?.walletId;
            if (ncwWalletId) {
                localVarHeaderParameter["X-End-User-Wallet-Id"] = ncwWalletId;
            }
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns a transaction by ID.
         * @summary Find a specific transaction by Fireblocks transaction ID
         * @param {string} txId The ID of the transaction to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById: async (txId: string,  requestOptions?: RequestOptions): Promise<AxiosRequestConfig> => {
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('getTransactionById', 'txId', txId)
            const localVarPath = `/transactions/{txId}`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const idempotencyKey = requestOptions?.idempotencyKey;
            if (idempotencyKey) {
                localVarHeaderParameter["Idempotency-Key"] = idempotencyKey;
            }

            const ncwWalletId = requestOptions?.ncw?.walletId;
            if (ncwWalletId) {
                localVarHeaderParameter["X-End-User-Wallet-Id"] = ncwWalletId;
            }
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Lists the transaction history for your workspace.
         * @summary List transaction history
         * @param {string} [before] Unix timestamp in milliseconds. Returns only transactions created before the specified date
         * @param {string} [after] Unix timestamp in milliseconds. Returns only transactions created after the specified date
         * @param {string} [status] You can filter by one of the statuses.
         * @param {'createdAt' | 'lastUpdated'} [orderBy] The field to order the results by  **Note**: Ordering by a field that is not createdAt may result with transactions that receive updates as you request the next or previous pages of results, resulting with missing those transactions.
         * @param {'ASC' | 'DESC'} [sort] The direction to order the results by
         * @param {number} [limit] Limits the number of results. If not provided, a limit of 200 will be used. The maximum allowed limit is 500
         * @param {'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'UNKNOWN' | 'GAS_STATION' | 'END_USER_WALLET'} [sourceType] The source type of the transaction
         * @param {string} [sourceId] The source ID of the transaction
         * @param {'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'ONE_TIME_ADDRESS' | 'END_USER_WALLET'} [destType] The destination type of the transaction
         * @param {string} [destId] The destination ID of the transaction
         * @param {string} [assets] A list of assets to filter by, seperated by commas
         * @param {string} [txHash] Returns only results with a specified txHash
         * @param {string} [sourceWalletId] Returns only results where the source is a specific end user wallet
         * @param {string} [destWalletId] Returns only results where the destination is a specific end user wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: async (before?: string, after?: string, status?: string, orderBy?: 'createdAt' | 'lastUpdated', sort?: 'ASC' | 'DESC', limit?: number, sourceType?: 'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'UNKNOWN' | 'GAS_STATION' | 'END_USER_WALLET', sourceId?: string, destType?: 'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'ONE_TIME_ADDRESS' | 'END_USER_WALLET', destId?: string, assets?: string, txHash?: string, sourceWalletId?: string, destWalletId?: string,  requestOptions?: RequestOptions): Promise<AxiosRequestConfig> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sourceType !== undefined) {
                localVarQueryParameter['sourceType'] = sourceType;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (destType !== undefined) {
                localVarQueryParameter['destType'] = destType;
            }

            if (destId !== undefined) {
                localVarQueryParameter['destId'] = destId;
            }

            if (assets !== undefined) {
                localVarQueryParameter['assets'] = assets;
            }

            if (txHash !== undefined) {
                localVarQueryParameter['txHash'] = txHash;
            }

            if (sourceWalletId !== undefined) {
                localVarQueryParameter['sourceWalletId'] = sourceWalletId;
            }

            if (destWalletId !== undefined) {
                localVarQueryParameter['destWalletId'] = destWalletId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const idempotencyKey = requestOptions?.idempotencyKey;
            if (idempotencyKey) {
                localVarHeaderParameter["Idempotency-Key"] = idempotencyKey;
            }

            const ncwWalletId = requestOptions?.ncw?.walletId;
            if (ncwWalletId) {
                localVarHeaderParameter["X-End-User-Wallet-Id"] = ncwWalletId;
            }
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Overrides the required number of confirmations for transaction completion by transaction ID.
         * @summary Set confirmation threshold by transaction ID
         * @param {string} txId The ID of the transaction
         * @param {SetConfirmationsThresholdRequest} [setConfirmationsThresholdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfirmationThresholdForTransaction: async (txId: string, setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest,  requestOptions?: RequestOptions): Promise<AxiosRequestConfig> => {
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('setConfirmationThresholdForTransaction', 'txId', txId)
            const localVarPath = `/transactions/{txId}/set_confirmation_threshold`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.data = setConfirmationsThresholdRequest as any;
            const idempotencyKey = requestOptions?.idempotencyKey;
            if (idempotencyKey) {
                localVarHeaderParameter["Idempotency-Key"] = idempotencyKey;
            }

            const ncwWalletId = requestOptions?.ncw?.walletId;
            if (ncwWalletId) {
                localVarHeaderParameter["X-End-User-Wallet-Id"] = ncwWalletId;
            }
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Overrides the required number of confirmations for transaction completion by transaction hash.
         * @summary Set confirmation threshold by transaction hash
         * @param {string} txHash The TxHash
         * @param {SetConfirmationsThresholdRequest} [setConfirmationsThresholdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfirmationThresholdForTransactionByHash: async (txHash: string, setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest,  requestOptions?: RequestOptions): Promise<AxiosRequestConfig> => {
            // verify required parameter 'txHash' is not null or undefined
            assertParamExists('setConfirmationThresholdForTransactionByHash', 'txHash', txHash)
            const localVarPath = `/txHash/{txHash}/set_confirmation_threshold`
                .replace(`{${"txHash"}}`, encodeURIComponent(String(txHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.data = setConfirmationsThresholdRequest as any;
            const idempotencyKey = requestOptions?.idempotencyKey;
            if (idempotencyKey) {
                localVarHeaderParameter["Idempotency-Key"] = idempotencyKey;
            }

            const ncwWalletId = requestOptions?.ncw?.walletId;
            if (ncwWalletId) {
                localVarHeaderParameter["X-End-User-Wallet-Id"] = ncwWalletId;
            }
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Unfreezes a transaction by ID and makes the transaction available again.
         * @summary Unfreeze a transaction
         * @param {string} txId The ID of the transaction to unfreeze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfreezeTransaction: async (txId: string,  requestOptions?: RequestOptions): Promise<AxiosRequestConfig> => {
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('unfreezeTransaction', 'txId', txId)
            const localVarPath = `/transactions/{txId}/unfreeze`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const idempotencyKey = requestOptions?.idempotencyKey;
            if (idempotencyKey) {
                localVarHeaderParameter["Idempotency-Key"] = idempotencyKey;
            }

            const ncwWalletId = requestOptions?.ncw?.walletId;
            if (ncwWalletId) {
                localVarHeaderParameter["X-End-User-Wallet-Id"] = ncwWalletId;
            }
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Checks if an address is valid (for XRP, DOT, XLM, and EOS).
         * @summary Validate destination address
         * @param {string} assetId The asset of the address
         * @param {string} address The address to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAddress: async (assetId: string, address: string,  requestOptions?: RequestOptions): Promise<AxiosRequestConfig> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('validateAddress', 'assetId', assetId)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('validateAddress', 'address', address)
            const localVarPath = `/transactions/validate_address/{assetId}/{address}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const idempotencyKey = requestOptions?.idempotencyKey;
            if (idempotencyKey) {
                localVarHeaderParameter["Idempotency-Key"] = idempotencyKey;
            }

            const ncwWalletId = requestOptions?.ncw?.walletId;
            if (ncwWalletId) {
                localVarHeaderParameter["X-End-User-Wallet-Id"] = ncwWalletId;
            }
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * Cancels a transaction by ID.
         * @summary Cancel a transaction
         * @param {string} txId The ID of the transaction to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTransaction(txId: string,  requestOptions?: RequestOptions): Promise<CancelTransactionResponse> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTransaction(txId, requestOptions);
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Creates a new transaction.
         * @summary Create a new transaction
         * @param {TransactionRequest} [transactionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransaction(transactionRequest?: TransactionRequest,  requestOptions?: RequestOptions): Promise<CreateTransactionResponse> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransaction(transactionRequest, requestOptions);
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Drops a stuck ETH transaction and creates a replacement transaction.
         * @summary Drop ETH transaction by ID
         * @param {string} txId The ID of the transaction
         * @param {DropTransactionRequest} [dropTransactionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropTransaction(txId: string, dropTransactionRequest?: DropTransactionRequest,  requestOptions?: RequestOptions): Promise<DropTransactionResponse> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropTransaction(txId, dropTransactionRequest, requestOptions);
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Gets the estimated required fee for an asset. For UTXO based assets, the response will contain the suggested fee per byte, for ETH/ETC based assets, the suggested gas price, and for XRP/XLM, the transaction fee.
         * @summary Estimate the required fee for an asset
         * @param {string} assetId The asset for which to estimate the fee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateNetworkFee(assetId: string,  requestOptions?: RequestOptions): Promise<EstimatedNetworkFeeResponse> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.estimateNetworkFee(assetId, requestOptions);
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Estimates the transaction fee for a transaction request. * Note: Supports all Fireblocks assets except ZCash (ZEC).
         * @summary Estimate transaction fee
         * @param {TransactionRequest} [transactionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateTransactionFee(transactionRequest?: TransactionRequest,  requestOptions?: RequestOptions): Promise<EstimatedTransactionFeeResponse> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.estimateTransactionFee(transactionRequest, requestOptions);
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Freezes a transaction by ID.
         * @summary Freeze a transaction
         * @param {string} txId The ID of the transaction to freeze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async freezeTransaction(txId: string,  requestOptions?: RequestOptions): Promise<FreezeTransactionResponse> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.freezeTransaction(txId, requestOptions);
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns transaction by external transaction ID.
         * @summary Find a specific transaction by external transaction ID
         * @param {string} externalTxId The external ID of the transaction to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionByExternalId(externalTxId: string,  requestOptions?: RequestOptions): Promise<TransactionResponse> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionByExternalId(externalTxId, requestOptions);
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns a transaction by ID.
         * @summary Find a specific transaction by Fireblocks transaction ID
         * @param {string} txId The ID of the transaction to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionById(txId: string,  requestOptions?: RequestOptions): Promise<TransactionResponse> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionById(txId, requestOptions);
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Lists the transaction history for your workspace.
         * @summary List transaction history
         * @param {string} [before] Unix timestamp in milliseconds. Returns only transactions created before the specified date
         * @param {string} [after] Unix timestamp in milliseconds. Returns only transactions created after the specified date
         * @param {string} [status] You can filter by one of the statuses.
         * @param {'createdAt' | 'lastUpdated'} [orderBy] The field to order the results by  **Note**: Ordering by a field that is not createdAt may result with transactions that receive updates as you request the next or previous pages of results, resulting with missing those transactions.
         * @param {'ASC' | 'DESC'} [sort] The direction to order the results by
         * @param {number} [limit] Limits the number of results. If not provided, a limit of 200 will be used. The maximum allowed limit is 500
         * @param {'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'UNKNOWN' | 'GAS_STATION' | 'END_USER_WALLET'} [sourceType] The source type of the transaction
         * @param {string} [sourceId] The source ID of the transaction
         * @param {'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'ONE_TIME_ADDRESS' | 'END_USER_WALLET'} [destType] The destination type of the transaction
         * @param {string} [destId] The destination ID of the transaction
         * @param {string} [assets] A list of assets to filter by, seperated by commas
         * @param {string} [txHash] Returns only results with a specified txHash
         * @param {string} [sourceWalletId] Returns only results where the source is a specific end user wallet
         * @param {string} [destWalletId] Returns only results where the destination is a specific end user wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactions(before?: string, after?: string, status?: string, orderBy?: 'createdAt' | 'lastUpdated', sort?: 'ASC' | 'DESC', limit?: number, sourceType?: 'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'UNKNOWN' | 'GAS_STATION' | 'END_USER_WALLET', sourceId?: string, destType?: 'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'ONE_TIME_ADDRESS' | 'END_USER_WALLET', destId?: string, assets?: string, txHash?: string, sourceWalletId?: string, destWalletId?: string,  requestOptions?: RequestOptions): Promise<Array<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(before, after, status, orderBy, sort, limit, sourceType, sourceId, destType, destId, assets, txHash, sourceWalletId, destWalletId, requestOptions);
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Overrides the required number of confirmations for transaction completion by transaction ID.
         * @summary Set confirmation threshold by transaction ID
         * @param {string} txId The ID of the transaction
         * @param {SetConfirmationsThresholdRequest} [setConfirmationsThresholdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setConfirmationThresholdForTransaction(txId: string, setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest,  requestOptions?: RequestOptions): Promise<SetConfirmationsThresholdResponse> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setConfirmationThresholdForTransaction(txId, setConfirmationsThresholdRequest, requestOptions);
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Overrides the required number of confirmations for transaction completion by transaction hash.
         * @summary Set confirmation threshold by transaction hash
         * @param {string} txHash The TxHash
         * @param {SetConfirmationsThresholdRequest} [setConfirmationsThresholdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setConfirmationThresholdForTransactionByHash(txHash: string, setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest,  requestOptions?: RequestOptions): Promise<SetConfirmationsThresholdResponse> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setConfirmationThresholdForTransactionByHash(txHash, setConfirmationsThresholdRequest, requestOptions);
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Unfreezes a transaction by ID and makes the transaction available again.
         * @summary Unfreeze a transaction
         * @param {string} txId The ID of the transaction to unfreeze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfreezeTransaction(txId: string,  requestOptions?: RequestOptions): Promise<UnfreezeTransactionResponse> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfreezeTransaction(txId, requestOptions);
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Checks if an address is valid (for XRP, DOT, XLM, and EOS).
         * @summary Validate destination address
         * @param {string} assetId The asset of the address
         * @param {string} address The address to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateAddress(assetId: string, address: string,  requestOptions?: RequestOptions): Promise<ValidateAddressResponse> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateAddress(assetId, address, requestOptions);
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for cancelTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiCancelTransactionRequest
 */
export interface TransactionsApiCancelTransactionRequest {
    /**
     * The ID of the transaction to cancel
     * @type {string}
     * @memberof TransactionsApiCancelTransaction
     */
    readonly txId: string
}

/**
 * Request parameters for createTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiCreateTransactionRequest
 */
export interface TransactionsApiCreateTransactionRequest {
    /**
     * 
     * @type {TransactionRequest}
     * @memberof TransactionsApiCreateTransaction
     */
    readonly transactionRequest?: TransactionRequest
}

/**
 * Request parameters for dropTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiDropTransactionRequest
 */
export interface TransactionsApiDropTransactionRequest {
    /**
     * The ID of the transaction
     * @type {string}
     * @memberof TransactionsApiDropTransaction
     */
    readonly txId: string

    /**
     * 
     * @type {DropTransactionRequest}
     * @memberof TransactionsApiDropTransaction
     */
    readonly dropTransactionRequest?: DropTransactionRequest
}

/**
 * Request parameters for estimateNetworkFee operation in TransactionsApi.
 * @export
 * @interface TransactionsApiEstimateNetworkFeeRequest
 */
export interface TransactionsApiEstimateNetworkFeeRequest {
    /**
     * The asset for which to estimate the fee
     * @type {string}
     * @memberof TransactionsApiEstimateNetworkFee
     */
    readonly assetId: string
}

/**
 * Request parameters for estimateTransactionFee operation in TransactionsApi.
 * @export
 * @interface TransactionsApiEstimateTransactionFeeRequest
 */
export interface TransactionsApiEstimateTransactionFeeRequest {
    /**
     * 
     * @type {TransactionRequest}
     * @memberof TransactionsApiEstimateTransactionFee
     */
    readonly transactionRequest?: TransactionRequest
}

/**
 * Request parameters for freezeTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiFreezeTransactionRequest
 */
export interface TransactionsApiFreezeTransactionRequest {
    /**
     * The ID of the transaction to freeze
     * @type {string}
     * @memberof TransactionsApiFreezeTransaction
     */
    readonly txId: string
}

/**
 * Request parameters for getTransactionByExternalId operation in TransactionsApi.
 * @export
 * @interface TransactionsApiGetTransactionByExternalIdRequest
 */
export interface TransactionsApiGetTransactionByExternalIdRequest {
    /**
     * The external ID of the transaction to return
     * @type {string}
     * @memberof TransactionsApiGetTransactionByExternalId
     */
    readonly externalTxId: string
}

/**
 * Request parameters for getTransactionById operation in TransactionsApi.
 * @export
 * @interface TransactionsApiGetTransactionByIdRequest
 */
export interface TransactionsApiGetTransactionByIdRequest {
    /**
     * The ID of the transaction to return
     * @type {string}
     * @memberof TransactionsApiGetTransactionById
     */
    readonly txId: string
}

/**
 * Request parameters for getTransactions operation in TransactionsApi.
 * @export
 * @interface TransactionsApiGetTransactionsRequest
 */
export interface TransactionsApiGetTransactionsRequest {
    /**
     * Unix timestamp in milliseconds. Returns only transactions created before the specified date
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly before?: string

    /**
     * Unix timestamp in milliseconds. Returns only transactions created after the specified date
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly after?: string

    /**
     * You can filter by one of the statuses.
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly status?: string

    /**
     * The field to order the results by  **Note**: Ordering by a field that is not createdAt may result with transactions that receive updates as you request the next or previous pages of results, resulting with missing those transactions.
     * @type {'createdAt' | 'lastUpdated'}
     * @memberof TransactionsApiGetTransactions
     */
    readonly orderBy?: 'createdAt' | 'lastUpdated'

    /**
     * The direction to order the results by
     * @type {'ASC' | 'DESC'}
     * @memberof TransactionsApiGetTransactions
     */
    readonly sort?: 'ASC' | 'DESC'

    /**
     * Limits the number of results. If not provided, a limit of 200 will be used. The maximum allowed limit is 500
     * @type {number}
     * @memberof TransactionsApiGetTransactions
     */
    readonly limit?: number

    /**
     * The source type of the transaction
     * @type {'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'UNKNOWN' | 'GAS_STATION' | 'END_USER_WALLET'}
     * @memberof TransactionsApiGetTransactions
     */
    readonly sourceType?: 'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'UNKNOWN' | 'GAS_STATION' | 'END_USER_WALLET'

    /**
     * The source ID of the transaction
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly sourceId?: string

    /**
     * The destination type of the transaction
     * @type {'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'ONE_TIME_ADDRESS' | 'END_USER_WALLET'}
     * @memberof TransactionsApiGetTransactions
     */
    readonly destType?: 'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'ONE_TIME_ADDRESS' | 'END_USER_WALLET'

    /**
     * The destination ID of the transaction
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly destId?: string

    /**
     * A list of assets to filter by, seperated by commas
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly assets?: string

    /**
     * Returns only results with a specified txHash
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly txHash?: string

    /**
     * Returns only results where the source is a specific end user wallet
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly sourceWalletId?: string

    /**
     * Returns only results where the destination is a specific end user wallet
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly destWalletId?: string
}

/**
 * Request parameters for setConfirmationThresholdForTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiSetConfirmationThresholdForTransactionRequest
 */
export interface TransactionsApiSetConfirmationThresholdForTransactionRequest {
    /**
     * The ID of the transaction
     * @type {string}
     * @memberof TransactionsApiSetConfirmationThresholdForTransaction
     */
    readonly txId: string

    /**
     * 
     * @type {SetConfirmationsThresholdRequest}
     * @memberof TransactionsApiSetConfirmationThresholdForTransaction
     */
    readonly setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest
}

/**
 * Request parameters for setConfirmationThresholdForTransactionByHash operation in TransactionsApi.
 * @export
 * @interface TransactionsApiSetConfirmationThresholdForTransactionByHashRequest
 */
export interface TransactionsApiSetConfirmationThresholdForTransactionByHashRequest {
    /**
     * The TxHash
     * @type {string}
     * @memberof TransactionsApiSetConfirmationThresholdForTransactionByHash
     */
    readonly txHash: string

    /**
     * 
     * @type {SetConfirmationsThresholdRequest}
     * @memberof TransactionsApiSetConfirmationThresholdForTransactionByHash
     */
    readonly setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest
}

/**
 * Request parameters for unfreezeTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiUnfreezeTransactionRequest
 */
export interface TransactionsApiUnfreezeTransactionRequest {
    /**
     * The ID of the transaction to unfreeze
     * @type {string}
     * @memberof TransactionsApiUnfreezeTransaction
     */
    readonly txId: string
}

/**
 * Request parameters for validateAddress operation in TransactionsApi.
 * @export
 * @interface TransactionsApiValidateAddressRequest
 */
export interface TransactionsApiValidateAddressRequest {
    /**
     * The asset of the address
     * @type {string}
     * @memberof TransactionsApiValidateAddress
     */
    readonly assetId: string

    /**
     * The address to validate
     * @type {string}
     * @memberof TransactionsApiValidateAddress
     */
    readonly address: string
}

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Cancels a transaction by ID.
     * @summary Cancel a transaction
     * @param {TransactionsApiCancelTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
     public cancelTransaction(requestParameters: TransactionsApiCancelTransactionRequest,  requestOptions?: RequestOptions) {
        return TransactionsApiFp(this.httpClient).cancelTransaction(requestParameters.txId, requestOptions);
    }

    /**
     * Creates a new transaction.
     * @summary Create a new transaction
     * @param {TransactionsApiCreateTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
     public createTransaction(requestParameters: TransactionsApiCreateTransactionRequest = {},  requestOptions?: RequestOptions) {
        return TransactionsApiFp(this.httpClient).createTransaction(requestParameters.transactionRequest, requestOptions);
    }

    /**
     * Drops a stuck ETH transaction and creates a replacement transaction.
     * @summary Drop ETH transaction by ID
     * @param {TransactionsApiDropTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
     public dropTransaction(requestParameters: TransactionsApiDropTransactionRequest,  requestOptions?: RequestOptions) {
        return TransactionsApiFp(this.httpClient).dropTransaction(requestParameters.txId, requestParameters.dropTransactionRequest, requestOptions);
    }

    /**
     * Gets the estimated required fee for an asset. For UTXO based assets, the response will contain the suggested fee per byte, for ETH/ETC based assets, the suggested gas price, and for XRP/XLM, the transaction fee.
     * @summary Estimate the required fee for an asset
     * @param {TransactionsApiEstimateNetworkFeeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
     public estimateNetworkFee(requestParameters: TransactionsApiEstimateNetworkFeeRequest,  requestOptions?: RequestOptions) {
        return TransactionsApiFp(this.httpClient).estimateNetworkFee(requestParameters.assetId, requestOptions);
    }

    /**
     * Estimates the transaction fee for a transaction request. * Note: Supports all Fireblocks assets except ZCash (ZEC).
     * @summary Estimate transaction fee
     * @param {TransactionsApiEstimateTransactionFeeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
     public estimateTransactionFee(requestParameters: TransactionsApiEstimateTransactionFeeRequest = {},  requestOptions?: RequestOptions) {
        return TransactionsApiFp(this.httpClient).estimateTransactionFee(requestParameters.transactionRequest, requestOptions);
    }

    /**
     * Freezes a transaction by ID.
     * @summary Freeze a transaction
     * @param {TransactionsApiFreezeTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
     public freezeTransaction(requestParameters: TransactionsApiFreezeTransactionRequest,  requestOptions?: RequestOptions) {
        return TransactionsApiFp(this.httpClient).freezeTransaction(requestParameters.txId, requestOptions);
    }

    /**
     * Returns transaction by external transaction ID.
     * @summary Find a specific transaction by external transaction ID
     * @param {TransactionsApiGetTransactionByExternalIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
     public getTransactionByExternalId(requestParameters: TransactionsApiGetTransactionByExternalIdRequest,  requestOptions?: RequestOptions) {
        return TransactionsApiFp(this.httpClient).getTransactionByExternalId(requestParameters.externalTxId, requestOptions);
    }

    /**
     * Returns a transaction by ID.
     * @summary Find a specific transaction by Fireblocks transaction ID
     * @param {TransactionsApiGetTransactionByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
     public getTransactionById(requestParameters: TransactionsApiGetTransactionByIdRequest,  requestOptions?: RequestOptions) {
        return TransactionsApiFp(this.httpClient).getTransactionById(requestParameters.txId, requestOptions);
    }

    /**
     * Lists the transaction history for your workspace.
     * @summary List transaction history
     * @param {TransactionsApiGetTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
     public getTransactions(requestParameters: TransactionsApiGetTransactionsRequest = {},  requestOptions?: RequestOptions) {
        return TransactionsApiFp(this.httpClient).getTransactions(requestParameters.before, requestParameters.after, requestParameters.status, requestParameters.orderBy, requestParameters.sort, requestParameters.limit, requestParameters.sourceType, requestParameters.sourceId, requestParameters.destType, requestParameters.destId, requestParameters.assets, requestParameters.txHash, requestParameters.sourceWalletId, requestParameters.destWalletId, requestOptions);
    }

    /**
     * Overrides the required number of confirmations for transaction completion by transaction ID.
     * @summary Set confirmation threshold by transaction ID
     * @param {TransactionsApiSetConfirmationThresholdForTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
     public setConfirmationThresholdForTransaction(requestParameters: TransactionsApiSetConfirmationThresholdForTransactionRequest,  requestOptions?: RequestOptions) {
        return TransactionsApiFp(this.httpClient).setConfirmationThresholdForTransaction(requestParameters.txId, requestParameters.setConfirmationsThresholdRequest, requestOptions);
    }

    /**
     * Overrides the required number of confirmations for transaction completion by transaction hash.
     * @summary Set confirmation threshold by transaction hash
     * @param {TransactionsApiSetConfirmationThresholdForTransactionByHashRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
     public setConfirmationThresholdForTransactionByHash(requestParameters: TransactionsApiSetConfirmationThresholdForTransactionByHashRequest,  requestOptions?: RequestOptions) {
        return TransactionsApiFp(this.httpClient).setConfirmationThresholdForTransactionByHash(requestParameters.txHash, requestParameters.setConfirmationsThresholdRequest, requestOptions);
    }

    /**
     * Unfreezes a transaction by ID and makes the transaction available again.
     * @summary Unfreeze a transaction
     * @param {TransactionsApiUnfreezeTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
     public unfreezeTransaction(requestParameters: TransactionsApiUnfreezeTransactionRequest,  requestOptions?: RequestOptions) {
        return TransactionsApiFp(this.httpClient).unfreezeTransaction(requestParameters.txId, requestOptions);
    }

    /**
     * Checks if an address is valid (for XRP, DOT, XLM, and EOS).
     * @summary Validate destination address
     * @param {TransactionsApiValidateAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
     public validateAddress(requestParameters: TransactionsApiValidateAddressRequest,  requestOptions?: RequestOptions) {
        return TransactionsApiFp(this.httpClient).validateAddress(requestParameters.assetId, requestParameters.address, requestOptions);
    }
}
