/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import { convertToFireblocksResponse } from "../response/fireblocksResponse";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import { assertParamExistsAndNotEmpty } from '../utils/validation_utils';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { CancelTransactionResponse } from '../models';
// @ts-ignore
import { CreateTransactionResponse } from '../models';
// @ts-ignore
import { DropTransactionRequest } from '../models';
// @ts-ignore
import { DropTransactionResponse } from '../models';
// @ts-ignore
import { ErrorSchema } from '../models';
// @ts-ignore
import { EstimatedNetworkFeeResponse } from '../models';
// @ts-ignore
import { EstimatedTransactionFeeResponse } from '../models';
// @ts-ignore
import { FreezeTransactionResponse } from '../models';
// @ts-ignore
import { GetTransactionsResponse } from '../models';
// @ts-ignore
import { RescanTransactionRequest } from '../models';
// @ts-ignore
import { SetConfirmationsThresholdRequest } from '../models';
// @ts-ignore
import { SetConfirmationsThresholdResponse } from '../models';
// @ts-ignore
import { TransactionRequest } from '../models';
// @ts-ignore
import { TransactionResponse } from '../models';
// @ts-ignore
import { UnfreezeTransactionResponse } from '../models';
// @ts-ignore
import { ValidateAddressResponse } from '../models';
// @ts-ignore
import { ValidatedTransactionsForRescanResponse } from '../models';
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels a transaction by ID.
         * @summary Cancel a transaction
         * @param {string} txId The ID of the transaction to cancel
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransaction: async (txId: string, xEndUserWalletId?: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('cancelTransaction', 'txId', txId)
            const localVarPath = `/transactions/{txId}/cancel`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xEndUserWalletId != null) {
                localVarHeaderParameter['X-End-User-Wallet-Id'] = String(xEndUserWalletId);
            }

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new transaction.
         * @summary Create a new transaction
         * @param {TransactionRequest} [transactionRequest] 
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction: async (transactionRequest?: TransactionRequest, xEndUserWalletId?: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xEndUserWalletId != null) {
                localVarHeaderParameter['X-End-User-Wallet-Id'] = String(xEndUserWalletId);
            }

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Drops a stuck ETH transaction and creates a replacement transaction.
         * @summary Drop ETH transaction by ID
         * @param {string} txId The ID of the transaction
         * @param {DropTransactionRequest} [dropTransactionRequest] 
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropTransaction: async (txId: string, dropTransactionRequest?: DropTransactionRequest, xEndUserWalletId?: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('dropTransaction', 'txId', txId)
            const localVarPath = `/transactions/{txId}/drop`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xEndUserWalletId != null) {
                localVarHeaderParameter['X-End-User-Wallet-Id'] = String(xEndUserWalletId);
            }

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dropTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the estimated required fee for an asset. For UTXO based assets, the response will contain the suggested fee per byte, for ETH/ETC based assets, the suggested gas price, and for XRP/XLM, the transaction fee.
         * @summary Estimate the required fee for an asset
         * @param {string} assetId The asset for which to estimate the fee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateNetworkFee: async (assetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('estimateNetworkFee', 'assetId', assetId)
            const localVarPath = `/estimate_network_fee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (assetId !== undefined) {
                localVarQueryParameter['assetId'] = assetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Estimates the transaction fee for a transaction request. * Note: Supports all Fireblocks assets except ZCash (ZEC).
         * @summary Estimate transaction fee
         * @param {TransactionRequest} [transactionRequest] 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateTransactionFee: async (transactionRequest?: TransactionRequest, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/estimate_fee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Freezes a transaction by ID.
         * @summary Freeze a transaction
         * @param {string} txId The ID of the transaction to freeze
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        freezeTransaction: async (txId: string, xEndUserWalletId?: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('freezeTransaction', 'txId', txId)
            const localVarPath = `/transactions/{txId}/freeze`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xEndUserWalletId != null) {
                localVarHeaderParameter['X-End-User-Wallet-Id'] = String(xEndUserWalletId);
            }

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a transaction by ID.
         * @summary Find a specific transaction by Fireblocks transaction ID
         * @param {string} txId The ID of the transaction to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction: async (txId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getTransaction', 'txId', txId)
            const localVarPath = `/transactions/{txId}`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns transaction by external transaction ID.
         * @summary Find a specific transaction by external transaction ID
         * @param {string} externalTxId The external ID of the transaction to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByExternalId: async (externalTxId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getTransactionByExternalId', 'externalTxId', externalTxId)
            const localVarPath = `/transactions/external_tx_id/{externalTxId}`
                .replace(`{${"externalTxId"}}`, encodeURIComponent(String(externalTxId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the transaction history for your workspace.
         * @summary List transaction history
         * @param {string} [before] Unix timestamp in milliseconds. Returns only transactions created before the specified date
         * @param {string} [after] Unix timestamp in milliseconds. Returns only transactions created after the specified date
         * @param {string} [status] You can filter by one of the statuses.
         * @param {GetTransactionsOrderByEnum} [orderBy] The field to order the results by  **Note**: Ordering by a field that is not createdAt may result with transactions that receive updates as you request the next or previous pages of results, resulting with missing those transactions.
         * @param {GetTransactionsSortEnum} [sort] The direction to order the results by
         * @param {number} [limit] Limits the number of results. If not provided, a limit of 200 will be used. The maximum allowed limit is 500
         * @param {GetTransactionsSourceTypeEnum} [sourceType] The source type of the transaction
         * @param {string} [sourceId] The source ID of the transaction
         * @param {GetTransactionsDestTypeEnum} [destType] The destination type of the transaction
         * @param {string} [destId] The destination ID of the transaction
         * @param {string} [assets] A list of assets to filter by, seperated by commas
         * @param {string} [txHash] Returns only results with a specified txHash
         * @param {string} [sourceWalletId] Returns only results where the source is a specific end user wallet
         * @param {string} [destWalletId] Returns only results where the destination is a specific end user wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: async (before?: string, after?: string, status?: string, orderBy?: GetTransactionsOrderByEnum, sort?: GetTransactionsSortEnum, limit?: number, sourceType?: GetTransactionsSourceTypeEnum, sourceId?: string, destType?: GetTransactionsDestTypeEnum, destId?: string, assets?: string, txHash?: string, sourceWalletId?: string, destWalletId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sourceType !== undefined) {
                localVarQueryParameter['sourceType'] = sourceType;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (destType !== undefined) {
                localVarQueryParameter['destType'] = destType;
            }

            if (destId !== undefined) {
                localVarQueryParameter['destId'] = destId;
            }

            if (assets !== undefined) {
                localVarQueryParameter['assets'] = assets;
            }

            if (txHash !== undefined) {
                localVarQueryParameter['txHash'] = txHash;
            }

            if (sourceWalletId !== undefined) {
                localVarQueryParameter['sourceWalletId'] = sourceWalletId;
            }

            if (destWalletId !== undefined) {
                localVarQueryParameter['destWalletId'] = destWalletId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * rescan transaction by running an async job. </br> **Note**: - These endpoints are currently in beta and might be subject to changes. - We limit the amount of the transaction to 16 per request. 
         * @summary rescan array of transactions
         * @param {RescanTransactionRequest} rescanTransactionRequest 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rescanTransactionsBeta: async (rescanTransactionRequest: RescanTransactionRequest, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('rescanTransactionsBeta', 'rescanTransactionRequest', rescanTransactionRequest)
            const localVarPath = `/transactions/rescan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rescanTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Overrides the required number of confirmations for transaction completion by transaction hash.
         * @summary Set confirmation threshold by transaction hash
         * @param {string} txHash The TxHash
         * @param {SetConfirmationsThresholdRequest} [setConfirmationsThresholdRequest] 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfirmationThresholdByTransactionHash: async (txHash: string, setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('setConfirmationThresholdByTransactionHash', 'txHash', txHash)
            const localVarPath = `/txHash/{txHash}/set_confirmation_threshold`
                .replace(`{${"txHash"}}`, encodeURIComponent(String(txHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setConfirmationsThresholdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Overrides the required number of confirmations for transaction completion by transaction ID.
         * @summary Set confirmation threshold by transaction ID
         * @param {string} txId The ID of the transaction
         * @param {SetConfirmationsThresholdRequest} [setConfirmationsThresholdRequest] 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTransactionConfirmationThreshold: async (txId: string, setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('setTransactionConfirmationThreshold', 'txId', txId)
            const localVarPath = `/transactions/{txId}/set_confirmation_threshold`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setConfirmationsThresholdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unfreezes a transaction by ID and makes the transaction available again.
         * @summary Unfreeze a transaction
         * @param {string} txId The ID of the transaction to unfreeze
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfreezeTransaction: async (txId: string, xEndUserWalletId?: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('unfreezeTransaction', 'txId', txId)
            const localVarPath = `/transactions/{txId}/unfreeze`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xEndUserWalletId != null) {
                localVarHeaderParameter['X-End-User-Wallet-Id'] = String(xEndUserWalletId);
            }

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if an address is valid (for XRP, DOT, XLM, and EOS).
         * @summary Validate destination address
         * @param {string} assetId The asset of the address
         * @param {string} address The address to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAddress: async (assetId: string, address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('validateAddress', 'assetId', assetId)
            assertParamExistsAndNotEmpty('validateAddress', 'address', address)
            const localVarPath = `/transactions/validate_address/{assetId}/{address}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancels a transaction by ID.
         * @summary Cancel a transaction
         * @param {string} txId The ID of the transaction to cancel
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTransaction(txId: string, xEndUserWalletId?: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTransaction(txId, xEndUserWalletId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.cancelTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates a new transaction.
         * @summary Create a new transaction
         * @param {TransactionRequest} [transactionRequest] 
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransaction(transactionRequest?: TransactionRequest, xEndUserWalletId?: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransaction(transactionRequest, xEndUserWalletId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.createTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Drops a stuck ETH transaction and creates a replacement transaction.
         * @summary Drop ETH transaction by ID
         * @param {string} txId The ID of the transaction
         * @param {DropTransactionRequest} [dropTransactionRequest] 
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropTransaction(txId: string, dropTransactionRequest?: DropTransactionRequest, xEndUserWalletId?: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DropTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropTransaction(txId, dropTransactionRequest, xEndUserWalletId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.dropTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Gets the estimated required fee for an asset. For UTXO based assets, the response will contain the suggested fee per byte, for ETH/ETC based assets, the suggested gas price, and for XRP/XLM, the transaction fee.
         * @summary Estimate the required fee for an asset
         * @param {string} assetId The asset for which to estimate the fee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateNetworkFee(assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimatedNetworkFeeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.estimateNetworkFee(assetId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.estimateNetworkFee']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Estimates the transaction fee for a transaction request. * Note: Supports all Fireblocks assets except ZCash (ZEC).
         * @summary Estimate transaction fee
         * @param {TransactionRequest} [transactionRequest] 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateTransactionFee(transactionRequest?: TransactionRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimatedTransactionFeeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.estimateTransactionFee(transactionRequest, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.estimateTransactionFee']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Freezes a transaction by ID.
         * @summary Freeze a transaction
         * @param {string} txId The ID of the transaction to freeze
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async freezeTransaction(txId: string, xEndUserWalletId?: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FreezeTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.freezeTransaction(txId, xEndUserWalletId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.freezeTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns a transaction by ID.
         * @summary Find a specific transaction by Fireblocks transaction ID
         * @param {string} txId The ID of the transaction to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransaction(txId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransaction(txId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.getTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns transaction by external transaction ID.
         * @summary Find a specific transaction by external transaction ID
         * @param {string} externalTxId The external ID of the transaction to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionByExternalId(externalTxId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionByExternalId(externalTxId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.getTransactionByExternalId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Lists the transaction history for your workspace.
         * @summary List transaction history
         * @param {string} [before] Unix timestamp in milliseconds. Returns only transactions created before the specified date
         * @param {string} [after] Unix timestamp in milliseconds. Returns only transactions created after the specified date
         * @param {string} [status] You can filter by one of the statuses.
         * @param {GetTransactionsOrderByEnum} [orderBy] The field to order the results by  **Note**: Ordering by a field that is not createdAt may result with transactions that receive updates as you request the next or previous pages of results, resulting with missing those transactions.
         * @param {GetTransactionsSortEnum} [sort] The direction to order the results by
         * @param {number} [limit] Limits the number of results. If not provided, a limit of 200 will be used. The maximum allowed limit is 500
         * @param {GetTransactionsSourceTypeEnum} [sourceType] The source type of the transaction
         * @param {string} [sourceId] The source ID of the transaction
         * @param {GetTransactionsDestTypeEnum} [destType] The destination type of the transaction
         * @param {string} [destId] The destination ID of the transaction
         * @param {string} [assets] A list of assets to filter by, seperated by commas
         * @param {string} [txHash] Returns only results with a specified txHash
         * @param {string} [sourceWalletId] Returns only results where the source is a specific end user wallet
         * @param {string} [destWalletId] Returns only results where the destination is a specific end user wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactions(before?: string, after?: string, status?: string, orderBy?: GetTransactionsOrderByEnum, sort?: GetTransactionsSortEnum, limit?: number, sourceType?: GetTransactionsSourceTypeEnum, sourceId?: string, destType?: GetTransactionsDestTypeEnum, destId?: string, assets?: string, txHash?: string, sourceWalletId?: string, destWalletId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(before, after, status, orderBy, sort, limit, sourceType, sourceId, destType, destId, assets, txHash, sourceWalletId, destWalletId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.getTransactions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * rescan transaction by running an async job. </br> **Note**: - These endpoints are currently in beta and might be subject to changes. - We limit the amount of the transaction to 16 per request. 
         * @summary rescan array of transactions
         * @param {RescanTransactionRequest} rescanTransactionRequest 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rescanTransactionsBeta(rescanTransactionRequest: RescanTransactionRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatedTransactionsForRescanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rescanTransactionsBeta(rescanTransactionRequest, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.rescanTransactionsBeta']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Overrides the required number of confirmations for transaction completion by transaction hash.
         * @summary Set confirmation threshold by transaction hash
         * @param {string} txHash The TxHash
         * @param {SetConfirmationsThresholdRequest} [setConfirmationsThresholdRequest] 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setConfirmationThresholdByTransactionHash(txHash: string, setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetConfirmationsThresholdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setConfirmationThresholdByTransactionHash(txHash, setConfirmationsThresholdRequest, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.setConfirmationThresholdByTransactionHash']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Overrides the required number of confirmations for transaction completion by transaction ID.
         * @summary Set confirmation threshold by transaction ID
         * @param {string} txId The ID of the transaction
         * @param {SetConfirmationsThresholdRequest} [setConfirmationsThresholdRequest] 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTransactionConfirmationThreshold(txId: string, setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetConfirmationsThresholdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTransactionConfirmationThreshold(txId, setConfirmationsThresholdRequest, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.setTransactionConfirmationThreshold']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Unfreezes a transaction by ID and makes the transaction available again.
         * @summary Unfreeze a transaction
         * @param {string} txId The ID of the transaction to unfreeze
         * @param {string} [xEndUserWalletId] Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfreezeTransaction(txId: string, xEndUserWalletId?: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnfreezeTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfreezeTransaction(txId, xEndUserWalletId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.unfreezeTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Checks if an address is valid (for XRP, DOT, XLM, and EOS).
         * @summary Validate destination address
         * @param {string} assetId The asset of the address
         * @param {string} address The address to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateAddress(assetId: string, address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateAddress(assetId, address, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TransactionsApi.validateAddress']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Cancels a transaction by ID.
         * @summary Cancel a transaction
         * @param {TransactionsApiCancelTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransaction(requestParameters: TransactionsApiCancelTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CancelTransactionResponse> {
            return localVarFp.cancelTransaction(requestParameters.txId, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new transaction.
         * @summary Create a new transaction
         * @param {TransactionsApiCreateTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(requestParameters: TransactionsApiCreateTransactionRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CreateTransactionResponse> {
            return localVarFp.createTransaction(requestParameters.transactionRequest, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Drops a stuck ETH transaction and creates a replacement transaction.
         * @summary Drop ETH transaction by ID
         * @param {TransactionsApiDropTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropTransaction(requestParameters: TransactionsApiDropTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DropTransactionResponse> {
            return localVarFp.dropTransaction(requestParameters.txId, requestParameters.dropTransactionRequest, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the estimated required fee for an asset. For UTXO based assets, the response will contain the suggested fee per byte, for ETH/ETC based assets, the suggested gas price, and for XRP/XLM, the transaction fee.
         * @summary Estimate the required fee for an asset
         * @param {TransactionsApiEstimateNetworkFeeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateNetworkFee(requestParameters: TransactionsApiEstimateNetworkFeeRequest, options?: RawAxiosRequestConfig): AxiosPromise<EstimatedNetworkFeeResponse> {
            return localVarFp.estimateNetworkFee(requestParameters.assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Estimates the transaction fee for a transaction request. * Note: Supports all Fireblocks assets except ZCash (ZEC).
         * @summary Estimate transaction fee
         * @param {TransactionsApiEstimateTransactionFeeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateTransactionFee(requestParameters: TransactionsApiEstimateTransactionFeeRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<EstimatedTransactionFeeResponse> {
            return localVarFp.estimateTransactionFee(requestParameters.transactionRequest, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Freezes a transaction by ID.
         * @summary Freeze a transaction
         * @param {TransactionsApiFreezeTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        freezeTransaction(requestParameters: TransactionsApiFreezeTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<FreezeTransactionResponse> {
            return localVarFp.freezeTransaction(requestParameters.txId, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a transaction by ID.
         * @summary Find a specific transaction by Fireblocks transaction ID
         * @param {TransactionsApiGetTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(requestParameters: TransactionsApiGetTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionResponse> {
            return localVarFp.getTransaction(requestParameters.txId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns transaction by external transaction ID.
         * @summary Find a specific transaction by external transaction ID
         * @param {TransactionsApiGetTransactionByExternalIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByExternalId(requestParameters: TransactionsApiGetTransactionByExternalIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionResponse> {
            return localVarFp.getTransactionByExternalId(requestParameters.externalTxId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the transaction history for your workspace.
         * @summary List transaction history
         * @param {TransactionsApiGetTransactionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(requestParameters: TransactionsApiGetTransactionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetTransactionsResponse> {
            return localVarFp.getTransactions(requestParameters.before, requestParameters.after, requestParameters.status, requestParameters.orderBy, requestParameters.sort, requestParameters.limit, requestParameters.sourceType, requestParameters.sourceId, requestParameters.destType, requestParameters.destId, requestParameters.assets, requestParameters.txHash, requestParameters.sourceWalletId, requestParameters.destWalletId, options).then((request) => request(axios, basePath));
        },
        /**
         * rescan transaction by running an async job. </br> **Note**: - These endpoints are currently in beta and might be subject to changes. - We limit the amount of the transaction to 16 per request. 
         * @summary rescan array of transactions
         * @param {TransactionsApiRescanTransactionsBetaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rescanTransactionsBeta(requestParameters: TransactionsApiRescanTransactionsBetaRequest, options?: RawAxiosRequestConfig): AxiosPromise<ValidatedTransactionsForRescanResponse> {
            return localVarFp.rescanTransactionsBeta(requestParameters.rescanTransactionRequest, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Overrides the required number of confirmations for transaction completion by transaction hash.
         * @summary Set confirmation threshold by transaction hash
         * @param {TransactionsApiSetConfirmationThresholdByTransactionHashRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfirmationThresholdByTransactionHash(requestParameters: TransactionsApiSetConfirmationThresholdByTransactionHashRequest, options?: RawAxiosRequestConfig): AxiosPromise<SetConfirmationsThresholdResponse> {
            return localVarFp.setConfirmationThresholdByTransactionHash(requestParameters.txHash, requestParameters.setConfirmationsThresholdRequest, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Overrides the required number of confirmations for transaction completion by transaction ID.
         * @summary Set confirmation threshold by transaction ID
         * @param {TransactionsApiSetTransactionConfirmationThresholdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTransactionConfirmationThreshold(requestParameters: TransactionsApiSetTransactionConfirmationThresholdRequest, options?: RawAxiosRequestConfig): AxiosPromise<SetConfirmationsThresholdResponse> {
            return localVarFp.setTransactionConfirmationThreshold(requestParameters.txId, requestParameters.setConfirmationsThresholdRequest, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Unfreezes a transaction by ID and makes the transaction available again.
         * @summary Unfreeze a transaction
         * @param {TransactionsApiUnfreezeTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfreezeTransaction(requestParameters: TransactionsApiUnfreezeTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<UnfreezeTransactionResponse> {
            return localVarFp.unfreezeTransaction(requestParameters.txId, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if an address is valid (for XRP, DOT, XLM, and EOS).
         * @summary Validate destination address
         * @param {TransactionsApiValidateAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAddress(requestParameters: TransactionsApiValidateAddressRequest, options?: RawAxiosRequestConfig): AxiosPromise<ValidateAddressResponse> {
            return localVarFp.validateAddress(requestParameters.assetId, requestParameters.address, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiCancelTransactionRequest
 */
export interface TransactionsApiCancelTransactionRequest {
    /**
     * The ID of the transaction to cancel
     * @type {string}
     * @memberof TransactionsApiCancelTransaction
     */
    readonly txId: string

    /**
     * Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
     * @type {string}
     * @memberof TransactionsApiCancelTransaction
     */
    readonly xEndUserWalletId?: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof TransactionsApiCancelTransaction
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for createTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiCreateTransactionRequest
 */
export interface TransactionsApiCreateTransactionRequest {
    /**
     * 
     * @type {TransactionRequest}
     * @memberof TransactionsApiCreateTransaction
     */
    readonly transactionRequest?: TransactionRequest

    /**
     * Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
     * @type {string}
     * @memberof TransactionsApiCreateTransaction
     */
    readonly xEndUserWalletId?: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof TransactionsApiCreateTransaction
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for dropTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiDropTransactionRequest
 */
export interface TransactionsApiDropTransactionRequest {
    /**
     * The ID of the transaction
     * @type {string}
     * @memberof TransactionsApiDropTransaction
     */
    readonly txId: string

    /**
     * 
     * @type {DropTransactionRequest}
     * @memberof TransactionsApiDropTransaction
     */
    readonly dropTransactionRequest?: DropTransactionRequest

    /**
     * Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
     * @type {string}
     * @memberof TransactionsApiDropTransaction
     */
    readonly xEndUserWalletId?: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof TransactionsApiDropTransaction
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for estimateNetworkFee operation in TransactionsApi.
 * @export
 * @interface TransactionsApiEstimateNetworkFeeRequest
 */
export interface TransactionsApiEstimateNetworkFeeRequest {
    /**
     * The asset for which to estimate the fee
     * @type {string}
     * @memberof TransactionsApiEstimateNetworkFee
     */
    readonly assetId: string
}

/**
 * Request parameters for estimateTransactionFee operation in TransactionsApi.
 * @export
 * @interface TransactionsApiEstimateTransactionFeeRequest
 */
export interface TransactionsApiEstimateTransactionFeeRequest {
    /**
     * 
     * @type {TransactionRequest}
     * @memberof TransactionsApiEstimateTransactionFee
     */
    readonly transactionRequest?: TransactionRequest

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof TransactionsApiEstimateTransactionFee
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for freezeTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiFreezeTransactionRequest
 */
export interface TransactionsApiFreezeTransactionRequest {
    /**
     * The ID of the transaction to freeze
     * @type {string}
     * @memberof TransactionsApiFreezeTransaction
     */
    readonly txId: string

    /**
     * Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
     * @type {string}
     * @memberof TransactionsApiFreezeTransaction
     */
    readonly xEndUserWalletId?: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof TransactionsApiFreezeTransaction
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for getTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiGetTransactionRequest
 */
export interface TransactionsApiGetTransactionRequest {
    /**
     * The ID of the transaction to return
     * @type {string}
     * @memberof TransactionsApiGetTransaction
     */
    readonly txId: string
}

/**
 * Request parameters for getTransactionByExternalId operation in TransactionsApi.
 * @export
 * @interface TransactionsApiGetTransactionByExternalIdRequest
 */
export interface TransactionsApiGetTransactionByExternalIdRequest {
    /**
     * The external ID of the transaction to return
     * @type {string}
     * @memberof TransactionsApiGetTransactionByExternalId
     */
    readonly externalTxId: string
}

/**
 * Request parameters for getTransactions operation in TransactionsApi.
 * @export
 * @interface TransactionsApiGetTransactionsRequest
 */
export interface TransactionsApiGetTransactionsRequest {
    /**
     * Unix timestamp in milliseconds. Returns only transactions created before the specified date
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly before?: string

    /**
     * Unix timestamp in milliseconds. Returns only transactions created after the specified date
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly after?: string

    /**
     * You can filter by one of the statuses.
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly status?: string

    /**
     * The field to order the results by  **Note**: Ordering by a field that is not createdAt may result with transactions that receive updates as you request the next or previous pages of results, resulting with missing those transactions.
     * @type {'createdAt' | 'lastUpdated'}
     * @memberof TransactionsApiGetTransactions
     */
    readonly orderBy?: GetTransactionsOrderByEnum

    /**
     * The direction to order the results by
     * @type {'ASC' | 'DESC'}
     * @memberof TransactionsApiGetTransactions
     */
    readonly sort?: GetTransactionsSortEnum

    /**
     * Limits the number of results. If not provided, a limit of 200 will be used. The maximum allowed limit is 500
     * @type {number}
     * @memberof TransactionsApiGetTransactions
     */
    readonly limit?: number

    /**
     * The source type of the transaction
     * @type {'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'CONTRACT' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'UNKNOWN' | 'GAS_STATION' | 'END_USER_WALLET'}
     * @memberof TransactionsApiGetTransactions
     */
    readonly sourceType?: GetTransactionsSourceTypeEnum

    /**
     * The source ID of the transaction
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly sourceId?: string

    /**
     * The destination type of the transaction
     * @type {'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'CONTRACT' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'ONE_TIME_ADDRESS' | 'END_USER_WALLET'}
     * @memberof TransactionsApiGetTransactions
     */
    readonly destType?: GetTransactionsDestTypeEnum

    /**
     * The destination ID of the transaction
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly destId?: string

    /**
     * A list of assets to filter by, seperated by commas
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly assets?: string

    /**
     * Returns only results with a specified txHash
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly txHash?: string

    /**
     * Returns only results where the source is a specific end user wallet
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly sourceWalletId?: string

    /**
     * Returns only results where the destination is a specific end user wallet
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly destWalletId?: string
}

/**
 * Request parameters for rescanTransactionsBeta operation in TransactionsApi.
 * @export
 * @interface TransactionsApiRescanTransactionsBetaRequest
 */
export interface TransactionsApiRescanTransactionsBetaRequest {
    /**
     * 
     * @type {RescanTransactionRequest}
     * @memberof TransactionsApiRescanTransactionsBeta
     */
    readonly rescanTransactionRequest: RescanTransactionRequest

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof TransactionsApiRescanTransactionsBeta
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for setConfirmationThresholdByTransactionHash operation in TransactionsApi.
 * @export
 * @interface TransactionsApiSetConfirmationThresholdByTransactionHashRequest
 */
export interface TransactionsApiSetConfirmationThresholdByTransactionHashRequest {
    /**
     * The TxHash
     * @type {string}
     * @memberof TransactionsApiSetConfirmationThresholdByTransactionHash
     */
    readonly txHash: string

    /**
     * 
     * @type {SetConfirmationsThresholdRequest}
     * @memberof TransactionsApiSetConfirmationThresholdByTransactionHash
     */
    readonly setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof TransactionsApiSetConfirmationThresholdByTransactionHash
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for setTransactionConfirmationThreshold operation in TransactionsApi.
 * @export
 * @interface TransactionsApiSetTransactionConfirmationThresholdRequest
 */
export interface TransactionsApiSetTransactionConfirmationThresholdRequest {
    /**
     * The ID of the transaction
     * @type {string}
     * @memberof TransactionsApiSetTransactionConfirmationThreshold
     */
    readonly txId: string

    /**
     * 
     * @type {SetConfirmationsThresholdRequest}
     * @memberof TransactionsApiSetTransactionConfirmationThreshold
     */
    readonly setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof TransactionsApiSetTransactionConfirmationThreshold
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for unfreezeTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiUnfreezeTransactionRequest
 */
export interface TransactionsApiUnfreezeTransactionRequest {
    /**
     * The ID of the transaction to unfreeze
     * @type {string}
     * @memberof TransactionsApiUnfreezeTransaction
     */
    readonly txId: string

    /**
     * Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
     * @type {string}
     * @memberof TransactionsApiUnfreezeTransaction
     */
    readonly xEndUserWalletId?: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof TransactionsApiUnfreezeTransaction
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for validateAddress operation in TransactionsApi.
 * @export
 * @interface TransactionsApiValidateAddressRequest
 */
export interface TransactionsApiValidateAddressRequest {
    /**
     * The asset of the address
     * @type {string}
     * @memberof TransactionsApiValidateAddress
     */
    readonly assetId: string

    /**
     * The address to validate
     * @type {string}
     * @memberof TransactionsApiValidateAddress
     */
    readonly address: string
}

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Cancels a transaction by ID.
     * @summary Cancel a transaction
     * @param {TransactionsApiCancelTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public cancelTransaction(requestParameters: TransactionsApiCancelTransactionRequest) {
        return TransactionsApiFp(this.configuration).cancelTransaction(requestParameters.txId, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Creates a new transaction.
     * @summary Create a new transaction
     * @param {TransactionsApiCreateTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createTransaction(requestParameters: TransactionsApiCreateTransactionRequest = {}) {
        return TransactionsApiFp(this.configuration).createTransaction(requestParameters.transactionRequest, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Drops a stuck ETH transaction and creates a replacement transaction.
     * @summary Drop ETH transaction by ID
     * @param {TransactionsApiDropTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public dropTransaction(requestParameters: TransactionsApiDropTransactionRequest) {
        return TransactionsApiFp(this.configuration).dropTransaction(requestParameters.txId, requestParameters.dropTransactionRequest, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Gets the estimated required fee for an asset. For UTXO based assets, the response will contain the suggested fee per byte, for ETH/ETC based assets, the suggested gas price, and for XRP/XLM, the transaction fee.
     * @summary Estimate the required fee for an asset
     * @param {TransactionsApiEstimateNetworkFeeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public estimateNetworkFee(requestParameters: TransactionsApiEstimateNetworkFeeRequest) {
        return TransactionsApiFp(this.configuration).estimateNetworkFee(requestParameters.assetId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Estimates the transaction fee for a transaction request. * Note: Supports all Fireblocks assets except ZCash (ZEC).
     * @summary Estimate transaction fee
     * @param {TransactionsApiEstimateTransactionFeeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public estimateTransactionFee(requestParameters: TransactionsApiEstimateTransactionFeeRequest = {}) {
        return TransactionsApiFp(this.configuration).estimateTransactionFee(requestParameters.transactionRequest, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Freezes a transaction by ID.
     * @summary Freeze a transaction
     * @param {TransactionsApiFreezeTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public freezeTransaction(requestParameters: TransactionsApiFreezeTransactionRequest) {
        return TransactionsApiFp(this.configuration).freezeTransaction(requestParameters.txId, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns a transaction by ID.
     * @summary Find a specific transaction by Fireblocks transaction ID
     * @param {TransactionsApiGetTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransaction(requestParameters: TransactionsApiGetTransactionRequest) {
        return TransactionsApiFp(this.configuration).getTransaction(requestParameters.txId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Returns transaction by external transaction ID.
     * @summary Find a specific transaction by external transaction ID
     * @param {TransactionsApiGetTransactionByExternalIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionByExternalId(requestParameters: TransactionsApiGetTransactionByExternalIdRequest) {
        return TransactionsApiFp(this.configuration).getTransactionByExternalId(requestParameters.externalTxId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Lists the transaction history for your workspace.
     * @summary List transaction history
     * @param {TransactionsApiGetTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactions(requestParameters: TransactionsApiGetTransactionsRequest = {}) {
        return TransactionsApiFp(this.configuration).getTransactions(requestParameters.before, requestParameters.after, requestParameters.status, requestParameters.orderBy, requestParameters.sort, requestParameters.limit, requestParameters.sourceType, requestParameters.sourceId, requestParameters.destType, requestParameters.destId, requestParameters.assets, requestParameters.txHash, requestParameters.sourceWalletId, requestParameters.destWalletId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * rescan transaction by running an async job. </br> **Note**: - These endpoints are currently in beta and might be subject to changes. - We limit the amount of the transaction to 16 per request. 
     * @summary rescan array of transactions
     * @param {TransactionsApiRescanTransactionsBetaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public rescanTransactionsBeta(requestParameters: TransactionsApiRescanTransactionsBetaRequest) {
        return TransactionsApiFp(this.configuration).rescanTransactionsBeta(requestParameters.rescanTransactionRequest, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Overrides the required number of confirmations for transaction completion by transaction hash.
     * @summary Set confirmation threshold by transaction hash
     * @param {TransactionsApiSetConfirmationThresholdByTransactionHashRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public setConfirmationThresholdByTransactionHash(requestParameters: TransactionsApiSetConfirmationThresholdByTransactionHashRequest) {
        return TransactionsApiFp(this.configuration).setConfirmationThresholdByTransactionHash(requestParameters.txHash, requestParameters.setConfirmationsThresholdRequest, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Overrides the required number of confirmations for transaction completion by transaction ID.
     * @summary Set confirmation threshold by transaction ID
     * @param {TransactionsApiSetTransactionConfirmationThresholdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public setTransactionConfirmationThreshold(requestParameters: TransactionsApiSetTransactionConfirmationThresholdRequest) {
        return TransactionsApiFp(this.configuration).setTransactionConfirmationThreshold(requestParameters.txId, requestParameters.setConfirmationsThresholdRequest, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Unfreezes a transaction by ID and makes the transaction available again.
     * @summary Unfreeze a transaction
     * @param {TransactionsApiUnfreezeTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public unfreezeTransaction(requestParameters: TransactionsApiUnfreezeTransactionRequest) {
        return TransactionsApiFp(this.configuration).unfreezeTransaction(requestParameters.txId, requestParameters.xEndUserWalletId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Checks if an address is valid (for XRP, DOT, XLM, and EOS).
     * @summary Validate destination address
     * @param {TransactionsApiValidateAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public validateAddress(requestParameters: TransactionsApiValidateAddressRequest) {
        return TransactionsApiFp(this.configuration).validateAddress(requestParameters.assetId, requestParameters.address).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }
}

/**
 * @export
 */
export const GetTransactionsOrderByEnum = {
    CreatedAt: 'createdAt',
    LastUpdated: 'lastUpdated'
} as const;
export type GetTransactionsOrderByEnum = typeof GetTransactionsOrderByEnum[keyof typeof GetTransactionsOrderByEnum];
/**
 * @export
 */
export const GetTransactionsSortEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type GetTransactionsSortEnum = typeof GetTransactionsSortEnum[keyof typeof GetTransactionsSortEnum];
/**
 * @export
 */
export const GetTransactionsSourceTypeEnum = {
    VaultAccount: 'VAULT_ACCOUNT',
    ExchangeAccount: 'EXCHANGE_ACCOUNT',
    InternalWallet: 'INTERNAL_WALLET',
    ExternalWallet: 'EXTERNAL_WALLET',
    Contract: 'CONTRACT',
    FiatAccount: 'FIAT_ACCOUNT',
    NetworkConnection: 'NETWORK_CONNECTION',
    Compound: 'COMPOUND',
    Unknown: 'UNKNOWN',
    GasStation: 'GAS_STATION',
    EndUserWallet: 'END_USER_WALLET'
} as const;
export type GetTransactionsSourceTypeEnum = typeof GetTransactionsSourceTypeEnum[keyof typeof GetTransactionsSourceTypeEnum];
/**
 * @export
 */
export const GetTransactionsDestTypeEnum = {
    VaultAccount: 'VAULT_ACCOUNT',
    ExchangeAccount: 'EXCHANGE_ACCOUNT',
    InternalWallet: 'INTERNAL_WALLET',
    ExternalWallet: 'EXTERNAL_WALLET',
    Contract: 'CONTRACT',
    FiatAccount: 'FIAT_ACCOUNT',
    NetworkConnection: 'NETWORK_CONNECTION',
    Compound: 'COMPOUND',
    OneTimeAddress: 'ONE_TIME_ADDRESS',
    EndUserWallet: 'END_USER_WALLET'
} as const;
export type GetTransactionsDestTypeEnum = typeof GetTransactionsDestTypeEnum[keyof typeof GetTransactionsDestTypeEnum];
