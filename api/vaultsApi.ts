/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.5.5
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

    import { AllocateFundsRequest } from '../model/allocateFundsRequest';
    import { CreateAddressResponse } from '../model/createAddressResponse';
    import { CreateTransactionResponse } from '../model/createTransactionResponse';
    import { CreateVaultAssetResponse } from '../model/createVaultAssetResponse';
    import { DeallocateFundsRequest } from '../model/deallocateFundsRequest';
    import { PublicKeyInformation } from '../model/publicKeyInformation';
    import { UnspentInputsResponse } from '../model/unspentInputsResponse';
    import { VaultAccount } from '../model/vaultAccount';
    import { VaultAccountsPagedResponse } from '../model/vaultAccountsPagedResponse';
    import { VaultAccountsPostRequest } from '../model/vaultAccountsPostRequest';
    import { VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest } from '../model/vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest';
    import { VaultAccountsVaultAccountIdAssetIdAddressesPostRequest } from '../model/vaultAccountsVaultAccountIdAssetIdAddressesPostRequest';
    import { VaultAccountsVaultAccountIdAssetIdPostRequest } from '../model/vaultAccountsVaultAccountIdAssetIdPostRequest';
    import { VaultAccountsVaultAccountIdPutRequest } from '../model/vaultAccountsVaultAccountIdPutRequest';
    import { VaultAccountsVaultAccountIdSetAutoFuelPostRequest } from '../model/vaultAccountsVaultAccountIdSetAutoFuelPostRequest';
    import { VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest } from '../model/vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest';
    import { VaultAsset } from '../model/vaultAsset';
    import { VaultWalletAddress } from '../model/vaultWalletAddress';
import {HttpClient} from '../utils/http-client';
import {Configuration, ConfigurationParameters} from '../utils/types/configuration';
import {ObjectSerializer} from "../model/models";
import { AxiosRequestConfig, AxiosResponse } from 'axios';


    export class VaultsApi {
        private  configuration: Configuration;
        private  httpClient: HttpClient;

        constructor(private configurationParameters:ConfigurationParameters = {}) {
            this.configuration = new Configuration(configurationParameters)
            this.httpClient = new HttpClient(this.configuration);
        }

            /**
            * Gets all vault accounts in your workspace.
                * @summary List vault accounts
                * @param namePrefix 
                * @param nameSuffix 
                * @param minAmountThreshold 
                * @param assetId 
                * @param maxBip44AddressIndexUsed 
                * @param maxBip44ChangeAddressIndexUsed 
            */
        public async vaultAccountsGet (namePrefix?: string, nameSuffix?: string, minAmountThreshold?: number, assetId?: string, maxBip44AddressIndexUsed?: number, maxBip44ChangeAddressIndexUsed?: number, ) : Promise<Array<VaultAccount>> {
                const path = this.configuration.basePath + '/vault/accounts';
                let params: any = {};
                let headers: any = {}

                    if (typeof namePrefix === 'object') {
                        for( const [key,value] of Object.entries(namePrefix)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['namePrefix'] = ObjectSerializer.serialize(namePrefix, "string");
                    }

                    if (typeof nameSuffix === 'object') {
                        for( const [key,value] of Object.entries(nameSuffix)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['nameSuffix'] = ObjectSerializer.serialize(nameSuffix, "string");
                    }

                    if (typeof minAmountThreshold === 'object') {
                        for( const [key,value] of Object.entries(minAmountThreshold)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['minAmountThreshold'] = ObjectSerializer.serialize(minAmountThreshold, "number");
                    }

                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                    if (typeof maxBip44AddressIndexUsed === 'object') {
                        for( const [key,value] of Object.entries(maxBip44AddressIndexUsed)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['maxBip44AddressIndexUsed'] = ObjectSerializer.serialize(maxBip44AddressIndexUsed, "number");
                    }

                    if (typeof maxBip44ChangeAddressIndexUsed === 'object') {
                        for( const [key,value] of Object.entries(maxBip44ChangeAddressIndexUsed)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['maxBip44ChangeAddressIndexUsed'] = ObjectSerializer.serialize(maxBip44ChangeAddressIndexUsed, "number");
                    }
                    if (namePrefix !== undefined) {
                        params['namePrefix'] = ObjectSerializer.serialize(namePrefix, "string");
                    }
                    if (nameSuffix !== undefined) {
                        params['nameSuffix'] = ObjectSerializer.serialize(nameSuffix, "string");
                    }
                    if (minAmountThreshold !== undefined) {
                        params['minAmountThreshold'] = ObjectSerializer.serialize(minAmountThreshold, "number");
                    }
                    if (assetId !== undefined) {
                        params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }
                    if (maxBip44AddressIndexUsed !== undefined) {
                        params['maxBip44AddressIndexUsed'] = ObjectSerializer.serialize(maxBip44AddressIndexUsed, "number");
                    }
                    if (maxBip44ChangeAddressIndexUsed !== undefined) {
                        params['maxBip44ChangeAddressIndexUsed'] = ObjectSerializer.serialize(maxBip44ChangeAddressIndexUsed, "number");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<Array<VaultAccount>>(requestOptions);
        }
            /**
            * Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.
                * @summary List vault acounts (Paginated)
                * @param namePrefix 
                * @param nameSuffix 
                * @param minAmountThreshold 
                * @param assetId 
                * @param maxBip44AddressIndexUsed 
                * @param maxBip44ChangeAddressIndexUsed 
                * @param orderBy 
                * @param before 
                * @param after 
                * @param limit 
            */
        public async vaultAccountsPagedGet (namePrefix?: string, nameSuffix?: string, minAmountThreshold?: number, assetId?: string, maxBip44AddressIndexUsed?: number, maxBip44ChangeAddressIndexUsed?: number, orderBy?: 'ASC' | 'DESC', before?: string, after?: string, limit?: number, ) : Promise<VaultAccountsPagedResponse> {
                const path = this.configuration.basePath + '/vault/accounts_paged';
                let params: any = {};
                let headers: any = {}

                    if (typeof namePrefix === 'object') {
                        for( const [key,value] of Object.entries(namePrefix)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['namePrefix'] = ObjectSerializer.serialize(namePrefix, "string");
                    }

                    if (typeof nameSuffix === 'object') {
                        for( const [key,value] of Object.entries(nameSuffix)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['nameSuffix'] = ObjectSerializer.serialize(nameSuffix, "string");
                    }

                    if (typeof minAmountThreshold === 'object') {
                        for( const [key,value] of Object.entries(minAmountThreshold)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['minAmountThreshold'] = ObjectSerializer.serialize(minAmountThreshold, "number");
                    }

                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                    if (typeof maxBip44AddressIndexUsed === 'object') {
                        for( const [key,value] of Object.entries(maxBip44AddressIndexUsed)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['maxBip44AddressIndexUsed'] = ObjectSerializer.serialize(maxBip44AddressIndexUsed, "number");
                    }

                    if (typeof maxBip44ChangeAddressIndexUsed === 'object') {
                        for( const [key,value] of Object.entries(maxBip44ChangeAddressIndexUsed)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['maxBip44ChangeAddressIndexUsed'] = ObjectSerializer.serialize(maxBip44ChangeAddressIndexUsed, "number");
                    }

                    if (typeof orderBy === 'object') {
                        for( const [key,value] of Object.entries(orderBy)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['orderBy'] = ObjectSerializer.serialize(orderBy, "'ASC' | 'DESC'");
                    }

                    if (typeof before === 'object') {
                        for( const [key,value] of Object.entries(before)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['before'] = ObjectSerializer.serialize(before, "string");
                    }

                    if (typeof after === 'object') {
                        for( const [key,value] of Object.entries(after)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['after'] = ObjectSerializer.serialize(after, "string");
                    }

                    if (typeof limit === 'object') {
                        for( const [key,value] of Object.entries(limit)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['limit'] = ObjectSerializer.serialize(limit, "number");
                    }
                    if (namePrefix !== undefined) {
                        params['namePrefix'] = ObjectSerializer.serialize(namePrefix, "string");
                    }
                    if (nameSuffix !== undefined) {
                        params['nameSuffix'] = ObjectSerializer.serialize(nameSuffix, "string");
                    }
                    if (minAmountThreshold !== undefined) {
                        params['minAmountThreshold'] = ObjectSerializer.serialize(minAmountThreshold, "number");
                    }
                    if (assetId !== undefined) {
                        params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }
                    if (maxBip44AddressIndexUsed !== undefined) {
                        params['maxBip44AddressIndexUsed'] = ObjectSerializer.serialize(maxBip44AddressIndexUsed, "number");
                    }
                    if (maxBip44ChangeAddressIndexUsed !== undefined) {
                        params['maxBip44ChangeAddressIndexUsed'] = ObjectSerializer.serialize(maxBip44ChangeAddressIndexUsed, "number");
                    }
                    if (orderBy !== undefined) {
                        params['orderBy'] = ObjectSerializer.serialize(orderBy, "'ASC' | 'DESC'");
                    }
                    if (before !== undefined) {
                        params['before'] = ObjectSerializer.serialize(before, "string");
                    }
                    if (after !== undefined) {
                        params['after'] = ObjectSerializer.serialize(after, "string");
                    }
                    if (limit !== undefined) {
                        params['limit'] = ObjectSerializer.serialize(limit, "number");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<VaultAccountsPagedResponse>(requestOptions);
        }
            /**
            * Creates a new vault account with the requested name.
                * @summary Create a new vault account
                * @param vaultAccountsPostRequest 
            */
        public async vaultAccountsPost (vaultAccountsPostRequest: VaultAccountsPostRequest, ) : Promise<VaultAccount> {
                const path = this.configuration.basePath + '/vault/accounts';
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountsPostRequest' is not null or undefined
                        if (vaultAccountsPostRequest === null || vaultAccountsPostRequest === undefined) {
                        throw new Error('Required parameter vaultAccountsPostRequest was null or undefined when calling vaultAccountsPost.');
                        }


                    if (typeof vaultAccountsPostRequest === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountsPostRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['VaultAccountsPostRequest'] = ObjectSerializer.serialize(vaultAccountsPostRequest, "VaultAccountsPostRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<VaultAccount>(requestOptions);
        }
            /**
            * Initiates activation for a wallet in a vault account.
                * @summary Activate a wallet in a vault account
                * @param vaultAccountId The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
                * @param assetId The ID of the asset
            */
        public async vaultAccountsVaultAccountIdAssetIdActivatePost (vaultAccountId: string, assetId: string, ) : Promise<CreateVaultAssetResponse> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/activate'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdActivatePost.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdActivatePost.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                };
                return this.httpClient.request<CreateVaultAssetResponse>(requestOptions);
        }
            /**
            * Converts an existing segwit address to the legacy format.
                * @summary Convert a segwit address to legacy format
                * @param vaultAccountId The ID of the vault account
                * @param assetId The ID of the asset
                * @param addressId The segwit address to translate
            */
        public async vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost (vaultAccountId: string, assetId: string, addressId: string, ) : Promise<CreateAddressResponse> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/create_legacy'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)))
                .replace('{' + 'addressId' + '}', encodeURIComponent(String(addressId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }
                        // verify required parameter 'addressId' is not null or undefined
                        if (addressId === null || addressId === undefined) {
                        throw new Error('Required parameter addressId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost.');
                        }


                    if (typeof addressId === 'object') {
                        for( const [key,value] of Object.entries(addressId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['addressId'] = ObjectSerializer.serialize(addressId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                };
                return this.httpClient.request<CreateAddressResponse>(requestOptions);
        }
            /**
            * Updates the description of an existing address of an asset in a vault account.
                * @summary Update address description
                * @param vaultAccountId The ID of the vault account
                * @param assetId The ID of the asset
                * @param addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
                * @param vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest 
            */
        public async vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut (vaultAccountId: string, assetId: string, addressId: string, vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest?: VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest, ) : Promise<any> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)))
                .replace('{' + 'addressId' + '}', encodeURIComponent(String(addressId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }
                        // verify required parameter 'addressId' is not null or undefined
                        if (addressId === null || addressId === undefined) {
                        throw new Error('Required parameter addressId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut.');
                        }


                    if (typeof addressId === 'object') {
                        for( const [key,value] of Object.entries(addressId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['addressId'] = ObjectSerializer.serialize(addressId, "string");
                    }

                    if (typeof vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest'] = ObjectSerializer.serialize(vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest, "VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'PUT',
                    url: path,
                        data: params
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Sets an AML/KYT customer reference ID for a specific address.
                * @summary Assign AML customer reference ID
                * @param vaultAccountId The ID of the vault account
                * @param assetId The ID of the asset
                * @param addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
                * @param vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest 
            */
        public async vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost (vaultAccountId: string, assetId: string, addressId: string, vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest: VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, ) : Promise<any> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/set_customer_ref_id'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)))
                .replace('{' + 'addressId' + '}', encodeURIComponent(String(addressId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }
                        // verify required parameter 'addressId' is not null or undefined
                        if (addressId === null || addressId === undefined) {
                        throw new Error('Required parameter addressId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost.');
                        }


                    if (typeof addressId === 'object') {
                        for( const [key,value] of Object.entries(addressId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['addressId'] = ObjectSerializer.serialize(addressId, "string");
                    }
                        // verify required parameter 'vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest' is not null or undefined
                        if (vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest === null || vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest === undefined) {
                        throw new Error('Required parameter vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest was null or undefined when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost.');
                        }


                    if (typeof vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest'] = ObjectSerializer.serialize(vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, "VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Lists all addresses for specific asset of vault account.
                * @summary Get asset addresses
                * @param vaultAccountId The ID of the vault account to return
                * @param assetId The ID of the asset
            */
        public async vaultAccountsVaultAccountIdAssetIdAddressesGet (vaultAccountId: string, assetId: string, ) : Promise<Array<VaultWalletAddress>> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/addresses'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdAddressesGet.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdAddressesGet.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<Array<VaultWalletAddress>>(requestOptions);
        }
            /**
            * Creates a new deposit address for an asset of a vault account.
                * @summary Create new asset deposit address
                * @param vaultAccountId The ID of the vault account to return
                * @param assetId The ID of the asset
                * @param vaultAccountsVaultAccountIdAssetIdAddressesPostRequest 
            */
        public async vaultAccountsVaultAccountIdAssetIdAddressesPost (vaultAccountId: string, assetId: string, vaultAccountsVaultAccountIdAssetIdAddressesPostRequest?: VaultAccountsVaultAccountIdAssetIdAddressesPostRequest, ) : Promise<CreateAddressResponse> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/addresses'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdAddressesPost.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdAddressesPost.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                    if (typeof vaultAccountsVaultAccountIdAssetIdAddressesPostRequest === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountsVaultAccountIdAssetIdAddressesPostRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['VaultAccountsVaultAccountIdAssetIdAddressesPostRequest'] = ObjectSerializer.serialize(vaultAccountsVaultAccountIdAssetIdAddressesPostRequest, "VaultAccountsVaultAccountIdAssetIdAddressesPostRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<CreateAddressResponse>(requestOptions);
        }
            /**
            * Updates the balance of a specific asset in a vault account.
                * @summary Refresh asset balance data
                * @param vaultAccountId The ID of the vault account to return
                * @param assetId The ID of the asset
                * @param body 
            */
        public async vaultAccountsVaultAccountIdAssetIdBalancePost (vaultAccountId: string, assetId: string, body?: object, ) : Promise<VaultAsset> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/balance'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdBalancePost.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdBalancePost.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                    if (typeof body === 'object') {
                        for( const [key,value] of Object.entries(body)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['body'] = ObjectSerializer.serialize(body, "object");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<VaultAsset>(requestOptions);
        }
            /**
            * Gets the public key information for the vault account.
                * @summary Get the public key for a vault account
                * @param vaultAccountId 
                * @param assetId 
                * @param change 
                * @param addressIndex 
                * @param compressed 
            */
        public async vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet (vaultAccountId: string, assetId: string, change: number, addressIndex: number, compressed?: boolean, ) : Promise<PublicKeyInformation> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/{change}/{addressIndex}/public_key_info'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)))
                .replace('{' + 'change' + '}', encodeURIComponent(String(change)))
                .replace('{' + 'addressIndex' + '}', encodeURIComponent(String(addressIndex)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }
                        // verify required parameter 'change' is not null or undefined
                        if (change === null || change === undefined) {
                        throw new Error('Required parameter change was null or undefined when calling vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet.');
                        }


                    if (typeof change === 'object') {
                        for( const [key,value] of Object.entries(change)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['change'] = ObjectSerializer.serialize(change, "number");
                    }
                        // verify required parameter 'addressIndex' is not null or undefined
                        if (addressIndex === null || addressIndex === undefined) {
                        throw new Error('Required parameter addressIndex was null or undefined when calling vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet.');
                        }


                    if (typeof addressIndex === 'object') {
                        for( const [key,value] of Object.entries(addressIndex)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['addressIndex'] = ObjectSerializer.serialize(addressIndex, "number");
                    }

                    if (typeof compressed === 'object') {
                        for( const [key,value] of Object.entries(compressed)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['compressed'] = ObjectSerializer.serialize(compressed, "boolean");
                    }
                    if (compressed !== undefined) {
                        params['compressed'] = ObjectSerializer.serialize(compressed, "boolean");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<PublicKeyInformation>(requestOptions);
        }
            /**
            * Returns a wallet for a specific asset of a vault account.
                * @summary Get the asset balance for a vault account
                * @param vaultAccountId The ID of the vault account to return
                * @param assetId The ID of the asset
            */
        public async vaultAccountsVaultAccountIdAssetIdGet (vaultAccountId: string, assetId: string, ) : Promise<VaultAsset> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdGet.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdGet.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<VaultAsset>(requestOptions);
        }
            /**
            * Transfers funds to a private ledger.
                * @summary Allocate funds to private ledger
                * @param vaultAccountId The vault account to allocate funds in
                * @param assetId The allocation asset id
                * @param allocateFundsRequest 
            */
        public async vaultAccountsVaultAccountIdAssetIdLockAllocationPost (vaultAccountId: string, assetId: string, allocateFundsRequest?: AllocateFundsRequest, ) : Promise<CreateTransactionResponse> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/lock_allocation'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdLockAllocationPost.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdLockAllocationPost.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                    if (typeof allocateFundsRequest === 'object') {
                        for( const [key,value] of Object.entries(allocateFundsRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['AllocateFundsRequest'] = ObjectSerializer.serialize(allocateFundsRequest, "AllocateFundsRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<CreateTransactionResponse>(requestOptions);
        }
            /**
            * Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.
                * @summary Get the maximum spendable amount in a single transaction.
                * @param vaultAccountId The ID of the vault account, or \&#39;default\&#39; for the default vault account
                * @param assetId The ID of the asset
                * @param manualSignging False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device.
            */
        public async vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet (vaultAccountId: string, assetId: string, manualSignging?: boolean, ) : Promise<any> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/max_spendable_amount'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                    if (typeof manualSignging === 'object') {
                        for( const [key,value] of Object.entries(manualSignging)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['manualSignging'] = ObjectSerializer.serialize(manualSignging, "boolean");
                    }
                    if (manualSignging !== undefined) {
                        params['manualSignging'] = ObjectSerializer.serialize(manualSignging, "boolean");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Creates a wallet for a specific asset in a vault account.
                * @summary Create a new wallet
                * @param vaultAccountId The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
                * @param assetId The ID of the asset
                * @param vaultAccountsVaultAccountIdAssetIdPostRequest 
            */
        public async vaultAccountsVaultAccountIdAssetIdPost (vaultAccountId: string, assetId: string, vaultAccountsVaultAccountIdAssetIdPostRequest?: VaultAccountsVaultAccountIdAssetIdPostRequest, ) : Promise<CreateVaultAssetResponse> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdPost.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdPost.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                    if (typeof vaultAccountsVaultAccountIdAssetIdPostRequest === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountsVaultAccountIdAssetIdPostRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['VaultAccountsVaultAccountIdAssetIdPostRequest'] = ObjectSerializer.serialize(vaultAccountsVaultAccountIdAssetIdPostRequest, "VaultAccountsVaultAccountIdAssetIdPostRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<CreateVaultAssetResponse>(requestOptions);
        }
            /**
            * Transfers funds from a private ledger to a vault account.
                * @summary Deallocate funds from private ledger
                * @param vaultAccountId The vault account to allocate funds in
                * @param assetId The allocation asset id
                * @param deallocateFundsRequest 
            */
        public async vaultAccountsVaultAccountIdAssetIdReleaseAllocationPost (vaultAccountId: string, assetId: string, deallocateFundsRequest?: DeallocateFundsRequest, ) : Promise<CreateTransactionResponse> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/release_allocation'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdReleaseAllocationPost.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdReleaseAllocationPost.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                    if (typeof deallocateFundsRequest === 'object') {
                        for( const [key,value] of Object.entries(deallocateFundsRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['DeallocateFundsRequest'] = ObjectSerializer.serialize(deallocateFundsRequest, "DeallocateFundsRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<CreateTransactionResponse>(requestOptions);
        }
            /**
            * Returns unspent inputs information of an asset in a vault account.
                * @summary Get UTXO unspent inputs information
                * @param vaultAccountId The ID of the vault account
                * @param assetId The ID of the asset
            */
        public async vaultAccountsVaultAccountIdAssetIdUnspentInputsGet (vaultAccountId: string, assetId: string, ) : Promise<Array<UnspentInputsResponse>> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/unspent_inputs'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdUnspentInputsGet.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling vaultAccountsVaultAccountIdAssetIdUnspentInputsGet.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<Array<UnspentInputsResponse>>(requestOptions);
        }
            /**
            * Returns the requested vault account.
                * @summary Find a vault account by ID
                * @param vaultAccountId The ID of the vault account to return type: string
            */
        public async vaultAccountsVaultAccountIdGet (vaultAccountId: string, ) : Promise<VaultAccount> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdGet.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<VaultAccount>(requestOptions);
        }
            /**
            * Hides the requested vault account from the web console view.
                * @summary Hide a vault account in the console
                * @param vaultAccountId The vault account to hide
            */
        public async vaultAccountsVaultAccountIdHidePost (vaultAccountId: string, ) : Promise<any> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/hide'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdHidePost.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Renames the requested vault account.
                * @summary Rename a vault account
                * @param vaultAccountId The ID of the vault account to edit
                * @param vaultAccountsVaultAccountIdPutRequest 
            */
        public async vaultAccountsVaultAccountIdPut (vaultAccountId: string, vaultAccountsVaultAccountIdPutRequest: VaultAccountsVaultAccountIdPutRequest, ) : Promise<any> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdPut.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'vaultAccountsVaultAccountIdPutRequest' is not null or undefined
                        if (vaultAccountsVaultAccountIdPutRequest === null || vaultAccountsVaultAccountIdPutRequest === undefined) {
                        throw new Error('Required parameter vaultAccountsVaultAccountIdPutRequest was null or undefined when calling vaultAccountsVaultAccountIdPut.');
                        }


                    if (typeof vaultAccountsVaultAccountIdPutRequest === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountsVaultAccountIdPutRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['VaultAccountsVaultAccountIdPutRequest'] = ObjectSerializer.serialize(vaultAccountsVaultAccountIdPutRequest, "VaultAccountsVaultAccountIdPutRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'PUT',
                    url: path,
                        data: params
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Sets the autofueling property of the vault account to enabled or disabled.
                * @summary Turn autofueling on or off
                * @param vaultAccountId The vault account ID
                * @param vaultAccountsVaultAccountIdSetAutoFuelPostRequest 
            */
        public async vaultAccountsVaultAccountIdSetAutoFuelPost (vaultAccountId: string, vaultAccountsVaultAccountIdSetAutoFuelPostRequest: VaultAccountsVaultAccountIdSetAutoFuelPostRequest, ) : Promise<any> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/set_auto_fuel'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdSetAutoFuelPost.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'vaultAccountsVaultAccountIdSetAutoFuelPostRequest' is not null or undefined
                        if (vaultAccountsVaultAccountIdSetAutoFuelPostRequest === null || vaultAccountsVaultAccountIdSetAutoFuelPostRequest === undefined) {
                        throw new Error('Required parameter vaultAccountsVaultAccountIdSetAutoFuelPostRequest was null or undefined when calling vaultAccountsVaultAccountIdSetAutoFuelPost.');
                        }


                    if (typeof vaultAccountsVaultAccountIdSetAutoFuelPostRequest === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountsVaultAccountIdSetAutoFuelPostRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['VaultAccountsVaultAccountIdSetAutoFuelPostRequest'] = ObjectSerializer.serialize(vaultAccountsVaultAccountIdSetAutoFuelPostRequest, "VaultAccountsVaultAccountIdSetAutoFuelPostRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Assigns an AML/KYT customer reference ID for the vault account.
                * @summary Set an AML/KYT customer reference ID for a vault account
                * @param vaultAccountId The vault account ID
                * @param vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest 
            */
        public async vaultAccountsVaultAccountIdSetCustomerRefIdPost (vaultAccountId: string, vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest: VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, ) : Promise<any> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/set_customer_ref_id'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdSetCustomerRefIdPost.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest' is not null or undefined
                        if (vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest === null || vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest === undefined) {
                        throw new Error('Required parameter vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest was null or undefined when calling vaultAccountsVaultAccountIdSetCustomerRefIdPost.');
                        }


                    if (typeof vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest'] = ObjectSerializer.serialize(vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, "VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Makes a hidden vault account visible in web console view.
                * @summary Unhide a vault account in the console
                * @param vaultAccountId The vault account to unhide
            */
        public async vaultAccountsVaultAccountIdUnhidePost (vaultAccountId: string, ) : Promise<any> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/unhide'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling vaultAccountsVaultAccountIdUnhidePost.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Gets the vault balance summary for an asset.
                * @summary Get vault balance by asset
                * @param assetId 
            */
        public async vaultAssetsAssetIdGet (assetId: string, ) : Promise<VaultAsset> {
                const path = this.configuration.basePath + '/vault/assets/{assetId}'
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling vaultAssetsAssetIdGet.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<VaultAsset>(requestOptions);
        }
            /**
            * Gets the assets amount summary for all accounts or filtered accounts.
                * @summary Get asset balance for chosen assets
                * @param accountNamePrefix 
                * @param accountNameSuffix 
            */
        public async vaultAssetsGet (accountNamePrefix?: string, accountNameSuffix?: string, ) : Promise<Array<VaultAsset>> {
                const path = this.configuration.basePath + '/vault/assets';
                let params: any = {};
                let headers: any = {}

                    if (typeof accountNamePrefix === 'object') {
                        for( const [key,value] of Object.entries(accountNamePrefix)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['accountNamePrefix'] = ObjectSerializer.serialize(accountNamePrefix, "string");
                    }

                    if (typeof accountNameSuffix === 'object') {
                        for( const [key,value] of Object.entries(accountNameSuffix)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['accountNameSuffix'] = ObjectSerializer.serialize(accountNameSuffix, "string");
                    }
                    if (accountNamePrefix !== undefined) {
                        params['accountNamePrefix'] = ObjectSerializer.serialize(accountNamePrefix, "string");
                    }
                    if (accountNameSuffix !== undefined) {
                        params['accountNameSuffix'] = ObjectSerializer.serialize(accountNameSuffix, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<Array<VaultAsset>>(requestOptions);
        }
            /**
            * Gets the public key information based on derivation path and signing algorithm.
                * @summary Get the public key information
                * @param derivationPath 
                * @param algorithm 
                * @param compressed 
            */
        public async vaultPublicKeyInfoGet (derivationPath: string, algorithm: string, compressed?: boolean, ) : Promise<PublicKeyInformation> {
                const path = this.configuration.basePath + '/vault/public_key_info/';
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'derivationPath' is not null or undefined
                        if (derivationPath === null || derivationPath === undefined) {
                        throw new Error('Required parameter derivationPath was null or undefined when calling vaultPublicKeyInfoGet.');
                        }


                    if (typeof derivationPath === 'object') {
                        for( const [key,value] of Object.entries(derivationPath)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['derivationPath'] = ObjectSerializer.serialize(derivationPath, "string");
                    }
                        // verify required parameter 'algorithm' is not null or undefined
                        if (algorithm === null || algorithm === undefined) {
                        throw new Error('Required parameter algorithm was null or undefined when calling vaultPublicKeyInfoGet.');
                        }


                    if (typeof algorithm === 'object') {
                        for( const [key,value] of Object.entries(algorithm)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['algorithm'] = ObjectSerializer.serialize(algorithm, "string");
                    }

                    if (typeof compressed === 'object') {
                        for( const [key,value] of Object.entries(compressed)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['compressed'] = ObjectSerializer.serialize(compressed, "boolean");
                    }
                    if (derivationPath !== undefined) {
                        params['derivationPath'] = ObjectSerializer.serialize(derivationPath, "string");
                    }
                    if (algorithm !== undefined) {
                        params['algorithm'] = ObjectSerializer.serialize(algorithm, "string");
                    }
                    if (compressed !== undefined) {
                        params['compressed'] = ObjectSerializer.serialize(compressed, "boolean");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<PublicKeyInformation>(requestOptions);
        }
        }
