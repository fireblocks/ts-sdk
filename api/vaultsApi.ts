/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

    import { CreateAddressResponse } from '../model/createAddressResponse';
    import { CreateVaultAccountAssetAddressRequest } from '../model/createVaultAccountAssetAddressRequest';
    import { CreateVaultAccountAssetRequest } from '../model/createVaultAccountAssetRequest';
    import { CreateVaultAccountRequest } from '../model/createVaultAccountRequest';
    import { CreateVaultAssetResponse } from '../model/createVaultAssetResponse';
    import { PaginatedAssetWalletResponse } from '../model/paginatedAssetWalletResponse';
    import { PublicKeyInformation } from '../model/publicKeyInformation';
    import { SetAutoFuelForVaultAccountRequest } from '../model/setAutoFuelForVaultAccountRequest';
    import { SetCustomerRefIdForVaultAccountRequest } from '../model/setCustomerRefIdForVaultAccountRequest';
    import { UnspentInputsResponse } from '../model/unspentInputsResponse';
    import { UpdateVaultAccountAssetAddressRequest } from '../model/updateVaultAccountAssetAddressRequest';
    import { UpdateVaultAccountRequest } from '../model/updateVaultAccountRequest';
    import { VaultAccount } from '../model/vaultAccount';
    import { VaultAccountsPagedResponse } from '../model/vaultAccountsPagedResponse';
    import { VaultAsset } from '../model/vaultAsset';
    import { VaultWalletAddress } from '../model/vaultWalletAddress';
import {HttpClient} from '../utils/http-client';
import {Configuration, ConfigurationParameters} from '../utils/types/configuration';
import {ObjectSerializer} from "../model/models";
import { AxiosRequestConfig, AxiosResponse } from 'axios';


    export class VaultsApi {
        private  configuration: Configuration;
        private  httpClient: HttpClient;

        constructor(private configurationParameters:ConfigurationParameters = {}) {
            this.configuration = new Configuration(configurationParameters)
            this.httpClient = new HttpClient(this.configuration);
        }

            /**
            * Initiates activation for a wallet in a vault account.
                * @summary Activate a wallet in a vault account
                * @param vaultAccountId The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
                * @param assetId The ID of the asset
            */
        public async activateAssetForVaultAccount (vaultAccountId: string, assetId: string, ) : Promise<CreateVaultAssetResponse> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/activate'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling activateAssetForVaultAccount.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling activateAssetForVaultAccount.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                };
                return this.httpClient.request<CreateVaultAssetResponse>(requestOptions);
        }
            /**
            * Converts an existing segwit address to the legacy format.
                * @summary Convert a segwit address to legacy format
                * @param vaultAccountId The ID of the vault account
                * @param assetId The ID of the asset
                * @param addressId The segwit address to translate
            */
        public async createLegacyAddressForVaultAccountAsset (vaultAccountId: string, assetId: string, addressId: string, ) : Promise<CreateAddressResponse> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/create_legacy'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)))
                .replace('{' + 'addressId' + '}', encodeURIComponent(String(addressId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling createLegacyAddressForVaultAccountAsset.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling createLegacyAddressForVaultAccountAsset.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }
                        // verify required parameter 'addressId' is not null or undefined
                        if (addressId === null || addressId === undefined) {
                        throw new Error('Required parameter addressId was null or undefined when calling createLegacyAddressForVaultAccountAsset.');
                        }


                    if (typeof addressId === 'object') {
                        for( const [key,value] of Object.entries(addressId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['addressId'] = ObjectSerializer.serialize(addressId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                };
                return this.httpClient.request<CreateAddressResponse>(requestOptions);
        }
            /**
            * Creates a new vault account with the requested name.
                * @summary Create a new vault account
                * @param createVaultAccountRequest 
            */
        public async createVaultAccount (createVaultAccountRequest: CreateVaultAccountRequest, ) : Promise<VaultAccount> {
                const path = this.configuration.basePath + '/vault/accounts';
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'createVaultAccountRequest' is not null or undefined
                        if (createVaultAccountRequest === null || createVaultAccountRequest === undefined) {
                        throw new Error('Required parameter createVaultAccountRequest was null or undefined when calling createVaultAccount.');
                        }


                    if (typeof createVaultAccountRequest === 'object') {
                        for( const [key,value] of Object.entries(createVaultAccountRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['CreateVaultAccountRequest'] = ObjectSerializer.serialize(createVaultAccountRequest, "CreateVaultAccountRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<VaultAccount>(requestOptions);
        }
            /**
            * Creates a wallet for a specific asset in a vault account.
                * @summary Create a new wallet
                * @param vaultAccountId The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
                * @param assetId The ID of the asset
                * @param createVaultAccountAssetRequest 
            */
        public async createVaultAccountAsset (vaultAccountId: string, assetId: string, createVaultAccountAssetRequest?: CreateVaultAccountAssetRequest, ) : Promise<CreateVaultAssetResponse> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling createVaultAccountAsset.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling createVaultAccountAsset.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                    if (typeof createVaultAccountAssetRequest === 'object') {
                        for( const [key,value] of Object.entries(createVaultAccountAssetRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['CreateVaultAccountAssetRequest'] = ObjectSerializer.serialize(createVaultAccountAssetRequest, "CreateVaultAccountAssetRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<CreateVaultAssetResponse>(requestOptions);
        }
            /**
            * Creates a new deposit address for an asset of a vault account.
                * @summary Create new asset deposit address
                * @param vaultAccountId The ID of the vault account to return
                * @param assetId The ID of the asset
                * @param createVaultAccountAssetAddressRequest 
            */
        public async createVaultAccountAssetAddress (vaultAccountId: string, assetId: string, createVaultAccountAssetAddressRequest?: CreateVaultAccountAssetAddressRequest, ) : Promise<CreateAddressResponse> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/addresses'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling createVaultAccountAssetAddress.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling createVaultAccountAssetAddress.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                    if (typeof createVaultAccountAssetAddressRequest === 'object') {
                        for( const [key,value] of Object.entries(createVaultAccountAssetAddressRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['CreateVaultAccountAssetAddressRequest'] = ObjectSerializer.serialize(createVaultAccountAssetAddressRequest, "CreateVaultAccountAssetAddressRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<CreateAddressResponse>(requestOptions);
        }
            /**
            * Gets all asset wallets at all of the vault accounts in your workspace. An asset wallet is an asset at a vault account. This method allows fast traversal of all account balances. **Note:**   - This API endpoint is in limited availability and available for selected customers. If you would like to get early access to this endpoint, please reach out to [Fireblocks Support](https://support.fireblocks.io/hc/en-us/requests/new?ticket_form_id=36000337220)   - This API call is subject to [rate limits](https://developers.fireblocks.com/reference/rate-limiting). 
                * @summary List asset wallets (Paginated)
                * @param totalAmountLargerThan When specified, only asset wallets with total balance larger than this amount are returned.
                * @param assetId When specified, only asset wallets cross vault accounts that have this asset ID are returned.
                * @param before Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page.
                * @param after Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page.
                * @param limit The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000.
            */
        public async getAssetWallets (totalAmountLargerThan?: number, assetId?: string, before?: string, after?: string, limit?: number, ) : Promise<PaginatedAssetWalletResponse> {
                const path = this.configuration.basePath + '/vault/asset_wallets';
                let params: any = {};
                let headers: any = {}

                    if (typeof totalAmountLargerThan === 'object') {
                        for( const [key,value] of Object.entries(totalAmountLargerThan)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['totalAmountLargerThan'] = ObjectSerializer.serialize(totalAmountLargerThan, "number");
                    }

                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                    if (typeof before === 'object') {
                        for( const [key,value] of Object.entries(before)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['before'] = ObjectSerializer.serialize(before, "string");
                    }

                    if (typeof after === 'object') {
                        for( const [key,value] of Object.entries(after)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['after'] = ObjectSerializer.serialize(after, "string");
                    }

                    if (typeof limit === 'object') {
                        for( const [key,value] of Object.entries(limit)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['limit'] = ObjectSerializer.serialize(limit, "number");
                    }
                    if (totalAmountLargerThan !== undefined) {
                        params['totalAmountLargerThan'] = ObjectSerializer.serialize(totalAmountLargerThan, "number");
                    }
                    if (assetId !== undefined) {
                        params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }
                    if (before !== undefined) {
                        params['before'] = ObjectSerializer.serialize(before, "string");
                    }
                    if (after !== undefined) {
                        params['after'] = ObjectSerializer.serialize(after, "string");
                    }
                    if (limit !== undefined) {
                        params['limit'] = ObjectSerializer.serialize(limit, "number");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<PaginatedAssetWalletResponse>(requestOptions);
        }
            /**
            * Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.
                * @summary Get the maximum spendable amount in a single transaction.
                * @param vaultAccountId The ID of the vault account, or \&#39;default\&#39; for the default vault account
                * @param assetId The ID of the asset
                * @param manualSignging False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device.
            */
        public async getMaxSpendableAmount (vaultAccountId: string, assetId: string, manualSignging?: boolean, ) : Promise<any> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/max_spendable_amount'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling getMaxSpendableAmount.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling getMaxSpendableAmount.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                    if (typeof manualSignging === 'object') {
                        for( const [key,value] of Object.entries(manualSignging)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['manualSignging'] = ObjectSerializer.serialize(manualSignging, "boolean");
                    }
                    if (manualSignging !== undefined) {
                        params['manualSignging'] = ObjectSerializer.serialize(manualSignging, "boolean");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.
                * @summary List vault acounts (Paginated)
                * @param namePrefix 
                * @param nameSuffix 
                * @param minAmountThreshold 
                * @param assetId 
                * @param maxBip44AddressIndexUsed 
                * @param maxBip44ChangeAddressIndexUsed 
                * @param orderBy 
                * @param before 
                * @param after 
                * @param limit 
            */
        public async getPagedVaultAccounts (namePrefix?: string, nameSuffix?: string, minAmountThreshold?: number, assetId?: string, maxBip44AddressIndexUsed?: number, maxBip44ChangeAddressIndexUsed?: number, orderBy?: 'ASC' | 'DESC', before?: string, after?: string, limit?: number, ) : Promise<VaultAccountsPagedResponse> {
                const path = this.configuration.basePath + '/vault/accounts_paged';
                let params: any = {};
                let headers: any = {}

                    if (typeof namePrefix === 'object') {
                        for( const [key,value] of Object.entries(namePrefix)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['namePrefix'] = ObjectSerializer.serialize(namePrefix, "string");
                    }

                    if (typeof nameSuffix === 'object') {
                        for( const [key,value] of Object.entries(nameSuffix)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['nameSuffix'] = ObjectSerializer.serialize(nameSuffix, "string");
                    }

                    if (typeof minAmountThreshold === 'object') {
                        for( const [key,value] of Object.entries(minAmountThreshold)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['minAmountThreshold'] = ObjectSerializer.serialize(minAmountThreshold, "number");
                    }

                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                    if (typeof maxBip44AddressIndexUsed === 'object') {
                        for( const [key,value] of Object.entries(maxBip44AddressIndexUsed)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['maxBip44AddressIndexUsed'] = ObjectSerializer.serialize(maxBip44AddressIndexUsed, "number");
                    }

                    if (typeof maxBip44ChangeAddressIndexUsed === 'object') {
                        for( const [key,value] of Object.entries(maxBip44ChangeAddressIndexUsed)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['maxBip44ChangeAddressIndexUsed'] = ObjectSerializer.serialize(maxBip44ChangeAddressIndexUsed, "number");
                    }

                    if (typeof orderBy === 'object') {
                        for( const [key,value] of Object.entries(orderBy)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['orderBy'] = ObjectSerializer.serialize(orderBy, "'ASC' | 'DESC'");
                    }

                    if (typeof before === 'object') {
                        for( const [key,value] of Object.entries(before)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['before'] = ObjectSerializer.serialize(before, "string");
                    }

                    if (typeof after === 'object') {
                        for( const [key,value] of Object.entries(after)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['after'] = ObjectSerializer.serialize(after, "string");
                    }

                    if (typeof limit === 'object') {
                        for( const [key,value] of Object.entries(limit)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['limit'] = ObjectSerializer.serialize(limit, "number");
                    }
                    if (namePrefix !== undefined) {
                        params['namePrefix'] = ObjectSerializer.serialize(namePrefix, "string");
                    }
                    if (nameSuffix !== undefined) {
                        params['nameSuffix'] = ObjectSerializer.serialize(nameSuffix, "string");
                    }
                    if (minAmountThreshold !== undefined) {
                        params['minAmountThreshold'] = ObjectSerializer.serialize(minAmountThreshold, "number");
                    }
                    if (assetId !== undefined) {
                        params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }
                    if (maxBip44AddressIndexUsed !== undefined) {
                        params['maxBip44AddressIndexUsed'] = ObjectSerializer.serialize(maxBip44AddressIndexUsed, "number");
                    }
                    if (maxBip44ChangeAddressIndexUsed !== undefined) {
                        params['maxBip44ChangeAddressIndexUsed'] = ObjectSerializer.serialize(maxBip44ChangeAddressIndexUsed, "number");
                    }
                    if (orderBy !== undefined) {
                        params['orderBy'] = ObjectSerializer.serialize(orderBy, "'ASC' | 'DESC'");
                    }
                    if (before !== undefined) {
                        params['before'] = ObjectSerializer.serialize(before, "string");
                    }
                    if (after !== undefined) {
                        params['after'] = ObjectSerializer.serialize(after, "string");
                    }
                    if (limit !== undefined) {
                        params['limit'] = ObjectSerializer.serialize(limit, "number");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<VaultAccountsPagedResponse>(requestOptions);
        }
            /**
            * Gets the public key information based on derivation path and signing algorithm.
                * @summary Get the public key information
                * @param derivationPath 
                * @param algorithm 
                * @param compressed 
            */
        public async getPublicKeyInfo (derivationPath: string, algorithm: string, compressed?: boolean, ) : Promise<PublicKeyInformation> {
                const path = this.configuration.basePath + '/vault/public_key_info/';
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'derivationPath' is not null or undefined
                        if (derivationPath === null || derivationPath === undefined) {
                        throw new Error('Required parameter derivationPath was null or undefined when calling getPublicKeyInfo.');
                        }


                    if (typeof derivationPath === 'object') {
                        for( const [key,value] of Object.entries(derivationPath)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['derivationPath'] = ObjectSerializer.serialize(derivationPath, "string");
                    }
                        // verify required parameter 'algorithm' is not null or undefined
                        if (algorithm === null || algorithm === undefined) {
                        throw new Error('Required parameter algorithm was null or undefined when calling getPublicKeyInfo.');
                        }


                    if (typeof algorithm === 'object') {
                        for( const [key,value] of Object.entries(algorithm)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['algorithm'] = ObjectSerializer.serialize(algorithm, "string");
                    }

                    if (typeof compressed === 'object') {
                        for( const [key,value] of Object.entries(compressed)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['compressed'] = ObjectSerializer.serialize(compressed, "boolean");
                    }
                    if (derivationPath !== undefined) {
                        params['derivationPath'] = ObjectSerializer.serialize(derivationPath, "string");
                    }
                    if (algorithm !== undefined) {
                        params['algorithm'] = ObjectSerializer.serialize(algorithm, "string");
                    }
                    if (compressed !== undefined) {
                        params['compressed'] = ObjectSerializer.serialize(compressed, "boolean");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<PublicKeyInformation>(requestOptions);
        }
            /**
            * Gets the public key information for the vault account.
                * @summary Get the public key for a vault account
                * @param vaultAccountId 
                * @param assetId 
                * @param change 
                * @param addressIndex 
                * @param compressed 
            */
        public async getPublicKeyInfoForAddress (vaultAccountId: string, assetId: string, change: number, addressIndex: number, compressed?: boolean, ) : Promise<PublicKeyInformation> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/{change}/{addressIndex}/public_key_info'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)))
                .replace('{' + 'change' + '}', encodeURIComponent(String(change)))
                .replace('{' + 'addressIndex' + '}', encodeURIComponent(String(addressIndex)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling getPublicKeyInfoForAddress.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling getPublicKeyInfoForAddress.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }
                        // verify required parameter 'change' is not null or undefined
                        if (change === null || change === undefined) {
                        throw new Error('Required parameter change was null or undefined when calling getPublicKeyInfoForAddress.');
                        }


                    if (typeof change === 'object') {
                        for( const [key,value] of Object.entries(change)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['change'] = ObjectSerializer.serialize(change, "number");
                    }
                        // verify required parameter 'addressIndex' is not null or undefined
                        if (addressIndex === null || addressIndex === undefined) {
                        throw new Error('Required parameter addressIndex was null or undefined when calling getPublicKeyInfoForAddress.');
                        }


                    if (typeof addressIndex === 'object') {
                        for( const [key,value] of Object.entries(addressIndex)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['addressIndex'] = ObjectSerializer.serialize(addressIndex, "number");
                    }

                    if (typeof compressed === 'object') {
                        for( const [key,value] of Object.entries(compressed)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['compressed'] = ObjectSerializer.serialize(compressed, "boolean");
                    }
                    if (compressed !== undefined) {
                        params['compressed'] = ObjectSerializer.serialize(compressed, "boolean");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<PublicKeyInformation>(requestOptions);
        }
            /**
            * Returns a wallet for a specific asset of a vault account.
                * @summary Get the asset balance for a vault account
                * @param vaultAccountId The ID of the vault account to return
                * @param assetId The ID of the asset
            */
        public async getVaultAccountAsset (vaultAccountId: string, assetId: string, ) : Promise<VaultAsset> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling getVaultAccountAsset.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling getVaultAccountAsset.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<VaultAsset>(requestOptions);
        }
            /**
            * Lists all addresses for specific asset of vault account.
                * @summary Get asset addresses
                * @param vaultAccountId The ID of the vault account to return
                * @param assetId The ID of the asset
            */
        public async getVaultAccountAssetAddresses (vaultAccountId: string, assetId: string, ) : Promise<Array<VaultWalletAddress>> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/addresses'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling getVaultAccountAssetAddresses.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling getVaultAccountAssetAddresses.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<Array<VaultWalletAddress>>(requestOptions);
        }
            /**
            * Returns unspent inputs information of an asset in a vault account.
                * @summary Get UTXO unspent inputs information
                * @param vaultAccountId The ID of the vault account
                * @param assetId The ID of the asset
            */
        public async getVaultAccountAssetUnspentInputs (vaultAccountId: string, assetId: string, ) : Promise<Array<UnspentInputsResponse>> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/unspent_inputs'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling getVaultAccountAssetUnspentInputs.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling getVaultAccountAssetUnspentInputs.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<Array<UnspentInputsResponse>>(requestOptions);
        }
            /**
            * Returns the requested vault account.
                * @summary Find a vault account by ID
                * @param vaultAccountId The ID of the vault account to return type: string
            */
        public async getVaultAccountById (vaultAccountId: string, ) : Promise<VaultAccount> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling getVaultAccountById.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<VaultAccount>(requestOptions);
        }
            /**
            * Gets all vault accounts in your workspace.
                * @summary List vault accounts
                * @param namePrefix 
                * @param nameSuffix 
                * @param minAmountThreshold 
                * @param assetId 
                * @param maxBip44AddressIndexUsed 
                * @param maxBip44ChangeAddressIndexUsed 
            */
        public async getVaultAccounts (namePrefix?: string, nameSuffix?: string, minAmountThreshold?: number, assetId?: string, maxBip44AddressIndexUsed?: number, maxBip44ChangeAddressIndexUsed?: number, ) : Promise<Array<VaultAccount>> {
                const path = this.configuration.basePath + '/vault/accounts';
                let params: any = {};
                let headers: any = {}

                    if (typeof namePrefix === 'object') {
                        for( const [key,value] of Object.entries(namePrefix)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['namePrefix'] = ObjectSerializer.serialize(namePrefix, "string");
                    }

                    if (typeof nameSuffix === 'object') {
                        for( const [key,value] of Object.entries(nameSuffix)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['nameSuffix'] = ObjectSerializer.serialize(nameSuffix, "string");
                    }

                    if (typeof minAmountThreshold === 'object') {
                        for( const [key,value] of Object.entries(minAmountThreshold)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['minAmountThreshold'] = ObjectSerializer.serialize(minAmountThreshold, "number");
                    }

                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                    if (typeof maxBip44AddressIndexUsed === 'object') {
                        for( const [key,value] of Object.entries(maxBip44AddressIndexUsed)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['maxBip44AddressIndexUsed'] = ObjectSerializer.serialize(maxBip44AddressIndexUsed, "number");
                    }

                    if (typeof maxBip44ChangeAddressIndexUsed === 'object') {
                        for( const [key,value] of Object.entries(maxBip44ChangeAddressIndexUsed)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['maxBip44ChangeAddressIndexUsed'] = ObjectSerializer.serialize(maxBip44ChangeAddressIndexUsed, "number");
                    }
                    if (namePrefix !== undefined) {
                        params['namePrefix'] = ObjectSerializer.serialize(namePrefix, "string");
                    }
                    if (nameSuffix !== undefined) {
                        params['nameSuffix'] = ObjectSerializer.serialize(nameSuffix, "string");
                    }
                    if (minAmountThreshold !== undefined) {
                        params['minAmountThreshold'] = ObjectSerializer.serialize(minAmountThreshold, "number");
                    }
                    if (assetId !== undefined) {
                        params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }
                    if (maxBip44AddressIndexUsed !== undefined) {
                        params['maxBip44AddressIndexUsed'] = ObjectSerializer.serialize(maxBip44AddressIndexUsed, "number");
                    }
                    if (maxBip44ChangeAddressIndexUsed !== undefined) {
                        params['maxBip44ChangeAddressIndexUsed'] = ObjectSerializer.serialize(maxBip44ChangeAddressIndexUsed, "number");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<Array<VaultAccount>>(requestOptions);
        }
            /**
            * Gets the vault balance summary for an asset.
                * @summary Get vault balance by asset
                * @param assetId 
            */
        public async getVaultAssetById (assetId: string, ) : Promise<VaultAsset> {
                const path = this.configuration.basePath + '/vault/assets/{assetId}'
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling getVaultAssetById.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<VaultAsset>(requestOptions);
        }
            /**
            * Gets the assets amount summary for all accounts or filtered accounts.
                * @summary Get asset balance for chosen assets
                * @param accountNamePrefix 
                * @param accountNameSuffix 
            */
        public async getVaultAssets (accountNamePrefix?: string, accountNameSuffix?: string, ) : Promise<Array<VaultAsset>> {
                const path = this.configuration.basePath + '/vault/assets';
                let params: any = {};
                let headers: any = {}

                    if (typeof accountNamePrefix === 'object') {
                        for( const [key,value] of Object.entries(accountNamePrefix)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['accountNamePrefix'] = ObjectSerializer.serialize(accountNamePrefix, "string");
                    }

                    if (typeof accountNameSuffix === 'object') {
                        for( const [key,value] of Object.entries(accountNameSuffix)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['accountNameSuffix'] = ObjectSerializer.serialize(accountNameSuffix, "string");
                    }
                    if (accountNamePrefix !== undefined) {
                        params['accountNamePrefix'] = ObjectSerializer.serialize(accountNamePrefix, "string");
                    }
                    if (accountNameSuffix !== undefined) {
                        params['accountNameSuffix'] = ObjectSerializer.serialize(accountNameSuffix, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'GET',
                    url: path,
                };
                return this.httpClient.request<Array<VaultAsset>>(requestOptions);
        }
            /**
            * Hides the requested vault account from the web console view.
                * @summary Hide a vault account in the console
                * @param vaultAccountId The vault account to hide
            */
        public async hideVaultAccount (vaultAccountId: string, ) : Promise<any> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/hide'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling hideVaultAccount.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Sets the autofueling property of the vault account to enabled or disabled.
                * @summary Turn autofueling on or off
                * @param vaultAccountId The vault account ID
                * @param setAutoFuelForVaultAccountRequest 
            */
        public async setAutoFuelForVaultAccount (vaultAccountId: string, setAutoFuelForVaultAccountRequest: SetAutoFuelForVaultAccountRequest, ) : Promise<any> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/set_auto_fuel'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling setAutoFuelForVaultAccount.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'setAutoFuelForVaultAccountRequest' is not null or undefined
                        if (setAutoFuelForVaultAccountRequest === null || setAutoFuelForVaultAccountRequest === undefined) {
                        throw new Error('Required parameter setAutoFuelForVaultAccountRequest was null or undefined when calling setAutoFuelForVaultAccount.');
                        }


                    if (typeof setAutoFuelForVaultAccountRequest === 'object') {
                        for( const [key,value] of Object.entries(setAutoFuelForVaultAccountRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['SetAutoFuelForVaultAccountRequest'] = ObjectSerializer.serialize(setAutoFuelForVaultAccountRequest, "SetAutoFuelForVaultAccountRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Assigns an AML/KYT customer reference ID for the vault account.
                * @summary Set an AML/KYT customer reference ID for a vault account
                * @param vaultAccountId The vault account ID
                * @param setCustomerRefIdForVaultAccountRequest 
            */
        public async setCustomerRefIdForVaultAccount (vaultAccountId: string, setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest, ) : Promise<any> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/set_customer_ref_id'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling setCustomerRefIdForVaultAccount.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'setCustomerRefIdForVaultAccountRequest' is not null or undefined
                        if (setCustomerRefIdForVaultAccountRequest === null || setCustomerRefIdForVaultAccountRequest === undefined) {
                        throw new Error('Required parameter setCustomerRefIdForVaultAccountRequest was null or undefined when calling setCustomerRefIdForVaultAccount.');
                        }


                    if (typeof setCustomerRefIdForVaultAccountRequest === 'object') {
                        for( const [key,value] of Object.entries(setCustomerRefIdForVaultAccountRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['SetCustomerRefIdForVaultAccountRequest'] = ObjectSerializer.serialize(setCustomerRefIdForVaultAccountRequest, "SetCustomerRefIdForVaultAccountRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Sets an AML/KYT customer reference ID for a specific address.
                * @summary Assign AML customer reference ID
                * @param vaultAccountId The ID of the vault account
                * @param assetId The ID of the asset
                * @param addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
                * @param setCustomerRefIdForVaultAccountRequest 
            */
        public async setCustomerRefIdForVaultAccountAssetAddress (vaultAccountId: string, assetId: string, addressId: string, setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest, ) : Promise<any> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/set_customer_ref_id'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)))
                .replace('{' + 'addressId' + '}', encodeURIComponent(String(addressId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling setCustomerRefIdForVaultAccountAssetAddress.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling setCustomerRefIdForVaultAccountAssetAddress.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }
                        // verify required parameter 'addressId' is not null or undefined
                        if (addressId === null || addressId === undefined) {
                        throw new Error('Required parameter addressId was null or undefined when calling setCustomerRefIdForVaultAccountAssetAddress.');
                        }


                    if (typeof addressId === 'object') {
                        for( const [key,value] of Object.entries(addressId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['addressId'] = ObjectSerializer.serialize(addressId, "string");
                    }
                        // verify required parameter 'setCustomerRefIdForVaultAccountRequest' is not null or undefined
                        if (setCustomerRefIdForVaultAccountRequest === null || setCustomerRefIdForVaultAccountRequest === undefined) {
                        throw new Error('Required parameter setCustomerRefIdForVaultAccountRequest was null or undefined when calling setCustomerRefIdForVaultAccountAssetAddress.');
                        }


                    if (typeof setCustomerRefIdForVaultAccountRequest === 'object') {
                        for( const [key,value] of Object.entries(setCustomerRefIdForVaultAccountRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['SetCustomerRefIdForVaultAccountRequest'] = ObjectSerializer.serialize(setCustomerRefIdForVaultAccountRequest, "SetCustomerRefIdForVaultAccountRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Makes a hidden vault account visible in web console view.
                * @summary Unhide a vault account in the console
                * @param vaultAccountId The vault account to unhide
            */
        public async unhideVaultAccount (vaultAccountId: string, ) : Promise<any> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/unhide'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling unhideVaultAccount.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Renames the requested vault account.
                * @summary Rename a vault account
                * @param vaultAccountId The ID of the vault account to edit
                * @param updateVaultAccountRequest 
            */
        public async updateVaultAccount (vaultAccountId: string, updateVaultAccountRequest: UpdateVaultAccountRequest, ) : Promise<any> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling updateVaultAccount.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'updateVaultAccountRequest' is not null or undefined
                        if (updateVaultAccountRequest === null || updateVaultAccountRequest === undefined) {
                        throw new Error('Required parameter updateVaultAccountRequest was null or undefined when calling updateVaultAccount.');
                        }


                    if (typeof updateVaultAccountRequest === 'object') {
                        for( const [key,value] of Object.entries(updateVaultAccountRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['UpdateVaultAccountRequest'] = ObjectSerializer.serialize(updateVaultAccountRequest, "UpdateVaultAccountRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'PUT',
                    url: path,
                        data: params
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Updates the description of an existing address of an asset in a vault account.
                * @summary Update address description
                * @param vaultAccountId The ID of the vault account
                * @param assetId The ID of the asset
                * @param addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
                * @param updateVaultAccountAssetAddressRequest 
            */
        public async updateVaultAccountAssetAddress (vaultAccountId: string, assetId: string, addressId: string, updateVaultAccountAssetAddressRequest?: UpdateVaultAccountAssetAddressRequest, ) : Promise<any> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)))
                .replace('{' + 'addressId' + '}', encodeURIComponent(String(addressId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling updateVaultAccountAssetAddress.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling updateVaultAccountAssetAddress.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }
                        // verify required parameter 'addressId' is not null or undefined
                        if (addressId === null || addressId === undefined) {
                        throw new Error('Required parameter addressId was null or undefined when calling updateVaultAccountAssetAddress.');
                        }


                    if (typeof addressId === 'object') {
                        for( const [key,value] of Object.entries(addressId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['addressId'] = ObjectSerializer.serialize(addressId, "string");
                    }

                    if (typeof updateVaultAccountAssetAddressRequest === 'object') {
                        for( const [key,value] of Object.entries(updateVaultAccountAssetAddressRequest)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['UpdateVaultAccountAssetAddressRequest'] = ObjectSerializer.serialize(updateVaultAccountAssetAddressRequest, "UpdateVaultAccountAssetAddressRequest");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'PUT',
                    url: path,
                        data: params
                };
                return this.httpClient.request<any>(requestOptions);
        }
            /**
            * Updates the balance of a specific asset in a vault account.
                * @summary Refresh asset balance data
                * @param vaultAccountId The ID of the vault account to return
                * @param assetId The ID of the asset
                * @param body 
            */
        public async updateVaultAccountAssetBalance (vaultAccountId: string, assetId: string, body?: object, ) : Promise<VaultAsset> {
                const path = this.configuration.basePath + '/vault/accounts/{vaultAccountId}/{assetId}/balance'
                .replace('{' + 'vaultAccountId' + '}', encodeURIComponent(String(vaultAccountId)))
                .replace('{' + 'assetId' + '}', encodeURIComponent(String(assetId)));
                let params: any = {};
                let headers: any = {}
                        // verify required parameter 'vaultAccountId' is not null or undefined
                        if (vaultAccountId === null || vaultAccountId === undefined) {
                        throw new Error('Required parameter vaultAccountId was null or undefined when calling updateVaultAccountAssetBalance.');
                        }


                    if (typeof vaultAccountId === 'object') {
                        for( const [key,value] of Object.entries(vaultAccountId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['vaultAccountId'] = ObjectSerializer.serialize(vaultAccountId, "string");
                    }
                        // verify required parameter 'assetId' is not null or undefined
                        if (assetId === null || assetId === undefined) {
                        throw new Error('Required parameter assetId was null or undefined when calling updateVaultAccountAssetBalance.');
                        }


                    if (typeof assetId === 'object') {
                        for( const [key,value] of Object.entries(assetId)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['assetId'] = ObjectSerializer.serialize(assetId, "string");
                    }

                    if (typeof body === 'object') {
                        for( const [key,value] of Object.entries(body)){
                            params[key] = ObjectSerializer.serialize(value, typeof value);
                        }
                    } else {
                            params['body'] = ObjectSerializer.serialize(body, "object");
                    }

                let requestOptions: AxiosRequestConfig = {
                    method:'POST',
                    url: path,
                        data: params
                };
                return this.httpClient.request<VaultAsset>(requestOptions);
        }
        }
