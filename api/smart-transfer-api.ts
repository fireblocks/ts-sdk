/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import { convertToFireblocksResponse } from "../response/fireblocksResponse";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { SmartTransferBadRequestResponse } from '../models';
// @ts-ignore
import { SmartTransferCreateTicket } from '../models';
// @ts-ignore
import { SmartTransferCreateTicketTerm } from '../models';
// @ts-ignore
import { SmartTransferForbiddenResponse } from '../models';
// @ts-ignore
import { SmartTransferFundTerm } from '../models';
// @ts-ignore
import { SmartTransferManuallyFundTerm } from '../models';
// @ts-ignore
import { SmartTransferNotFoundResponse } from '../models';
// @ts-ignore
import { SmartTransferSetTicketExpiration } from '../models';
// @ts-ignore
import { SmartTransferSetTicketExternalId } from '../models';
// @ts-ignore
import { SmartTransferSetUserGroups } from '../models';
// @ts-ignore
import { SmartTransferSubmitTicket } from '../models';
// @ts-ignore
import { SmartTransferTicketFilteredResponse } from '../models';
// @ts-ignore
import { SmartTransferTicketResponse } from '../models';
// @ts-ignore
import { SmartTransferTicketTermResponse } from '../models';
// @ts-ignore
import { SmartTransferUpdateTicketTerm } from '../models';
// @ts-ignore
import { SmartTransferUserGroupsResponse } from '../models';
/**
 * SmartTransferApi - axios parameter creator
 * @export
 */
export const SmartTransferApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel Smart Transfer ticket
         * @summary Cancel Ticket
         * @param {string} ticketId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTicket: async (ticketId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('cancelTicket', 'ticketId', ticketId)
            const localVarPath = `/smart-transfers/{ticketId}/cancel`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new Smart Transfer ticket
         * @summary Create Ticket
         * @param {SmartTransferCreateTicket} smartTransferCreateTicket 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket: async (smartTransferCreateTicket: SmartTransferCreateTicket, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'smartTransferCreateTicket' is not null or undefined
            assertParamExists('createTicket', 'smartTransferCreateTicket', smartTransferCreateTicket)
            const localVarPath = `/smart-transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smartTransferCreateTicket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates new smart transfer ticket term (when the ticket status is DRAFT)
         * @summary Create leg (term)
         * @param {SmartTransferCreateTicketTerm} smartTransferCreateTicketTerm 
         * @param {string} ticketId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketTerm: async (smartTransferCreateTicketTerm: SmartTransferCreateTicketTerm, ticketId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'smartTransferCreateTicketTerm' is not null or undefined
            assertParamExists('createTicketTerm', 'smartTransferCreateTicketTerm', smartTransferCreateTicketTerm)
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('createTicketTerm', 'ticketId', ticketId)
            const localVarPath = `/smart-transfers/{ticketId}/terms`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smartTransferCreateTicketTerm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find Smart Transfer ticket by id
         * @summary Search Tickets by ID
         * @param {string} ticketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTicketById: async (ticketId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('findTicketById', 'ticketId', ticketId)
            const localVarPath = `/smart-transfers/{ticketId}`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find Smart Transfer ticket term by id
         * @summary Search ticket by leg (term) ID
         * @param {string} ticketId 
         * @param {string} termId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTicketTermById: async (ticketId: string, termId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('findTicketTermById', 'ticketId', ticketId)
            // verify required parameter 'termId' is not null or undefined
            assertParamExists('findTicketTermById', 'termId', termId)
            const localVarPath = `/smart-transfers/{ticketId}/terms/{termId}`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)))
                .replace(`{${"termId"}}`, encodeURIComponent(String(termId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manually fulfill ticket, in case when all terms (legs) are funded manually
         * @summary Fund ticket manually
         * @param {string} ticketId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillTicket: async (ticketId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('fulfillTicket', 'ticketId', ticketId)
            const localVarPath = `/smart-transfers/{ticketId}/fulfill`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set funding source for ticket term (in case of ASYNC tickets, this will execute transfer immediately)
         * @summary Define funding source
         * @param {SmartTransferFundTerm} smartTransferFundTerm 
         * @param {string} ticketId 
         * @param {string} termId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fundTicketTerm: async (smartTransferFundTerm: SmartTransferFundTerm, ticketId: string, termId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'smartTransferFundTerm' is not null or undefined
            assertParamExists('fundTicketTerm', 'smartTransferFundTerm', smartTransferFundTerm)
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('fundTicketTerm', 'ticketId', ticketId)
            // verify required parameter 'termId' is not null or undefined
            assertParamExists('fundTicketTerm', 'termId', termId)
            const localVarPath = `/smart-transfers/{ticketId}/terms/{termId}/fund`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)))
                .replace(`{${"termId"}}`, encodeURIComponent(String(termId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smartTransferFundTerm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Smart Transfer user groups
         * @summary Get user group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmartTransferUserGroups: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/smart-transfers/settings/user-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manually set ticket term transaction
         * @summary Manually add term transaction
         * @param {SmartTransferManuallyFundTerm} smartTransferManuallyFundTerm 
         * @param {string} ticketId 
         * @param {string} termId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manuallyFundTicketTerm: async (smartTransferManuallyFundTerm: SmartTransferManuallyFundTerm, ticketId: string, termId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'smartTransferManuallyFundTerm' is not null or undefined
            assertParamExists('manuallyFundTicketTerm', 'smartTransferManuallyFundTerm', smartTransferManuallyFundTerm)
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('manuallyFundTicketTerm', 'ticketId', ticketId)
            // verify required parameter 'termId' is not null or undefined
            assertParamExists('manuallyFundTicketTerm', 'termId', termId)
            const localVarPath = `/smart-transfers/{ticketId}/terms/{termId}/manually-fund`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)))
                .replace(`{${"termId"}}`, encodeURIComponent(String(termId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smartTransferManuallyFundTerm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete ticket term when ticket is in DRAFT status
         * @summary Delete ticket leg (term)
         * @param {string} ticketId 
         * @param {string} termId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTicketTerm: async (ticketId: string, termId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('removeTicketTerm', 'ticketId', ticketId)
            // verify required parameter 'termId' is not null or undefined
            assertParamExists('removeTicketTerm', 'termId', termId)
            const localVarPath = `/smart-transfers/{ticketId}/terms/{termId}`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)))
                .replace(`{${"termId"}}`, encodeURIComponent(String(termId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds Smart Transfer tickets that match the submitted criteria
         * @summary Find Ticket
         * @param {string} [q] Search string - counterparty name or asset or ticketId. Optional
         * @param {Array<SearchTicketsStatusesEnum>} [statuses] Ticket statuses for Smart Transfer tickets. Optional
         * @param {string} [networkId] NetworkId that is used in the ticket . Optional
         * @param {boolean} [createdByMe] Filter created tickets by created by self or by others. Optional
         * @param {string} [expiresAfter] Lower bound of search range. Optional
         * @param {string} [expiresBefore] Upper bound of search range. Optional
         * @param {SearchTicketsTypeEnum} [type] Type of transfer. ASYNC executes transfers as they are funded, ATOMIC executes all terms (legs) as one atomic transfer
         * @param {string} [externalRefId] External ref. ID that workspace can use to identify ticket outside of Fireblocks system.
         * @param {string} [after] ID of the record after which to fetch $limit records
         * @param {number} [limit] Number of records to fetch. By default, it is 100
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTickets: async (q?: string, statuses?: Array<SearchTicketsStatusesEnum>, networkId?: string, createdByMe?: boolean, expiresAfter?: string, expiresBefore?: string, type?: SearchTicketsTypeEnum, externalRefId?: string, after?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/smart-transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (networkId !== undefined) {
                localVarQueryParameter['networkId'] = networkId;
            }

            if (createdByMe !== undefined) {
                localVarQueryParameter['createdByMe'] = createdByMe;
            }

            if (expiresAfter !== undefined) {
                localVarQueryParameter['expiresAfter'] = (expiresAfter as any instanceof Date) ?
                    (expiresAfter as any).toISOString() :
                    expiresAfter;
            }

            if (expiresBefore !== undefined) {
                localVarQueryParameter['expiresBefore'] = (expiresBefore as any instanceof Date) ?
                    (expiresBefore as any).toISOString() :
                    expiresBefore;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (externalRefId !== undefined) {
                localVarQueryParameter['externalRefId'] = externalRefId;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set external id Smart Transfer ticket
         * @summary Add external ref. ID
         * @param {SmartTransferSetTicketExternalId} smartTransferSetTicketExternalId 
         * @param {string} ticketId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalRefId: async (smartTransferSetTicketExternalId: SmartTransferSetTicketExternalId, ticketId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'smartTransferSetTicketExternalId' is not null or undefined
            assertParamExists('setExternalRefId', 'smartTransferSetTicketExternalId', smartTransferSetTicketExternalId)
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('setExternalRefId', 'ticketId', ticketId)
            const localVarPath = `/smart-transfers/{ticketId}/external-id`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smartTransferSetTicketExternalId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set expiration date on Smart Transfer ticket
         * @summary Set expiration
         * @param {SmartTransferSetTicketExpiration} smartTransferSetTicketExpiration 
         * @param {string} ticketId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTicketExpiration: async (smartTransferSetTicketExpiration: SmartTransferSetTicketExpiration, ticketId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'smartTransferSetTicketExpiration' is not null or undefined
            assertParamExists('setTicketExpiration', 'smartTransferSetTicketExpiration', smartTransferSetTicketExpiration)
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('setTicketExpiration', 'ticketId', ticketId)
            const localVarPath = `/smart-transfers/{ticketId}/expires-in`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smartTransferSetTicketExpiration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set Smart Transfer user group
         * @summary Set user group
         * @param {SmartTransferSetUserGroups} smartTransferSetUserGroups 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserGroups: async (smartTransferSetUserGroups: SmartTransferSetUserGroups, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'smartTransferSetUserGroups' is not null or undefined
            assertParamExists('setUserGroups', 'smartTransferSetUserGroups', smartTransferSetUserGroups)
            const localVarPath = `/smart-transfers/settings/user-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smartTransferSetUserGroups, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit Smart Transfer ticket - change status into ready for approval if auto approval is not turned on, or OPEN if auto approval is on
         * @summary Submit ticket
         * @param {SmartTransferSubmitTicket} smartTransferSubmitTicket 
         * @param {string} ticketId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTicket: async (smartTransferSubmitTicket: SmartTransferSubmitTicket, ticketId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'smartTransferSubmitTicket' is not null or undefined
            assertParamExists('submitTicket', 'smartTransferSubmitTicket', smartTransferSubmitTicket)
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('submitTicket', 'ticketId', ticketId)
            const localVarPath = `/smart-transfers/{ticketId}/submit`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smartTransferSubmitTicket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update ticket term (when ticket status is DRAFT)
         * @summary Update ticket leg (term)
         * @param {SmartTransferUpdateTicketTerm} smartTransferUpdateTicketTerm 
         * @param {string} ticketId 
         * @param {string} termId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicketTerm: async (smartTransferUpdateTicketTerm: SmartTransferUpdateTicketTerm, ticketId: string, termId: string, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'smartTransferUpdateTicketTerm' is not null or undefined
            assertParamExists('updateTicketTerm', 'smartTransferUpdateTicketTerm', smartTransferUpdateTicketTerm)
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('updateTicketTerm', 'ticketId', ticketId)
            // verify required parameter 'termId' is not null or undefined
            assertParamExists('updateTicketTerm', 'termId', termId)
            const localVarPath = `/smart-transfers/{ticketId}/terms/{termId}`
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)))
                .replace(`{${"termId"}}`, encodeURIComponent(String(termId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smartTransferUpdateTicketTerm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SmartTransferApi - functional programming interface
 * @export
 */
export const SmartTransferApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SmartTransferApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel Smart Transfer ticket
         * @summary Cancel Ticket
         * @param {string} ticketId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTicket(ticketId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartTransferTicketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTicket(ticketId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SmartTransferApi.cancelTicket']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates new Smart Transfer ticket
         * @summary Create Ticket
         * @param {SmartTransferCreateTicket} smartTransferCreateTicket 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTicket(smartTransferCreateTicket: SmartTransferCreateTicket, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartTransferTicketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTicket(smartTransferCreateTicket, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SmartTransferApi.createTicket']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Creates new smart transfer ticket term (when the ticket status is DRAFT)
         * @summary Create leg (term)
         * @param {SmartTransferCreateTicketTerm} smartTransferCreateTicketTerm 
         * @param {string} ticketId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTicketTerm(smartTransferCreateTicketTerm: SmartTransferCreateTicketTerm, ticketId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartTransferTicketTermResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTicketTerm(smartTransferCreateTicketTerm, ticketId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SmartTransferApi.createTicketTerm']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Find Smart Transfer ticket by id
         * @summary Search Tickets by ID
         * @param {string} ticketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTicketById(ticketId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartTransferTicketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTicketById(ticketId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SmartTransferApi.findTicketById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Find Smart Transfer ticket term by id
         * @summary Search ticket by leg (term) ID
         * @param {string} ticketId 
         * @param {string} termId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTicketTermById(ticketId: string, termId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartTransferTicketTermResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTicketTermById(ticketId, termId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SmartTransferApi.findTicketTermById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Manually fulfill ticket, in case when all terms (legs) are funded manually
         * @summary Fund ticket manually
         * @param {string} ticketId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fulfillTicket(ticketId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartTransferTicketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fulfillTicket(ticketId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SmartTransferApi.fulfillTicket']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Set funding source for ticket term (in case of ASYNC tickets, this will execute transfer immediately)
         * @summary Define funding source
         * @param {SmartTransferFundTerm} smartTransferFundTerm 
         * @param {string} ticketId 
         * @param {string} termId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fundTicketTerm(smartTransferFundTerm: SmartTransferFundTerm, ticketId: string, termId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartTransferTicketTermResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fundTicketTerm(smartTransferFundTerm, ticketId, termId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SmartTransferApi.fundTicketTerm']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get Smart Transfer user groups
         * @summary Get user group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSmartTransferUserGroups(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartTransferUserGroupsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSmartTransferUserGroups(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SmartTransferApi.getSmartTransferUserGroups']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Manually set ticket term transaction
         * @summary Manually add term transaction
         * @param {SmartTransferManuallyFundTerm} smartTransferManuallyFundTerm 
         * @param {string} ticketId 
         * @param {string} termId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manuallyFundTicketTerm(smartTransferManuallyFundTerm: SmartTransferManuallyFundTerm, ticketId: string, termId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartTransferTicketTermResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.manuallyFundTicketTerm(smartTransferManuallyFundTerm, ticketId, termId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SmartTransferApi.manuallyFundTicketTerm']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete ticket term when ticket is in DRAFT status
         * @summary Delete ticket leg (term)
         * @param {string} ticketId 
         * @param {string} termId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTicketTerm(ticketId: string, termId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTicketTerm(ticketId, termId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SmartTransferApi.removeTicketTerm']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Finds Smart Transfer tickets that match the submitted criteria
         * @summary Find Ticket
         * @param {string} [q] Search string - counterparty name or asset or ticketId. Optional
         * @param {Array<SearchTicketsStatusesEnum>} [statuses] Ticket statuses for Smart Transfer tickets. Optional
         * @param {string} [networkId] NetworkId that is used in the ticket . Optional
         * @param {boolean} [createdByMe] Filter created tickets by created by self or by others. Optional
         * @param {string} [expiresAfter] Lower bound of search range. Optional
         * @param {string} [expiresBefore] Upper bound of search range. Optional
         * @param {SearchTicketsTypeEnum} [type] Type of transfer. ASYNC executes transfers as they are funded, ATOMIC executes all terms (legs) as one atomic transfer
         * @param {string} [externalRefId] External ref. ID that workspace can use to identify ticket outside of Fireblocks system.
         * @param {string} [after] ID of the record after which to fetch $limit records
         * @param {number} [limit] Number of records to fetch. By default, it is 100
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTickets(q?: string, statuses?: Array<SearchTicketsStatusesEnum>, networkId?: string, createdByMe?: boolean, expiresAfter?: string, expiresBefore?: string, type?: SearchTicketsTypeEnum, externalRefId?: string, after?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartTransferTicketFilteredResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTickets(q, statuses, networkId, createdByMe, expiresAfter, expiresBefore, type, externalRefId, after, limit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SmartTransferApi.searchTickets']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Set external id Smart Transfer ticket
         * @summary Add external ref. ID
         * @param {SmartTransferSetTicketExternalId} smartTransferSetTicketExternalId 
         * @param {string} ticketId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setExternalRefId(smartTransferSetTicketExternalId: SmartTransferSetTicketExternalId, ticketId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartTransferTicketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setExternalRefId(smartTransferSetTicketExternalId, ticketId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SmartTransferApi.setExternalRefId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Set expiration date on Smart Transfer ticket
         * @summary Set expiration
         * @param {SmartTransferSetTicketExpiration} smartTransferSetTicketExpiration 
         * @param {string} ticketId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTicketExpiration(smartTransferSetTicketExpiration: SmartTransferSetTicketExpiration, ticketId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartTransferTicketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTicketExpiration(smartTransferSetTicketExpiration, ticketId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SmartTransferApi.setTicketExpiration']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Set Smart Transfer user group
         * @summary Set user group
         * @param {SmartTransferSetUserGroups} smartTransferSetUserGroups 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserGroups(smartTransferSetUserGroups: SmartTransferSetUserGroups, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartTransferUserGroupsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserGroups(smartTransferSetUserGroups, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SmartTransferApi.setUserGroups']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Submit Smart Transfer ticket - change status into ready for approval if auto approval is not turned on, or OPEN if auto approval is on
         * @summary Submit ticket
         * @param {SmartTransferSubmitTicket} smartTransferSubmitTicket 
         * @param {string} ticketId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitTicket(smartTransferSubmitTicket: SmartTransferSubmitTicket, ticketId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartTransferTicketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitTicket(smartTransferSubmitTicket, ticketId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SmartTransferApi.submitTicket']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update ticket term (when ticket status is DRAFT)
         * @summary Update ticket leg (term)
         * @param {SmartTransferUpdateTicketTerm} smartTransferUpdateTicketTerm 
         * @param {string} ticketId 
         * @param {string} termId 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTicketTerm(smartTransferUpdateTicketTerm: SmartTransferUpdateTicketTerm, ticketId: string, termId: string, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartTransferTicketTermResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTicketTerm(smartTransferUpdateTicketTerm, ticketId, termId, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SmartTransferApi.updateTicketTerm']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SmartTransferApi - factory interface
 * @export
 */
export const SmartTransferApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SmartTransferApiFp(configuration)
    return {
        /**
         * Cancel Smart Transfer ticket
         * @summary Cancel Ticket
         * @param {SmartTransferApiCancelTicketRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTicket(requestParameters: SmartTransferApiCancelTicketRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartTransferTicketResponse> {
            return localVarFp.cancelTicket(requestParameters.ticketId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates new Smart Transfer ticket
         * @summary Create Ticket
         * @param {SmartTransferApiCreateTicketRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket(requestParameters: SmartTransferApiCreateTicketRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartTransferTicketResponse> {
            return localVarFp.createTicket(requestParameters.smartTransferCreateTicket, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates new smart transfer ticket term (when the ticket status is DRAFT)
         * @summary Create leg (term)
         * @param {SmartTransferApiCreateTicketTermRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketTerm(requestParameters: SmartTransferApiCreateTicketTermRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartTransferTicketTermResponse> {
            return localVarFp.createTicketTerm(requestParameters.smartTransferCreateTicketTerm, requestParameters.ticketId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Find Smart Transfer ticket by id
         * @summary Search Tickets by ID
         * @param {SmartTransferApiFindTicketByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTicketById(requestParameters: SmartTransferApiFindTicketByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartTransferTicketResponse> {
            return localVarFp.findTicketById(requestParameters.ticketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Find Smart Transfer ticket term by id
         * @summary Search ticket by leg (term) ID
         * @param {SmartTransferApiFindTicketTermByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTicketTermById(requestParameters: SmartTransferApiFindTicketTermByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartTransferTicketTermResponse> {
            return localVarFp.findTicketTermById(requestParameters.ticketId, requestParameters.termId, options).then((request) => request(axios, basePath));
        },
        /**
         * Manually fulfill ticket, in case when all terms (legs) are funded manually
         * @summary Fund ticket manually
         * @param {SmartTransferApiFulfillTicketRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillTicket(requestParameters: SmartTransferApiFulfillTicketRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartTransferTicketResponse> {
            return localVarFp.fulfillTicket(requestParameters.ticketId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Set funding source for ticket term (in case of ASYNC tickets, this will execute transfer immediately)
         * @summary Define funding source
         * @param {SmartTransferApiFundTicketTermRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fundTicketTerm(requestParameters: SmartTransferApiFundTicketTermRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartTransferTicketTermResponse> {
            return localVarFp.fundTicketTerm(requestParameters.smartTransferFundTerm, requestParameters.ticketId, requestParameters.termId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Smart Transfer user groups
         * @summary Get user group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmartTransferUserGroups(options?: RawAxiosRequestConfig): AxiosPromise<SmartTransferUserGroupsResponse> {
            return localVarFp.getSmartTransferUserGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * Manually set ticket term transaction
         * @summary Manually add term transaction
         * @param {SmartTransferApiManuallyFundTicketTermRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manuallyFundTicketTerm(requestParameters: SmartTransferApiManuallyFundTicketTermRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartTransferTicketTermResponse> {
            return localVarFp.manuallyFundTicketTerm(requestParameters.smartTransferManuallyFundTerm, requestParameters.ticketId, requestParameters.termId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete ticket term when ticket is in DRAFT status
         * @summary Delete ticket leg (term)
         * @param {SmartTransferApiRemoveTicketTermRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTicketTerm(requestParameters: SmartTransferApiRemoveTicketTermRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeTicketTerm(requestParameters.ticketId, requestParameters.termId, options).then((request) => request(axios, basePath));
        },
        /**
         * Finds Smart Transfer tickets that match the submitted criteria
         * @summary Find Ticket
         * @param {SmartTransferApiSearchTicketsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTickets(requestParameters: SmartTransferApiSearchTicketsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<SmartTransferTicketFilteredResponse> {
            return localVarFp.searchTickets(requestParameters.q, requestParameters.statuses, requestParameters.networkId, requestParameters.createdByMe, requestParameters.expiresAfter, requestParameters.expiresBefore, requestParameters.type, requestParameters.externalRefId, requestParameters.after, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Set external id Smart Transfer ticket
         * @summary Add external ref. ID
         * @param {SmartTransferApiSetExternalRefIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalRefId(requestParameters: SmartTransferApiSetExternalRefIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartTransferTicketResponse> {
            return localVarFp.setExternalRefId(requestParameters.smartTransferSetTicketExternalId, requestParameters.ticketId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Set expiration date on Smart Transfer ticket
         * @summary Set expiration
         * @param {SmartTransferApiSetTicketExpirationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTicketExpiration(requestParameters: SmartTransferApiSetTicketExpirationRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartTransferTicketResponse> {
            return localVarFp.setTicketExpiration(requestParameters.smartTransferSetTicketExpiration, requestParameters.ticketId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Set Smart Transfer user group
         * @summary Set user group
         * @param {SmartTransferApiSetUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserGroups(requestParameters: SmartTransferApiSetUserGroupsRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartTransferUserGroupsResponse> {
            return localVarFp.setUserGroups(requestParameters.smartTransferSetUserGroups, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit Smart Transfer ticket - change status into ready for approval if auto approval is not turned on, or OPEN if auto approval is on
         * @summary Submit ticket
         * @param {SmartTransferApiSubmitTicketRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTicket(requestParameters: SmartTransferApiSubmitTicketRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartTransferTicketResponse> {
            return localVarFp.submitTicket(requestParameters.smartTransferSubmitTicket, requestParameters.ticketId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Update ticket term (when ticket status is DRAFT)
         * @summary Update ticket leg (term)
         * @param {SmartTransferApiUpdateTicketTermRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicketTerm(requestParameters: SmartTransferApiUpdateTicketTermRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartTransferTicketTermResponse> {
            return localVarFp.updateTicketTerm(requestParameters.smartTransferUpdateTicketTerm, requestParameters.ticketId, requestParameters.termId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelTicket operation in SmartTransferApi.
 * @export
 * @interface SmartTransferApiCancelTicketRequest
 */
export interface SmartTransferApiCancelTicketRequest {
    /**
     * 
     * @type {string}
     * @memberof SmartTransferApiCancelTicket
     */
    readonly ticketId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof SmartTransferApiCancelTicket
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for createTicket operation in SmartTransferApi.
 * @export
 * @interface SmartTransferApiCreateTicketRequest
 */
export interface SmartTransferApiCreateTicketRequest {
    /**
     * 
     * @type {SmartTransferCreateTicket}
     * @memberof SmartTransferApiCreateTicket
     */
    readonly smartTransferCreateTicket: SmartTransferCreateTicket

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof SmartTransferApiCreateTicket
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for createTicketTerm operation in SmartTransferApi.
 * @export
 * @interface SmartTransferApiCreateTicketTermRequest
 */
export interface SmartTransferApiCreateTicketTermRequest {
    /**
     * 
     * @type {SmartTransferCreateTicketTerm}
     * @memberof SmartTransferApiCreateTicketTerm
     */
    readonly smartTransferCreateTicketTerm: SmartTransferCreateTicketTerm

    /**
     * 
     * @type {string}
     * @memberof SmartTransferApiCreateTicketTerm
     */
    readonly ticketId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof SmartTransferApiCreateTicketTerm
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for findTicketById operation in SmartTransferApi.
 * @export
 * @interface SmartTransferApiFindTicketByIdRequest
 */
export interface SmartTransferApiFindTicketByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof SmartTransferApiFindTicketById
     */
    readonly ticketId: string
}

/**
 * Request parameters for findTicketTermById operation in SmartTransferApi.
 * @export
 * @interface SmartTransferApiFindTicketTermByIdRequest
 */
export interface SmartTransferApiFindTicketTermByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof SmartTransferApiFindTicketTermById
     */
    readonly ticketId: string

    /**
     * 
     * @type {string}
     * @memberof SmartTransferApiFindTicketTermById
     */
    readonly termId: string
}

/**
 * Request parameters for fulfillTicket operation in SmartTransferApi.
 * @export
 * @interface SmartTransferApiFulfillTicketRequest
 */
export interface SmartTransferApiFulfillTicketRequest {
    /**
     * 
     * @type {string}
     * @memberof SmartTransferApiFulfillTicket
     */
    readonly ticketId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof SmartTransferApiFulfillTicket
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for fundTicketTerm operation in SmartTransferApi.
 * @export
 * @interface SmartTransferApiFundTicketTermRequest
 */
export interface SmartTransferApiFundTicketTermRequest {
    /**
     * 
     * @type {SmartTransferFundTerm}
     * @memberof SmartTransferApiFundTicketTerm
     */
    readonly smartTransferFundTerm: SmartTransferFundTerm

    /**
     * 
     * @type {string}
     * @memberof SmartTransferApiFundTicketTerm
     */
    readonly ticketId: string

    /**
     * 
     * @type {string}
     * @memberof SmartTransferApiFundTicketTerm
     */
    readonly termId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof SmartTransferApiFundTicketTerm
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for manuallyFundTicketTerm operation in SmartTransferApi.
 * @export
 * @interface SmartTransferApiManuallyFundTicketTermRequest
 */
export interface SmartTransferApiManuallyFundTicketTermRequest {
    /**
     * 
     * @type {SmartTransferManuallyFundTerm}
     * @memberof SmartTransferApiManuallyFundTicketTerm
     */
    readonly smartTransferManuallyFundTerm: SmartTransferManuallyFundTerm

    /**
     * 
     * @type {string}
     * @memberof SmartTransferApiManuallyFundTicketTerm
     */
    readonly ticketId: string

    /**
     * 
     * @type {string}
     * @memberof SmartTransferApiManuallyFundTicketTerm
     */
    readonly termId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof SmartTransferApiManuallyFundTicketTerm
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for removeTicketTerm operation in SmartTransferApi.
 * @export
 * @interface SmartTransferApiRemoveTicketTermRequest
 */
export interface SmartTransferApiRemoveTicketTermRequest {
    /**
     * 
     * @type {string}
     * @memberof SmartTransferApiRemoveTicketTerm
     */
    readonly ticketId: string

    /**
     * 
     * @type {string}
     * @memberof SmartTransferApiRemoveTicketTerm
     */
    readonly termId: string
}

/**
 * Request parameters for searchTickets operation in SmartTransferApi.
 * @export
 * @interface SmartTransferApiSearchTicketsRequest
 */
export interface SmartTransferApiSearchTicketsRequest {
    /**
     * Search string - counterparty name or asset or ticketId. Optional
     * @type {string}
     * @memberof SmartTransferApiSearchTickets
     */
    readonly q?: string

    /**
     * Ticket statuses for Smart Transfer tickets. Optional
     * @type {Array<'DRAFT' | 'PENDING_APPROVAL' | 'OPEN' | 'IN_SETTLEMENT' | 'FULFILLED' | 'EXPIRED' | 'CANCELED'>}
     * @memberof SmartTransferApiSearchTickets
     */
    readonly statuses?: Array<SearchTicketsStatusesEnum>

    /**
     * NetworkId that is used in the ticket . Optional
     * @type {string}
     * @memberof SmartTransferApiSearchTickets
     */
    readonly networkId?: string

    /**
     * Filter created tickets by created by self or by others. Optional
     * @type {boolean}
     * @memberof SmartTransferApiSearchTickets
     */
    readonly createdByMe?: boolean

    /**
     * Lower bound of search range. Optional
     * @type {string}
     * @memberof SmartTransferApiSearchTickets
     */
    readonly expiresAfter?: string

    /**
     * Upper bound of search range. Optional
     * @type {string}
     * @memberof SmartTransferApiSearchTickets
     */
    readonly expiresBefore?: string

    /**
     * Type of transfer. ASYNC executes transfers as they are funded, ATOMIC executes all terms (legs) as one atomic transfer
     * @type {'ASYNC'}
     * @memberof SmartTransferApiSearchTickets
     */
    readonly type?: SearchTicketsTypeEnum

    /**
     * External ref. ID that workspace can use to identify ticket outside of Fireblocks system.
     * @type {string}
     * @memberof SmartTransferApiSearchTickets
     */
    readonly externalRefId?: string

    /**
     * ID of the record after which to fetch $limit records
     * @type {string}
     * @memberof SmartTransferApiSearchTickets
     */
    readonly after?: string

    /**
     * Number of records to fetch. By default, it is 100
     * @type {number}
     * @memberof SmartTransferApiSearchTickets
     */
    readonly limit?: number
}

/**
 * Request parameters for setExternalRefId operation in SmartTransferApi.
 * @export
 * @interface SmartTransferApiSetExternalRefIdRequest
 */
export interface SmartTransferApiSetExternalRefIdRequest {
    /**
     * 
     * @type {SmartTransferSetTicketExternalId}
     * @memberof SmartTransferApiSetExternalRefId
     */
    readonly smartTransferSetTicketExternalId: SmartTransferSetTicketExternalId

    /**
     * 
     * @type {string}
     * @memberof SmartTransferApiSetExternalRefId
     */
    readonly ticketId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof SmartTransferApiSetExternalRefId
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for setTicketExpiration operation in SmartTransferApi.
 * @export
 * @interface SmartTransferApiSetTicketExpirationRequest
 */
export interface SmartTransferApiSetTicketExpirationRequest {
    /**
     * 
     * @type {SmartTransferSetTicketExpiration}
     * @memberof SmartTransferApiSetTicketExpiration
     */
    readonly smartTransferSetTicketExpiration: SmartTransferSetTicketExpiration

    /**
     * 
     * @type {string}
     * @memberof SmartTransferApiSetTicketExpiration
     */
    readonly ticketId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof SmartTransferApiSetTicketExpiration
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for setUserGroups operation in SmartTransferApi.
 * @export
 * @interface SmartTransferApiSetUserGroupsRequest
 */
export interface SmartTransferApiSetUserGroupsRequest {
    /**
     * 
     * @type {SmartTransferSetUserGroups}
     * @memberof SmartTransferApiSetUserGroups
     */
    readonly smartTransferSetUserGroups: SmartTransferSetUserGroups

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof SmartTransferApiSetUserGroups
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for submitTicket operation in SmartTransferApi.
 * @export
 * @interface SmartTransferApiSubmitTicketRequest
 */
export interface SmartTransferApiSubmitTicketRequest {
    /**
     * 
     * @type {SmartTransferSubmitTicket}
     * @memberof SmartTransferApiSubmitTicket
     */
    readonly smartTransferSubmitTicket: SmartTransferSubmitTicket

    /**
     * 
     * @type {string}
     * @memberof SmartTransferApiSubmitTicket
     */
    readonly ticketId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof SmartTransferApiSubmitTicket
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for updateTicketTerm operation in SmartTransferApi.
 * @export
 * @interface SmartTransferApiUpdateTicketTermRequest
 */
export interface SmartTransferApiUpdateTicketTermRequest {
    /**
     * 
     * @type {SmartTransferUpdateTicketTerm}
     * @memberof SmartTransferApiUpdateTicketTerm
     */
    readonly smartTransferUpdateTicketTerm: SmartTransferUpdateTicketTerm

    /**
     * 
     * @type {string}
     * @memberof SmartTransferApiUpdateTicketTerm
     */
    readonly ticketId: string

    /**
     * 
     * @type {string}
     * @memberof SmartTransferApiUpdateTicketTerm
     */
    readonly termId: string

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof SmartTransferApiUpdateTicketTerm
     */
    readonly idempotencyKey?: string
}

/**
 * SmartTransferApi - object-oriented interface
 * @export
 * @class SmartTransferApi
 * @extends {BaseAPI}
 */
export class SmartTransferApi extends BaseAPI {
    /**
     * Cancel Smart Transfer ticket
     * @summary Cancel Ticket
     * @param {SmartTransferApiCancelTicketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    public cancelTicket(requestParameters: SmartTransferApiCancelTicketRequest) {
        return SmartTransferApiFp(this.configuration).cancelTicket(requestParameters.ticketId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Creates new Smart Transfer ticket
     * @summary Create Ticket
     * @param {SmartTransferApiCreateTicketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    public createTicket(requestParameters: SmartTransferApiCreateTicketRequest) {
        return SmartTransferApiFp(this.configuration).createTicket(requestParameters.smartTransferCreateTicket, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Creates new smart transfer ticket term (when the ticket status is DRAFT)
     * @summary Create leg (term)
     * @param {SmartTransferApiCreateTicketTermRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    public createTicketTerm(requestParameters: SmartTransferApiCreateTicketTermRequest) {
        return SmartTransferApiFp(this.configuration).createTicketTerm(requestParameters.smartTransferCreateTicketTerm, requestParameters.ticketId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Find Smart Transfer ticket by id
     * @summary Search Tickets by ID
     * @param {SmartTransferApiFindTicketByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    public findTicketById(requestParameters: SmartTransferApiFindTicketByIdRequest) {
        return SmartTransferApiFp(this.configuration).findTicketById(requestParameters.ticketId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Find Smart Transfer ticket term by id
     * @summary Search ticket by leg (term) ID
     * @param {SmartTransferApiFindTicketTermByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    public findTicketTermById(requestParameters: SmartTransferApiFindTicketTermByIdRequest) {
        return SmartTransferApiFp(this.configuration).findTicketTermById(requestParameters.ticketId, requestParameters.termId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Manually fulfill ticket, in case when all terms (legs) are funded manually
     * @summary Fund ticket manually
     * @param {SmartTransferApiFulfillTicketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    public fulfillTicket(requestParameters: SmartTransferApiFulfillTicketRequest) {
        return SmartTransferApiFp(this.configuration).fulfillTicket(requestParameters.ticketId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Set funding source for ticket term (in case of ASYNC tickets, this will execute transfer immediately)
     * @summary Define funding source
     * @param {SmartTransferApiFundTicketTermRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    public fundTicketTerm(requestParameters: SmartTransferApiFundTicketTermRequest) {
        return SmartTransferApiFp(this.configuration).fundTicketTerm(requestParameters.smartTransferFundTerm, requestParameters.ticketId, requestParameters.termId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Get Smart Transfer user groups
     * @summary Get user group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    public getSmartTransferUserGroups() {
        return SmartTransferApiFp(this.configuration).getSmartTransferUserGroups().then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Manually set ticket term transaction
     * @summary Manually add term transaction
     * @param {SmartTransferApiManuallyFundTicketTermRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    public manuallyFundTicketTerm(requestParameters: SmartTransferApiManuallyFundTicketTermRequest) {
        return SmartTransferApiFp(this.configuration).manuallyFundTicketTerm(requestParameters.smartTransferManuallyFundTerm, requestParameters.ticketId, requestParameters.termId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Delete ticket term when ticket is in DRAFT status
     * @summary Delete ticket leg (term)
     * @param {SmartTransferApiRemoveTicketTermRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    public removeTicketTerm(requestParameters: SmartTransferApiRemoveTicketTermRequest) {
        return SmartTransferApiFp(this.configuration).removeTicketTerm(requestParameters.ticketId, requestParameters.termId).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Finds Smart Transfer tickets that match the submitted criteria
     * @summary Find Ticket
     * @param {SmartTransferApiSearchTicketsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    public searchTickets(requestParameters: SmartTransferApiSearchTicketsRequest = {}) {
        return SmartTransferApiFp(this.configuration).searchTickets(requestParameters.q, requestParameters.statuses, requestParameters.networkId, requestParameters.createdByMe, requestParameters.expiresAfter, requestParameters.expiresBefore, requestParameters.type, requestParameters.externalRefId, requestParameters.after, requestParameters.limit).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Set external id Smart Transfer ticket
     * @summary Add external ref. ID
     * @param {SmartTransferApiSetExternalRefIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    public setExternalRefId(requestParameters: SmartTransferApiSetExternalRefIdRequest) {
        return SmartTransferApiFp(this.configuration).setExternalRefId(requestParameters.smartTransferSetTicketExternalId, requestParameters.ticketId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Set expiration date on Smart Transfer ticket
     * @summary Set expiration
     * @param {SmartTransferApiSetTicketExpirationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    public setTicketExpiration(requestParameters: SmartTransferApiSetTicketExpirationRequest) {
        return SmartTransferApiFp(this.configuration).setTicketExpiration(requestParameters.smartTransferSetTicketExpiration, requestParameters.ticketId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Set Smart Transfer user group
     * @summary Set user group
     * @param {SmartTransferApiSetUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    public setUserGroups(requestParameters: SmartTransferApiSetUserGroupsRequest) {
        return SmartTransferApiFp(this.configuration).setUserGroups(requestParameters.smartTransferSetUserGroups, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Submit Smart Transfer ticket - change status into ready for approval if auto approval is not turned on, or OPEN if auto approval is on
     * @summary Submit ticket
     * @param {SmartTransferApiSubmitTicketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    public submitTicket(requestParameters: SmartTransferApiSubmitTicketRequest) {
        return SmartTransferApiFp(this.configuration).submitTicket(requestParameters.smartTransferSubmitTicket, requestParameters.ticketId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Update ticket term (when ticket status is DRAFT)
     * @summary Update ticket leg (term)
     * @param {SmartTransferApiUpdateTicketTermRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    public updateTicketTerm(requestParameters: SmartTransferApiUpdateTicketTermRequest) {
        return SmartTransferApiFp(this.configuration).updateTicketTerm(requestParameters.smartTransferUpdateTicketTerm, requestParameters.ticketId, requestParameters.termId, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }
}

/**
 * @export
 */
export const SearchTicketsStatusesEnum = {
    Draft: 'DRAFT',
    PendingApproval: 'PENDING_APPROVAL',
    Open: 'OPEN',
    InSettlement: 'IN_SETTLEMENT',
    Fulfilled: 'FULFILLED',
    Expired: 'EXPIRED',
    Canceled: 'CANCELED'
} as const;
export type SearchTicketsStatusesEnum = typeof SearchTicketsStatusesEnum[keyof typeof SearchTicketsStatusesEnum];
/**
 * @export
 */
export const SearchTicketsTypeEnum = {
    Async: 'ASYNC'
} as const;
export type SearchTicketsTypeEnum = typeof SearchTicketsTypeEnum[keyof typeof SearchTicketsTypeEnum];
