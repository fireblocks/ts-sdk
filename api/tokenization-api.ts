/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import { convertToFireblocksResponse } from "../response/fireblocksResponse";
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import { assertParamExistsAndNotEmpty } from '../utils/validation_utils';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { AssetAlreadyExistHttpError } from '../models';
// @ts-ignore
import { AssetDoesNotExistHttpError } from '../models';
// @ts-ignore
import { CreateTokenRequestDto } from '../models';
// @ts-ignore
import { ErrorSchema } from '../models';
// @ts-ignore
import { NotFoundException } from '../models';
// @ts-ignore
import { TokenLinkDto } from '../models';
// @ts-ignore
import { TokenLinkExistsHttpError } from '../models';
// @ts-ignore
import { TokenLinkRequestDto } from '../models';
// @ts-ignore
import { TokensPaginatedResponse } from '../models';
/**
 * TokenizationApi - axios parameter creator
 * @export
 */
export const TokenizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a linked token, with its status and metadata.
         * @summary Return a linked token
         * @param {string} id The token link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedToken: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('getLinkedToken', 'id', id)
            const localVarPath = `/tokenization/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return all linked tokens (paginated)
         * @summary List all linked tokens
         * @param {string} [pageCursor] Page cursor to get the next page
         * @param {number} [pageSize] Number of items per page, requesting more then max will return max items
         * @param {any} [status] A comma separated list of statuses to filter. Default is \&quot;COMPLETED\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedTokens: async (pageCursor?: string, pageSize?: number, status?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokenization/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (status !== undefined) {
                for (const [key, value] of Object.entries(status)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Facilitates the creation of a new token, supporting both EVM-based and Stellar/Ripple platforms. For EVM, it deploys the corresponding contract template to the blockchain and links the token to the workspace. For Stellar/Ripple, it links a newly created token directly to the workspace without deploying a contract. Returns the token link with status \"PENDING\" until the token is deployed or \"SUCCESS\" if no deployment is needed.
         * @summary Issue a new token
         * @param {CreateTokenRequestDto} createTokenRequestDto 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueNewToken: async (createTokenRequestDto: CreateTokenRequestDto, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('issueNewToken', 'createTokenRequestDto', createTokenRequestDto)
            const localVarPath = `/tokenization/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTokenRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Link an already existing token (by assetId, collectionId or contractId as refId) to a workspace across EVM, Stellar, or Ripple platforms. The token will be linked to the workspace if it does not already exist.
         * @summary Link a token
         * @param {TokenLinkRequestDto} tokenLinkRequestDto 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        link: async (tokenLinkRequestDto: TokenLinkRequestDto, idempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExists('link', 'tokenLinkRequestDto', tokenLinkRequestDto)
            const localVarPath = `/tokenization/tokens/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenLinkRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlink a token. The token will be unlinked from the workspace. The token will not be deleted on chain nor the refId, only the link to the workspace will be removed.
         * @summary Unlink a token
         * @param {string} id The token link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlink: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            assertParamExistsAndNotEmpty('unlink', 'id', id)
            const localVarPath = `/tokenization/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenizationApi - functional programming interface
 * @export
 */
export const TokenizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Return a linked token, with its status and metadata.
         * @summary Return a linked token
         * @param {string} id The token link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkedToken(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenLinkDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkedToken(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenizationApi.getLinkedToken']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return all linked tokens (paginated)
         * @summary List all linked tokens
         * @param {string} [pageCursor] Page cursor to get the next page
         * @param {number} [pageSize] Number of items per page, requesting more then max will return max items
         * @param {any} [status] A comma separated list of statuses to filter. Default is \&quot;COMPLETED\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkedTokens(pageCursor?: string, pageSize?: number, status?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensPaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkedTokens(pageCursor, pageSize, status, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenizationApi.getLinkedTokens']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Facilitates the creation of a new token, supporting both EVM-based and Stellar/Ripple platforms. For EVM, it deploys the corresponding contract template to the blockchain and links the token to the workspace. For Stellar/Ripple, it links a newly created token directly to the workspace without deploying a contract. Returns the token link with status \"PENDING\" until the token is deployed or \"SUCCESS\" if no deployment is needed.
         * @summary Issue a new token
         * @param {CreateTokenRequestDto} createTokenRequestDto 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueNewToken(createTokenRequestDto: CreateTokenRequestDto, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenLinkDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueNewToken(createTokenRequestDto, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenizationApi.issueNewToken']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Link an already existing token (by assetId, collectionId or contractId as refId) to a workspace across EVM, Stellar, or Ripple platforms. The token will be linked to the workspace if it does not already exist.
         * @summary Link a token
         * @param {TokenLinkRequestDto} tokenLinkRequestDto 
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async link(tokenLinkRequestDto: TokenLinkRequestDto, idempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenLinkDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.link(tokenLinkRequestDto, idempotencyKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenizationApi.link']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Unlink a token. The token will be unlinked from the workspace. The token will not be deleted on chain nor the refId, only the link to the workspace will be removed.
         * @summary Unlink a token
         * @param {string} id The token link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlink(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlink(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TokenizationApi.unlink']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TokenizationApi - factory interface
 * @export
 */
export const TokenizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenizationApiFp(configuration)
    return {
        /**
         * Return a linked token, with its status and metadata.
         * @summary Return a linked token
         * @param {TokenizationApiGetLinkedTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedToken(requestParameters: TokenizationApiGetLinkedTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenLinkDto> {
            return localVarFp.getLinkedToken(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Return all linked tokens (paginated)
         * @summary List all linked tokens
         * @param {TokenizationApiGetLinkedTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedTokens(requestParameters: TokenizationApiGetLinkedTokensRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<TokensPaginatedResponse> {
            return localVarFp.getLinkedTokens(requestParameters.pageCursor, requestParameters.pageSize, requestParameters.status, options).then((request) => request(axios, basePath));
        },
        /**
         * Facilitates the creation of a new token, supporting both EVM-based and Stellar/Ripple platforms. For EVM, it deploys the corresponding contract template to the blockchain and links the token to the workspace. For Stellar/Ripple, it links a newly created token directly to the workspace without deploying a contract. Returns the token link with status \"PENDING\" until the token is deployed or \"SUCCESS\" if no deployment is needed.
         * @summary Issue a new token
         * @param {TokenizationApiIssueNewTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueNewToken(requestParameters: TokenizationApiIssueNewTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenLinkDto> {
            return localVarFp.issueNewToken(requestParameters.createTokenRequestDto, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Link an already existing token (by assetId, collectionId or contractId as refId) to a workspace across EVM, Stellar, or Ripple platforms. The token will be linked to the workspace if it does not already exist.
         * @summary Link a token
         * @param {TokenizationApiLinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        link(requestParameters: TokenizationApiLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenLinkDto> {
            return localVarFp.link(requestParameters.tokenLinkRequestDto, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlink a token. The token will be unlinked from the workspace. The token will not be deleted on chain nor the refId, only the link to the workspace will be removed.
         * @summary Unlink a token
         * @param {TokenizationApiUnlinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlink(requestParameters: TokenizationApiUnlinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unlink(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getLinkedToken operation in TokenizationApi.
 * @export
 * @interface TokenizationApiGetLinkedTokenRequest
 */
export interface TokenizationApiGetLinkedTokenRequest {
    /**
     * The token link id
     * @type {string}
     * @memberof TokenizationApiGetLinkedToken
     */
    readonly id: string
}

/**
 * Request parameters for getLinkedTokens operation in TokenizationApi.
 * @export
 * @interface TokenizationApiGetLinkedTokensRequest
 */
export interface TokenizationApiGetLinkedTokensRequest {
    /**
     * Page cursor to get the next page
     * @type {string}
     * @memberof TokenizationApiGetLinkedTokens
     */
    readonly pageCursor?: string

    /**
     * Number of items per page, requesting more then max will return max items
     * @type {number}
     * @memberof TokenizationApiGetLinkedTokens
     */
    readonly pageSize?: number

    /**
     * A comma separated list of statuses to filter. Default is \&quot;COMPLETED\&quot;
     * @type {any}
     * @memberof TokenizationApiGetLinkedTokens
     */
    readonly status?: any
}

/**
 * Request parameters for issueNewToken operation in TokenizationApi.
 * @export
 * @interface TokenizationApiIssueNewTokenRequest
 */
export interface TokenizationApiIssueNewTokenRequest {
    /**
     * 
     * @type {CreateTokenRequestDto}
     * @memberof TokenizationApiIssueNewToken
     */
    readonly createTokenRequestDto: CreateTokenRequestDto

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof TokenizationApiIssueNewToken
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for link operation in TokenizationApi.
 * @export
 * @interface TokenizationApiLinkRequest
 */
export interface TokenizationApiLinkRequest {
    /**
     * 
     * @type {TokenLinkRequestDto}
     * @memberof TokenizationApiLink
     */
    readonly tokenLinkRequestDto: TokenLinkRequestDto

    /**
     * A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
     * @type {string}
     * @memberof TokenizationApiLink
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for unlink operation in TokenizationApi.
 * @export
 * @interface TokenizationApiUnlinkRequest
 */
export interface TokenizationApiUnlinkRequest {
    /**
     * The token link id
     * @type {string}
     * @memberof TokenizationApiUnlink
     */
    readonly id: string
}

/**
 * TokenizationApi - object-oriented interface
 * @export
 * @class TokenizationApi
 * @extends {BaseAPI}
 */
export class TokenizationApi extends BaseAPI {
    /**
     * Return a linked token, with its status and metadata.
     * @summary Return a linked token
     * @param {TokenizationApiGetLinkedTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenizationApi
     */
    public getLinkedToken(requestParameters: TokenizationApiGetLinkedTokenRequest) {
        return TokenizationApiFp(this.configuration).getLinkedToken(requestParameters.id).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Return all linked tokens (paginated)
     * @summary List all linked tokens
     * @param {TokenizationApiGetLinkedTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenizationApi
     */
    public getLinkedTokens(requestParameters: TokenizationApiGetLinkedTokensRequest = {}) {
        return TokenizationApiFp(this.configuration).getLinkedTokens(requestParameters.pageCursor, requestParameters.pageSize, requestParameters.status).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Facilitates the creation of a new token, supporting both EVM-based and Stellar/Ripple platforms. For EVM, it deploys the corresponding contract template to the blockchain and links the token to the workspace. For Stellar/Ripple, it links a newly created token directly to the workspace without deploying a contract. Returns the token link with status \"PENDING\" until the token is deployed or \"SUCCESS\" if no deployment is needed.
     * @summary Issue a new token
     * @param {TokenizationApiIssueNewTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenizationApi
     */
    public issueNewToken(requestParameters: TokenizationApiIssueNewTokenRequest) {
        return TokenizationApiFp(this.configuration).issueNewToken(requestParameters.createTokenRequestDto, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Link an already existing token (by assetId, collectionId or contractId as refId) to a workspace across EVM, Stellar, or Ripple platforms. The token will be linked to the workspace if it does not already exist.
     * @summary Link a token
     * @param {TokenizationApiLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenizationApi
     */
    public link(requestParameters: TokenizationApiLinkRequest) {
        return TokenizationApiFp(this.configuration).link(requestParameters.tokenLinkRequestDto, requestParameters.idempotencyKey).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }

    /**
     * Unlink a token. The token will be unlinked from the workspace. The token will not be deleted on chain nor the refId, only the link to the workspace will be removed.
     * @summary Unlink a token
     * @param {TokenizationApiUnlinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenizationApi
     */
    public unlink(requestParameters: TokenizationApiUnlinkRequest) {
        return TokenizationApiFp(this.configuration).unlink(requestParameters.id).then((request) => request(this.axios, this.basePath)).then(convertToFireblocksResponse);
    }
}

