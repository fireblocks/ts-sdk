/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import {HttpClient} from "./utils/http-client";
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists,  setSearchParams, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddAssetToContractRequest
 */
export interface AddAssetToContractRequest {
    /**
     * The contract\'s address (or xpub) of the wallet
     * @type {string}
     * @memberof AddAssetToContractRequest
     */
    'address': string;
    /**
     * The destination tag, for XRP wallets
     * @type {string}
     * @memberof AddAssetToContractRequest
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface AddAssetToExternalWalletRequest
 */
export interface AddAssetToExternalWalletRequest {
    /**
     * The wallet\'s address (or xpub) of the wallet
     * @type {string}
     * @memberof AddAssetToExternalWalletRequest
     */
    'address': string;
    /**
     * For XRP wallets, the destination tag; for EOS/XLM, the memo; for the fiat providers (BLINC by BCB Group), the Bank Transfer Description
     * @type {string}
     * @memberof AddAssetToExternalWalletRequest
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface AddCollateralRequestBody
 */
export interface AddCollateralRequestBody {
    /**
     * 
     * @type {TransactionRequest}
     * @memberof AddCollateralRequestBody
     */
    'transactionRequest'?: TransactionRequest;
    /**
     * optional
     * @type {boolean}
     * @memberof AddCollateralRequestBody
     */
    'isSrcCollateral'?: boolean;
}
/**
 * The result of the AML screening.
 * @export
 * @interface AmlScreeningResult
 */
export interface AmlScreeningResult {
    /**
     * 
     * @type {string}
     * @memberof AmlScreeningResult
     */
    'provider'?: string;
    /**
     * 
     * @type {object}
     * @memberof AmlScreeningResult
     */
    'payload'?: object;
}
/**
 * The details of the requested amount to transfer.
 * @export
 * @interface AmountInfo
 */
export interface AmountInfo {
    /**
     * If the transfer is a withdrawal from an exchange, the actual amount that was requested to be transferred. Otherwise, the requested amount
     * @type {string}
     * @memberof AmountInfo
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof AmountInfo
     */
    'requestedAmount'?: string;
    /**
     * The net amount of the transaction, after fee deduction
     * @type {string}
     * @memberof AmountInfo
     */
    'netAmount'?: string;
    /**
     * The USD value of the requested amount
     * @type {string}
     * @memberof AmountInfo
     */
    'amountUSD'?: string;
}
/**
 * 
 * @export
 * @interface AssetTypeResponse
 */
export interface AssetTypeResponse {
    /**
     * 
     * @type {string}
     * @memberof AssetTypeResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AssetTypeResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AssetTypeResponse
     */
    'type': AssetTypeResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AssetTypeResponse
     */
    'contractAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetTypeResponse
     */
    'nativeAsset'?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetTypeResponse
     */
    'decimals'?: number;
}

export const AssetTypeResponseTypeEnum = {
    AlgoAsset: 'ALGO_ASSET',
    BaseAsset: 'BASE_ASSET',
    Bep20: 'BEP20',
    Compound: 'COMPOUND',
    Erc20: 'ERC20',
    Fiat: 'FIAT',
    SolAsset: 'SOL_ASSET',
    TronTrc20: 'TRON_TRC20',
    XlmAsset: 'XLM_ASSET',
    XdbAsset: 'XDB_ASSET'
} as const;

export type AssetTypeResponseTypeEnum = typeof AssetTypeResponseTypeEnum[keyof typeof AssetTypeResponseTypeEnum];

/**
 * 
 * @export
 * @interface AssetWallet
 */
export interface AssetWallet {
    /**
     * ID of the vault account. You can [get the vault account by this ID](https://developers.fireblocks.com/reference/get_vault-accounts-vaultaccountid) to retrieve vault properties such as its name, auto fueling, hidden on UI or customer reference ID.
     * @type {string}
     * @memberof AssetWallet
     */
    'vaultId'?: string;
    /**
     * ID of the asset. You can get more information about this asset by using the [supported assets API](https://developers.fireblocks.com/reference/get_supported-assets)
     * @type {string}
     * @memberof AssetWallet
     */
    'assetId'?: string;
    /**
     * Available balance, available to use in a transaction.
     * @type {string}
     * @memberof AssetWallet
     */
    'available'?: string;
    /**
     * Total balance at the asset wallet, as seen at the blockchain explorers. This includes balance available, and any kind of unavailable balance such as locked, frozen, or others.
     * @type {string}
     * @memberof AssetWallet
     */
    'total'?: string;
    /**
     * Pending balance.
     * @type {string}
     * @memberof AssetWallet
     */
    'pending'?: string;
    /**
     * Staked balance.
     * @type {string}
     * @memberof AssetWallet
     */
    'staked'?: string;
    /**
     * Funds frozen due to the anti-money laundering policy at this workspace.
     * @type {string}
     * @memberof AssetWallet
     */
    'frozen'?: string;
    /**
     * Locked balance.
     * @type {string}
     * @memberof AssetWallet
     */
    'lockedAmount'?: string;
    /**
     * The height (number) of the block of the balance. Can by empty.
     * @type {string}
     * @memberof AssetWallet
     */
    'blockHeight'?: string;
    /**
     * The hash of the block of the balance. Can by empty.
     * @type {string}
     * @memberof AssetWallet
     */
    'blockHash'?: string;
    /**
     * Unix timestamp of the time the asset wallet was created.
     * @type {string}
     * @memberof AssetWallet
     */
    'creationTimestamp'?: string;
}
/**
 * 
 * @export
 * @interface AuthorizationGroups
 */
export interface AuthorizationGroups {
    /**
     * 
     * @type {number}
     * @memberof AuthorizationGroups
     */
    'th'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AuthorizationGroups
     */
    'users'?: { [key: string]: string; };
}

export const AuthorizationGroupsUsersEnum = {
    PendingAuthorization: 'PENDING_AUTHORIZATION',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Na: 'NA'
} as const;

export type AuthorizationGroupsUsersEnum = typeof AuthorizationGroupsUsersEnum[keyof typeof AuthorizationGroupsUsersEnum];

/**
 * The information about your [Transaction Authorization Policy (TAP).](https://developers.fireblocks.com/docs/capabilities#transaction-authorization-policy-tap)
 * @export
 * @interface AuthorizationInfo
 */
export interface AuthorizationInfo {
    /**
     * 
     * @type {boolean}
     * @memberof AuthorizationInfo
     */
    'allowOperatorAsAuthorizer'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationInfo
     */
    'logic'?: AuthorizationInfoLogicEnum;
    /**
     * 
     * @type {Array<AuthorizationGroups>}
     * @memberof AuthorizationInfo
     */
    'groups'?: Array<AuthorizationGroups>;
}

export const AuthorizationInfoLogicEnum = {
    And: 'AND',
    Or: 'OR'
} as const;

export type AuthorizationInfoLogicEnum = typeof AuthorizationInfoLogicEnum[keyof typeof AuthorizationInfoLogicEnum];

/**
 * The block hash and height of the block that this transaction was mined in.      **Note**: If an outgoing transaction uses the destinations object with more than one value in the array, blockHash is set to null.
 * @export
 * @interface BlockInfo
 */
export interface BlockInfo {
    /**
     * 
     * @type {string}
     * @memberof BlockInfo
     */
    'blockHeight'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockInfo
     */
    'blockHash'?: string;
}
/**
 * 
 * @export
 * @interface CancelTransactionResponse
 */
export interface CancelTransactionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CancelTransactionResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface CheckThirdPartyRoutingForNetworkConnection200Response
 */
export interface CheckThirdPartyRoutingForNetworkConnection200Response {
    /**
     * 
     * @type {boolean}
     * @memberof CheckThirdPartyRoutingForNetworkConnection200Response
     */
    'isThirdPartyRouting'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CheckThirdPartyRoutingForNetworkConnection200Response
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ConfigChangeRequestStatus = {
    WaitingForApproval: 'WAITING_FOR_APPROVAL',
    Approved: 'APPROVED',
    Cancelled: 'CANCELLED',
    Rejected: 'REJECTED',
    Failed: 'FAILED'
} as const;

export type ConfigChangeRequestStatus = typeof ConfigChangeRequestStatus[keyof typeof ConfigChangeRequestStatus];


/**
 * 
 * @export
 * @interface ConvertExchangeAccountRequest
 */
export interface ConvertExchangeAccountRequest {
    /**
     * Name of the source asset (must be in a currency that is supported for conversions in the selected exchange type that corresponds to your exchange ID)
     * @type {string}
     * @memberof ConvertExchangeAccountRequest
     */
    'srcAsset': string;
    /**
     * Name of the destination asset (must be in a currency that is supported for conversions in the selected exchange type that corresponds to your exchange ID)
     * @type {string}
     * @memberof ConvertExchangeAccountRequest
     */
    'destAsset': string;
    /**
     * The amount to transfer (in the currency of the source asset)
     * @type {number}
     * @memberof ConvertExchangeAccountRequest
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface CreateAddressResponse
 */
export interface CreateAddressResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateAddressResponse
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressResponse
     */
    'legacyAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressResponse
     */
    'enterpriseAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressResponse
     */
    'tag'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateAddressResponse
     */
    'bip44AddressIndex'?: number;
}
/**
 * 
 * @export
 * @interface CreateConnectionRequest
 */
export interface CreateConnectionRequest {
    /**
     * The ID of the vault to connect to the Web3 connection.
     * @type {number}
     * @memberof CreateConnectionRequest
     */
    'vaultAccountId': number;
    /**
     * The default fee level. Valid values are `MEDIUM` and `HIGH`.
     * @type {string}
     * @memberof CreateConnectionRequest
     */
    'feeLevel': CreateConnectionRequestFeeLevelEnum;
    /**
     * The WalletConnect uri provided by the dapp.
     * @type {string}
     * @memberof CreateConnectionRequest
     */
    'uri': string;
    /**
     * The ID of the blockchain network used in the Web3 connection.
     * @type {Array<string>}
     * @memberof CreateConnectionRequest
     */
    'chainIds': Array<string>;
}

export const CreateConnectionRequestFeeLevelEnum = {
    Medium: 'MEDIUM',
    High: 'HIGH'
} as const;

export type CreateConnectionRequestFeeLevelEnum = typeof CreateConnectionRequestFeeLevelEnum[keyof typeof CreateConnectionRequestFeeLevelEnum];

/**
 * 
 * @export
 * @interface CreateConnectionResponse
 */
export interface CreateConnectionResponse {
    /**
     * The ID of the Web3 connection initiated.
     * @type {string}
     * @memberof CreateConnectionResponse
     */
    'id': string;
    /**
     * 
     * @type {CreateConnectionResponseSessionMetadata}
     * @memberof CreateConnectionResponse
     */
    'sessionMetadata': CreateConnectionResponseSessionMetadata;
}
/**
 * Metadata of the Web3 connection (provided by the DApp).
 * @export
 * @interface CreateConnectionResponseSessionMetadata
 */
export interface CreateConnectionResponseSessionMetadata {
    /**
     * 
     * @type {string}
     * @memberof CreateConnectionResponseSessionMetadata
     */
    'appUrl': string;
    /**
     * 
     * @type {string}
     * @memberof CreateConnectionResponseSessionMetadata
     */
    'appName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateConnectionResponseSessionMetadata
     */
    'appDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateConnectionResponseSessionMetadata
     */
    'appIcon'?: string;
}
/**
 * 
 * @export
 * @interface CreateContractRequest
 */
export interface CreateContractRequest {
    /**
     * the contract\'s display name
     * @type {string}
     * @memberof CreateContractRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CreateInternalTransferRequest
 */
export interface CreateInternalTransferRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateInternalTransferRequest
     */
    'asset'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateInternalTransferRequest
     */
    'amount'?: string;
    /**
     * 
     * @type {TradingAccountType}
     * @memberof CreateInternalTransferRequest
     */
    'sourceType'?: TradingAccountType;
    /**
     * 
     * @type {TradingAccountType}
     * @memberof CreateInternalTransferRequest
     */
    'destType'?: TradingAccountType;
}


/**
 * 
 * @export
 * @interface CreateInternalWalletAssetRequest
 */
export interface CreateInternalWalletAssetRequest {
    /**
     * The wallet\'s address or, for EOS wallets, the account name
     * @type {string}
     * @memberof CreateInternalWalletAssetRequest
     */
    'address': string;
    /**
     * for XRP wallets, the destination tag; for EOS, the memo; for the fiat providers (BLINC by BCB Group), the Bank Transfer Description
     * @type {string}
     * @memberof CreateInternalWalletAssetRequest
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface CreateInternalWalletRequest
 */
export interface CreateInternalWalletRequest {
    /**
     * the wallet\'s display name
     * @type {string}
     * @memberof CreateInternalWalletRequest
     */
    'name'?: string;
    /**
     * Optional - Sets a customer reference ID
     * @type {string}
     * @memberof CreateInternalWalletRequest
     */
    'customerRefId'?: string;
}
/**
 * 
 * @export
 * @interface CreateNetworkIdRequest
 */
export interface CreateNetworkIdRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateNetworkIdRequest
     */
    'name': string;
    /**
     * 
     * @type {NetworkIdRoutingPolicy}
     * @memberof CreateNetworkIdRequest
     */
    'routingPolicy'?: NetworkIdRoutingPolicy;
}
/**
 * 
 * @export
 * @interface CreatePayoutRequest
 */
export interface CreatePayoutRequest {
    /**
     * 
     * @type {PaymentAccount}
     * @memberof CreatePayoutRequest
     */
    'paymentAccount': PaymentAccount;
    /**
     * 
     * @type {Array<PayoutInstruction>}
     * @memberof CreatePayoutRequest
     */
    'instructionSet': Array<PayoutInstruction>;
}
/**
 * 
 * @export
 * @interface CreateTransactionResponse
 */
export interface CreateTransactionResponse {
    /**
     * The ID of the transaction.
     * @type {string}
     * @memberof CreateTransactionResponse
     */
    'id'?: string;
    /**
     * The primary status of the transaction. For details, see [Primary transaction statuses.] (https://developers.fireblocks.com/reference/primary-transaction-statuses)
     * @type {string}
     * @memberof CreateTransactionResponse
     */
    'status'?: string;
    /**
     * 
     * @type {SystemMessageInfo}
     * @memberof CreateTransactionResponse
     */
    'systemMessages'?: SystemMessageInfo;
}
/**
 * 
 * @export
 * @interface CreateVaultAccountAssetAddressRequest
 */
export interface CreateVaultAccountAssetAddressRequest {
    /**
     * (Optional) Attach a description to the new address
     * @type {string}
     * @memberof CreateVaultAccountAssetAddressRequest
     */
    'description'?: string;
    /**
     * Optional - Sets a customer reference ID
     * @type {string}
     * @memberof CreateVaultAccountAssetAddressRequest
     */
    'customerRefId'?: string;
}
/**
 * 
 * @export
 * @interface CreateVaultAccountAssetRequest
 */
export interface CreateVaultAccountAssetRequest {
    /**
     * Optional - when creating an EOS wallet, the account name. If not provided, a random name will be generated
     * @type {string}
     * @memberof CreateVaultAccountAssetRequest
     */
    'eosAccountName'?: string;
}
/**
 * 
 * @export
 * @interface CreateVaultAccountRequest
 */
export interface CreateVaultAccountRequest {
    /**
     * Account Name
     * @type {string}
     * @memberof CreateVaultAccountRequest
     */
    'name'?: string;
    /**
     * Optional - if true, the created account and all related transactions will not be shown on Fireblocks console
     * @type {boolean}
     * @memberof CreateVaultAccountRequest
     */
    'hiddenOnUI'?: boolean;
    /**
     * Optional - Sets a customer reference ID
     * @type {string}
     * @memberof CreateVaultAccountRequest
     */
    'customerRefId'?: string;
    /**
     * Optional - Sets the autoFuel property of the vault account
     * @type {boolean}
     * @memberof CreateVaultAccountRequest
     */
    'autoFuel'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateVaultAssetResponse
 */
export interface CreateVaultAssetResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateVaultAssetResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateVaultAssetResponse
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateVaultAssetResponse
     */
    'legacyAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateVaultAssetResponse
     */
    'enterpriseAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateVaultAssetResponse
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateVaultAssetResponse
     */
    'eosAccountName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateVaultAssetResponse
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateVaultAssetResponse
     */
    'activationTxId'?: string;
}
/**
 * 
 * @export
 * @interface CustomCryptoRoutingDest
 */
export interface CustomCryptoRoutingDest {
    /**
     * The network routing logic.
     * @type {string}
     * @memberof CustomCryptoRoutingDest
     */
    'scheme': CustomCryptoRoutingDestSchemeEnum;
    /**
     * The type of destination account the funds are being sent to.
     * @type {string}
     * @memberof CustomCryptoRoutingDest
     */
    'dstType': CustomCryptoRoutingDestDstTypeEnum;
    /**
     * The ID of the destination account the funds are being sent to.
     * @type {string}
     * @memberof CustomCryptoRoutingDest
     */
    'dstId': string;
}

export const CustomCryptoRoutingDestSchemeEnum = {
    Custom: 'CUSTOM'
} as const;

export type CustomCryptoRoutingDestSchemeEnum = typeof CustomCryptoRoutingDestSchemeEnum[keyof typeof CustomCryptoRoutingDestSchemeEnum];
export const CustomCryptoRoutingDestDstTypeEnum = {
    Vault: 'VAULT',
    Exchange: 'EXCHANGE'
} as const;

export type CustomCryptoRoutingDestDstTypeEnum = typeof CustomCryptoRoutingDestDstTypeEnum[keyof typeof CustomCryptoRoutingDestDstTypeEnum];

/**
 * 
 * @export
 * @interface CustomFiatRoutingDest
 */
export interface CustomFiatRoutingDest {
    /**
     * The network routing logic.
     * @type {string}
     * @memberof CustomFiatRoutingDest
     */
    'scheme': CustomFiatRoutingDestSchemeEnum;
    /**
     * The fiat account the funds are being sent to.
     * @type {string}
     * @memberof CustomFiatRoutingDest
     */
    'dstType': CustomFiatRoutingDestDstTypeEnum;
    /**
     * The ID of the fiat account the funds are being sent to.
     * @type {string}
     * @memberof CustomFiatRoutingDest
     */
    'dstId': string;
}

export const CustomFiatRoutingDestSchemeEnum = {
    Custom: 'CUSTOM'
} as const;

export type CustomFiatRoutingDestSchemeEnum = typeof CustomFiatRoutingDestSchemeEnum[keyof typeof CustomFiatRoutingDestSchemeEnum];
export const CustomFiatRoutingDestDstTypeEnum = {
    FiatAccount: 'FIAT_ACCOUNT'
} as const;

export type CustomFiatRoutingDestDstTypeEnum = typeof CustomFiatRoutingDestDstTypeEnum[keyof typeof CustomFiatRoutingDestDstTypeEnum];

/**
 * 
 * @export
 * @interface DefaultNetworkRoutingDest
 */
export interface DefaultNetworkRoutingDest {
    /**
     * The network routing logic.
     * @type {string}
     * @memberof DefaultNetworkRoutingDest
     */
    'scheme': DefaultNetworkRoutingDestSchemeEnum;
}

export const DefaultNetworkRoutingDestSchemeEnum = {
    Default: 'DEFAULT'
} as const;

export type DefaultNetworkRoutingDestSchemeEnum = typeof DefaultNetworkRoutingDestSchemeEnum[keyof typeof DefaultNetworkRoutingDestSchemeEnum];

/**
 * 
 * @export
 * @interface DestinationTransferPeerPath
 */
export interface DestinationTransferPeerPath {
    /**
     * 
     * @type {string}
     * @memberof DestinationTransferPeerPath
     */
    'type': DestinationTransferPeerPathTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DestinationTransferPeerPath
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DestinationTransferPeerPath
     */
    'walletId'?: string;
    /**
     * 
     * @type {OneTimeAddress}
     * @memberof DestinationTransferPeerPath
     */
    'oneTimeAddress'?: OneTimeAddress;
}

export const DestinationTransferPeerPathTypeEnum = {
    VaultAccount: 'VAULT_ACCOUNT',
    ExchangeAccount: 'EXCHANGE_ACCOUNT',
    InternalWallet: 'INTERNAL_WALLET',
    ExternalWallet: 'EXTERNAL_WALLET',
    NetworkConnection: 'NETWORK_CONNECTION',
    FiatAccount: 'FIAT_ACCOUNT',
    Compound: 'COMPOUND',
    GasStation: 'GAS_STATION',
    OneTimeAddress: 'ONE_TIME_ADDRESS',
    Unknown: 'UNKNOWN',
    EndUserWallet: 'END_USER_WALLET'
} as const;

export type DestinationTransferPeerPathTypeEnum = typeof DestinationTransferPeerPathTypeEnum[keyof typeof DestinationTransferPeerPathTypeEnum];

/**
 * The destination of the transaction.
 * @export
 * @interface DestinationTransferPeerPathAllOf
 */
export interface DestinationTransferPeerPathAllOf {
    /**
     * 
     * @type {OneTimeAddress}
     * @memberof DestinationTransferPeerPathAllOf
     */
    'oneTimeAddress'?: OneTimeAddress;
}
/**
 * 
 * @export
 * @interface DestinationTransferPeerPathResponse
 */
export interface DestinationTransferPeerPathResponse {
    /**
     * 
     * @type {string}
     * @memberof DestinationTransferPeerPathResponse
     */
    'type': DestinationTransferPeerPathResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DestinationTransferPeerPathResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DestinationTransferPeerPathResponse
     */
    'walletId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DestinationTransferPeerPathResponse
     */
    'name'?: string;
    /**
     * The specific exchange, fiat account or unmanaged wallet (either INTERNAL / EXTERNAL)
     * @type {string}
     * @memberof DestinationTransferPeerPathResponse
     */
    'subType'?: string;
}

export const DestinationTransferPeerPathResponseTypeEnum = {
    VaultAccount: 'VAULT_ACCOUNT',
    ExchangeAccount: 'EXCHANGE_ACCOUNT',
    InternalWallet: 'INTERNAL_WALLET',
    ExternalWallet: 'EXTERNAL_WALLET',
    NetworkConnection: 'NETWORK_CONNECTION',
    FiatAccount: 'FIAT_ACCOUNT',
    Compound: 'COMPOUND',
    GasStation: 'GAS_STATION',
    OneTimeAddress: 'ONE_TIME_ADDRESS',
    Unknown: 'UNKNOWN',
    EndUserWallet: 'END_USER_WALLET'
} as const;

export type DestinationTransferPeerPathResponseTypeEnum = typeof DestinationTransferPeerPathResponseTypeEnum[keyof typeof DestinationTransferPeerPathResponseTypeEnum];

/**
 * The transactionâ€™s destination. **Note:** In case the transaction is sent to multiple destinations, the `destinations` parameter is be used instead of this.
 * @export
 * @interface DestinationTransferPeerPathResponseAllOf
 */
export interface DestinationTransferPeerPathResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof DestinationTransferPeerPathResponseAllOf
     */
    'name'?: string;
    /**
     * The specific exchange, fiat account or unmanaged wallet (either INTERNAL / EXTERNAL)
     * @type {string}
     * @memberof DestinationTransferPeerPathResponseAllOf
     */
    'subType'?: string;
}
/**
 * 
 * @export
 * @interface DispatchPayoutResponse
 */
export interface DispatchPayoutResponse {
    /**
     * 
     * @type {string}
     * @memberof DispatchPayoutResponse
     */
    'payoutId': string;
}
/**
 * 
 * @export
 * @interface DropTransactionRequest
 */
export interface DropTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof DropTransactionRequest
     */
    'txId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropTransactionRequest
     */
    'feeLevel'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropTransactionRequest
     */
    'gasPrice'?: string;
}
/**
 * 
 * @export
 * @interface DropTransactionResponse
 */
export interface DropTransactionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DropTransactionResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof DropTransactionResponse
     */
    'transactions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorResponseError}
     * @memberof ErrorResponse
     */
    'error': ErrorResponseError;
}
/**
 * 
 * @export
 * @interface ErrorResponseError
 */
export interface ErrorResponseError {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseError
     */
    'type': ErrorResponseErrorTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseError
     */
    'message': string;
}

export const ErrorResponseErrorTypeEnum = {
    Internal: 'INTERNAL',
    Authentication: 'AUTHENTICATION',
    Authorization: 'AUTHORIZATION',
    Validation: 'VALIDATION',
    NotFound: 'NOT_FOUND',
    UnprocessableEntity: 'UNPROCESSABLE_ENTITY',
    Forbidden: 'FORBIDDEN'
} as const;

export type ErrorResponseErrorTypeEnum = typeof ErrorResponseErrorTypeEnum[keyof typeof ErrorResponseErrorTypeEnum];

/**
 * 
 * @export
 * @interface EstimatedNetworkFeeResponse
 */
export interface EstimatedNetworkFeeResponse {
    /**
     * 
     * @type {NetworkFee}
     * @memberof EstimatedNetworkFeeResponse
     */
    'low': NetworkFee;
    /**
     * 
     * @type {NetworkFee}
     * @memberof EstimatedNetworkFeeResponse
     */
    'medium': NetworkFee;
    /**
     * 
     * @type {NetworkFee}
     * @memberof EstimatedNetworkFeeResponse
     */
    'high': NetworkFee;
}
/**
 * 
 * @export
 * @interface EstimatedTransactionFeeResponse
 */
export interface EstimatedTransactionFeeResponse {
    /**
     * 
     * @type {TransactionFee}
     * @memberof EstimatedTransactionFeeResponse
     */
    'low': TransactionFee;
    /**
     * 
     * @type {TransactionFee}
     * @memberof EstimatedTransactionFeeResponse
     */
    'medium': TransactionFee;
    /**
     * 
     * @type {TransactionFee}
     * @memberof EstimatedTransactionFeeResponse
     */
    'high': TransactionFee;
}
/**
 * 
 * @export
 * @interface ExchangeAccount
 */
export interface ExchangeAccount {
    /**
     * 
     * @type {string}
     * @memberof ExchangeAccount
     */
    'id'?: string;
    /**
     * 
     * @type {ExchangeType}
     * @memberof ExchangeAccount
     */
    'type'?: ExchangeType;
    /**
     * Display name of the exchange account
     * @type {string}
     * @memberof ExchangeAccount
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeAccount
     */
    'status'?: string;
    /**
     * 
     * @type {Array<ExchangeAsset>}
     * @memberof ExchangeAccount
     */
    'assets'?: Array<ExchangeAsset>;
    /**
     * 
     * @type {Array<ExchangeTradingAccount>}
     * @memberof ExchangeAccount
     */
    'tradingAccounts'?: Array<ExchangeTradingAccount>;
    /**
     * True if the account is a subaccount in an exchange
     * @type {boolean}
     * @memberof ExchangeAccount
     */
    'isSubaccount'?: boolean;
    /**
     * if the account is a sub-account, the ID of the main account
     * @type {string}
     * @memberof ExchangeAccount
     */
    'mainAccountId'?: string;
}


/**
 * 
 * @export
 * @interface ExchangeAsset
 */
export interface ExchangeAsset {
    /**
     * 
     * @type {string}
     * @memberof ExchangeAsset
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeAsset
     */
    'balance'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeAsset
     */
    'lockedAmount'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeAsset
     */
    'total'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeAsset
     */
    'available'?: string;
}
/**
 * 
 * @export
 * @interface ExchangeTradingAccount
 */
export interface ExchangeTradingAccount {
    /**
     * 
     * @type {string}
     * @memberof ExchangeTradingAccount
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExchangeTradingAccount
     */
    'name'?: string;
    /**
     * 
     * @type {Array<ExchangeAsset>}
     * @memberof ExchangeTradingAccount
     */
    'assets'?: Array<ExchangeAsset>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ExchangeType = {
    Binance: 'BINANCE',
    Binanceus: 'BINANCEUS',
    Bitfinex: 'BITFINEX',
    Bithumb: 'BITHUMB',
    Bitmex: 'BITMEX',
    Bitso: 'BITSO',
    Bitstamp: 'BITSTAMP',
    Bittrex: 'BITTREX',
    Circle: 'CIRCLE',
    Coinbasepro: 'COINBASEPRO',
    Coinmetro: 'COINMETRO',
    Coinspro: 'COINSPRO',
    Cryptocom: 'CRYPTOCOM',
    Deribit: 'DERIBIT',
    Ftx: 'FTX',
    Fixus: 'FIXUS',
    Gemini: 'GEMINI',
    Hitbtc: 'HITBTC',
    Huobi: 'HUOBI',
    Korbit: 'KORBIT',
    Kraken: 'KRAKEN',
    Liquid: 'LIQUID',
    Poloniex: 'POLONIEX',
    Okcoin: 'OKCOIN',
    Okex: 'OKEX',
    Seedcx: 'SEEDCX'
} as const;

export type ExchangeType = typeof ExchangeType[keyof typeof ExchangeType];


/**
 * 
 * @export
 * @interface ExternalWalletAsset
 */
export interface ExternalWalletAsset {
    /**
     * 
     * @type {string}
     * @memberof ExternalWalletAsset
     */
    'id'?: string;
    /**
     * 
     * @type {ConfigChangeRequestStatus}
     * @memberof ExternalWalletAsset
     */
    'status'?: ConfigChangeRequestStatus;
    /**
     * 
     * @type {string}
     * @memberof ExternalWalletAsset
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalWalletAsset
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalWalletAsset
     */
    'activationTime'?: string;
}


/**
 * Details of the transaction\'s fee.
 * @export
 * @interface FeeInfo
 */
export interface FeeInfo {
    /**
     * The fee paid to the network
     * @type {string}
     * @memberof FeeInfo
     */
    'networkFee'?: string;
    /**
     * The total fee deducted by the exchange from the actual requested amount (serviceFee = amount - netAmount)
     * @type {string}
     * @memberof FeeInfo
     */
    'serviceFee'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeInfo
     */
    'gasPrice'?: string;
}
/**
 * 
 * @export
 * @interface FiatAccount
 */
export interface FiatAccount {
    /**
     * 
     * @type {string}
     * @memberof FiatAccount
     */
    'id'?: string;
    /**
     * 
     * @type {FiatAccountType}
     * @memberof FiatAccount
     */
    'type'?: FiatAccountType;
    /**
     * Display name of the fiat account
     * @type {string}
     * @memberof FiatAccount
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiatAccount
     */
    'address'?: string;
    /**
     * 
     * @type {Array<FiatAsset>}
     * @memberof FiatAccount
     */
    'assets'?: Array<FiatAsset>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const FiatAccountType = {
    Blinc: 'BLINC'
} as const;

export type FiatAccountType = typeof FiatAccountType[keyof typeof FiatAccountType];


/**
 * 
 * @export
 * @interface FiatAsset
 */
export interface FiatAsset {
    /**
     * 
     * @type {string}
     * @memberof FiatAsset
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FiatAsset
     */
    'balance'?: string;
}
/**
 * 
 * @export
 * @interface FreezeTransactionResponse
 */
export interface FreezeTransactionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof FreezeTransactionResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface GasStationConfiguration
 */
export interface GasStationConfiguration {
    /**
     * 
     * @type {string}
     * @memberof GasStationConfiguration
     */
    'gasThreshold'?: string;
    /**
     * 
     * @type {string}
     * @memberof GasStationConfiguration
     */
    'gasCap'?: string;
    /**
     * 
     * @type {string}
     * @memberof GasStationConfiguration
     */
    'maxGasPrice'?: string;
}
/**
 * 
 * @export
 * @interface GasStationPropertiesResponse
 */
export interface GasStationPropertiesResponse {
    /**
     * 
     * @type {object}
     * @memberof GasStationPropertiesResponse
     */
    'balance'?: object;
    /**
     * 
     * @type {GasStationConfiguration}
     * @memberof GasStationPropertiesResponse
     */
    'configuration'?: GasStationConfiguration;
}
/**
 * 
 * @export
 * @interface GetConnectionsFilterParameter
 */
export interface GetConnectionsFilterParameter {
    /**
     * 
     * @type {string}
     * @memberof GetConnectionsFilterParameter
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetConnectionsFilterParameter
     */
    'userId'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetConnectionsFilterParameter
     */
    'vaultAccountId'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetConnectionsFilterParameter
     */
    'connectionMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetConnectionsFilterParameter
     */
    'feeLevel'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetConnectionsFilterParameter
     */
    'appUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetConnectionsFilterParameter
     */
    'appName'?: string;
}
/**
 * 
 * @export
 * @interface GetConnectionsResponse
 */
export interface GetConnectionsResponse {
    /**
     * Array with the requested Web3 connection\'s data
     * @type {Array<SessionDTO>}
     * @memberof GetConnectionsResponse
     */
    'data': Array<SessionDTO>;
    /**
     * 
     * @type {Paging}
     * @memberof GetConnectionsResponse
     */
    'paging'?: Paging;
}
/**
 * 
 * @export
 * @interface GetNFTTokens200Response
 */
export interface GetNFTTokens200Response {
    /**
     * 
     * @type {Paging}
     * @memberof GetNFTTokens200Response
     */
    'paging'?: Paging;
    /**
     * 
     * @type {Array<TokenResponse>}
     * @memberof GetNFTTokens200Response
     */
    'data'?: Array<TokenResponse>;
}
/**
 * 
 * @export
 * @interface GetNetworkIds200ResponseInner
 */
export interface GetNetworkIds200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof GetNetworkIds200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetNetworkIds200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {NetworkIdRoutingPolicy}
     * @memberof GetNetworkIds200ResponseInner
     */
    'routingPolicy'?: NetworkIdRoutingPolicy;
    /**
     * The specific network is discoverable.
     * @type {boolean}
     * @memberof GetNetworkIds200ResponseInner
     */
    'isDiscoverable'?: boolean;
}
/**
 * 
 * @export
 * @interface GetOwnershipTokens200Response
 */
export interface GetOwnershipTokens200Response {
    /**
     * 
     * @type {Paging}
     * @memberof GetOwnershipTokens200Response
     */
    'paging'?: Paging;
    /**
     * 
     * @type {Array<TokenOwnershipResponse>}
     * @memberof GetOwnershipTokens200Response
     */
    'data'?: Array<TokenOwnershipResponse>;
}
/**
 * * `TRANSFER` - Transfers funds from one account to another. UTXO blockchains allow multi-input and multi-output transfers. All other blockchains allow transfers with one source address and one destination address. * `MINT` - Mints new tokens. Supported for Stellar, Ripple and EVM-based blockchains. * `BURN` - Burns tokens. Supported for Stellar, Ripple and EVM-based blockchains. * `CONTRACT_CALL` - Calls a smart contract method for web3 operations on any EVM blockchain. The Fireblocks [development libraries](https://developers.fireblocks.com/docs/ethereum-development#convenience-libraries) are recommended for building contract call transactions. * `TYPED_MESSAGE` - An off-chain message in either Ethereum Personal Message or EIP712 format. Use it to sign specific readable messages that are not actual transactions. [Learn more about typed messages](https://developers.fireblocks.com/docs/typed-message-signing). * `RAW` - An off-chain message with no predefined format. Use it to sign any message with your private key, including protocols such as blockchains and custom transaction types that are not natively supported by Fireblocks. [Learn more about raw signing transactions.](https://developers.fireblocks.com/docs/raw-message-signing) * `ENABLE_ASSET` - Algorand, DigitalBits, Solana, and Stellar require an on-chain transaction to create an asset wallet and enable the deposit address. This transaction is automatically created when adding assets on these blockchains at a vault account. * `STAKE` - Assign assets to a staking pool managed by a staking validator. Supported for Stellar and EVM-based blockchains. This transaction is automatically created when performing staking operations. * `UNSTAKE` - Remove assets from a staking pool managed by a staking validator. Supported for Stellar and EVM-based blockchains. This transaction is automatically created when performing staking operations. * `WITHDRAW` - Transfer assets from a dedicated staking vault account to another address. Supported for Stellar and EVM-based blockchains. This transaction is automatically created when performing staking operations.      **Note:** Fireblocks will rename this type from `WITHDRAW` to a different type name soon. There will be a 7-day notice regarding the new type name.  * `SUPPLY_TO_COMPOUND` - Deprecated since April 1st, 2023. Older transactions may have this as their operation, in case users in the workspace have used the direct integration between Fireblocks and the Compound DeFI protocol. * `REDEEM_FROM_COMPOUND` - Deprecated since April 1st, 2023. Older transactions may have this as their operation, in case users in the workspace have used the direct integration between Fireblocks and the Compound DeFI protocol. 
 * @export
 * @enum {string}
 */

export const GetTransactionOperation = {
    Transfer: 'TRANSFER',
    Burn: 'BURN',
    ContractCall: 'CONTRACT_CALL',
    Mint: 'MINT',
    Raw: 'RAW',
    TypedMessage: 'TYPED_MESSAGE',
    EnableAsset: 'ENABLE_ASSET',
    Stake: 'STAKE',
    Unstake: 'UNSTAKE',
    Withdraw: 'WITHDRAW',
    RedeemFromCompound: 'REDEEM_FROM_COMPOUND',
    SupplyToCompound: 'SUPPLY_TO_COMPOUND'
} as const;

export type GetTransactionOperation = typeof GetTransactionOperation[keyof typeof GetTransactionOperation];


/**
 * 
 * @export
 * @interface GetUsersResponse
 */
export interface GetUsersResponse {
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof GetUsersResponse
     */
    'users'?: Array<UserResponse>;
}
/**
 * 
 * @export
 * @interface InstructionAmount
 */
export interface InstructionAmount {
    /**
     * 
     * @type {string}
     * @memberof InstructionAmount
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof InstructionAmount
     */
    'assetId': string;
}
/**
 * 
 * @export
 * @interface MediaEntityResponse
 */
export interface MediaEntityResponse {
    /**
     * Cached accessible URL
     * @type {string}
     * @memberof MediaEntityResponse
     */
    'url': string;
    /**
     * Media type
     * @type {string}
     * @memberof MediaEntityResponse
     */
    'contentType': MediaEntityResponseContentTypeEnum;
}

export const MediaEntityResponseContentTypeEnum = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Animation: 'ANIMATION',
    ThreeD: 'THREE_D',
    Text: 'TEXT',
    Gif: 'GIF',
    UnknownType: 'UNKNOWN_TYPE',
    Svg: 'SVG',
    Audio: 'AUDIO'
} as const;

export type MediaEntityResponseContentTypeEnum = typeof MediaEntityResponseContentTypeEnum[keyof typeof MediaEntityResponseContentTypeEnum];

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    'code'?: number;
}
/**
 * Deprecated in the only used reference - NetworkConnectionResponse
 * @export
 * @interface NetworkChannel
 */
export interface NetworkChannel {
    /**
     * 
     * @type {string}
     * @memberof NetworkChannel
     */
    'networkId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkChannel
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface NetworkConnection
 */
export interface NetworkConnection {
    /**
     * The network ID of the profile trying to create the connection.
     * @type {string}
     * @memberof NetworkConnection
     */
    'localNetworkId': string;
    /**
     * The network ID the profile is attempting to connect to.
     * @type {string}
     * @memberof NetworkConnection
     */
    'remoteNetworkId': string;
    /**
     * 
     * @type {NetworkConnectionRoutingPolicy}
     * @memberof NetworkConnection
     */
    'routingPolicy'?: NetworkConnectionRoutingPolicy;
}
/**
 * 
 * @export
 * @interface NetworkConnectionResponse
 */
export interface NetworkConnectionResponse {
    /**
     * 
     * @type {string}
     * @memberof NetworkConnectionResponse
     */
    'id': string;
    /**
     * 
     * @type {NetworkConnectionResponseLocalChannel}
     * @memberof NetworkConnectionResponse
     * @deprecated
     */
    'localChannel'?: NetworkConnectionResponseLocalChannel;
    /**
     * 
     * @type {NetworkConnectionResponseRemoteChannel}
     * @memberof NetworkConnectionResponse
     * @deprecated
     */
    'remoteChannel'?: NetworkConnectionResponseRemoteChannel;
    /**
     * 
     * @type {ConfigChangeRequestStatus}
     * @memberof NetworkConnectionResponse
     */
    'status': ConfigChangeRequestStatus;
    /**
     * 
     * @type {NetworkId}
     * @memberof NetworkConnectionResponse
     */
    'localNetworkId': NetworkId;
    /**
     * 
     * @type {NetworkId}
     * @memberof NetworkConnectionResponse
     */
    'remoteNetworkId': NetworkId;
    /**
     * 
     * @type {NetworkConnectionRoutingPolicy}
     * @memberof NetworkConnectionResponse
     */
    'routingPolicy': NetworkConnectionRoutingPolicy;
}


/**
 * Deprecated - Replaced by `localNetworkId`
 * @export
 * @interface NetworkConnectionResponseLocalChannel
 */
export interface NetworkConnectionResponseLocalChannel {
    /**
     * 
     * @type {string}
     * @memberof NetworkConnectionResponseLocalChannel
     */
    'networkId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkConnectionResponseLocalChannel
     */
    'name'?: string;
}
/**
 * Deprecated - Replaced by `remoteNetworkId`
 * @export
 * @interface NetworkConnectionResponseRemoteChannel
 */
export interface NetworkConnectionResponseRemoteChannel {
    /**
     * 
     * @type {string}
     * @memberof NetworkConnectionResponseRemoteChannel
     */
    'networkId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkConnectionResponseRemoteChannel
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface NetworkConnectionRoutingPolicy
 */
export interface NetworkConnectionRoutingPolicy {
    /**
     * 
     * @type {NetworkConnectionRoutingPolicyCrypto}
     * @memberof NetworkConnectionRoutingPolicy
     */
    'crypto'?: NetworkConnectionRoutingPolicyCrypto;
    /**
     * 
     * @type {NetworkConnectionRoutingPolicySen}
     * @memberof NetworkConnectionRoutingPolicy
     */
    'sen'?: NetworkConnectionRoutingPolicySen;
    /**
     * 
     * @type {NetworkConnectionRoutingPolicySignet}
     * @memberof NetworkConnectionRoutingPolicy
     */
    'signet'?: NetworkConnectionRoutingPolicySignet;
    /**
     * 
     * @type {NetworkConnectionRoutingPolicySenTest}
     * @memberof NetworkConnectionRoutingPolicy
     */
    'sen_test'?: NetworkConnectionRoutingPolicySenTest;
    /**
     * 
     * @type {NetworkConnectionRoutingPolicySignetTest}
     * @memberof NetworkConnectionRoutingPolicy
     */
    'signet_test'?: NetworkConnectionRoutingPolicySignetTest;
}
/**
 * @type NetworkConnectionRoutingPolicyCrypto
 * @export
 */
export type NetworkConnectionRoutingPolicyCrypto = CustomCryptoRoutingDest | DefaultNetworkRoutingDest | NoneNetworkRoutingDest;

/**
 * @type NetworkConnectionRoutingPolicySen
 * @export
 */
export type NetworkConnectionRoutingPolicySen = CustomFiatRoutingDest | DefaultNetworkRoutingDest | NoneNetworkRoutingDest;

/**
 * @type NetworkConnectionRoutingPolicySenTest
 * @export
 */
export type NetworkConnectionRoutingPolicySenTest = CustomFiatRoutingDest | DefaultNetworkRoutingDest | NoneNetworkRoutingDest;

/**
 * @type NetworkConnectionRoutingPolicySignet
 * @export
 */
export type NetworkConnectionRoutingPolicySignet = CustomFiatRoutingDest | DefaultNetworkRoutingDest | NoneNetworkRoutingDest;

/**
 * @type NetworkConnectionRoutingPolicySignetTest
 * @export
 */
export type NetworkConnectionRoutingPolicySignetTest = CustomFiatRoutingDest | DefaultNetworkRoutingDest | NoneNetworkRoutingDest;

/**
 * 
 * @export
 * @interface NetworkFee
 */
export interface NetworkFee {
    /**
     * 
     * @type {string}
     * @memberof NetworkFee
     */
    'feePerByte'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkFee
     */
    'gasPrice'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkFee
     */
    'networkFee'?: string;
    /**
     * (optional) Base Fee according to EIP-1559 (ETH assets)
     * @type {string}
     * @memberof NetworkFee
     */
    'baseFee'?: string;
    /**
     * (optional) Priority Fee according to EIP-1559 (ETH assets)
     * @type {string}
     * @memberof NetworkFee
     */
    'priorityFee'?: string;
}
/**
 * 
 * @export
 * @interface NetworkId
 */
export interface NetworkId {
    /**
     * 
     * @type {string}
     * @memberof NetworkId
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkId
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface NetworkIdResponse
 */
export interface NetworkIdResponse {
    /**
     * 
     * @type {string}
     * @memberof NetworkIdResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NetworkIdResponse
     */
    'name': string;
    /**
     * 
     * @type {NetworkIdRoutingPolicy}
     * @memberof NetworkIdResponse
     */
    'routingPolicy'?: NetworkIdRoutingPolicy;
    /**
     * The specific network is discoverable.
     * @type {boolean}
     * @memberof NetworkIdResponse
     */
    'isDiscoverable'?: boolean;
}
/**
 * 
 * @export
 * @interface NetworkIdResponseAllOf
 */
export interface NetworkIdResponseAllOf {
    /**
     * 
     * @type {NetworkIdRoutingPolicy}
     * @memberof NetworkIdResponseAllOf
     */
    'routingPolicy'?: NetworkIdRoutingPolicy;
    /**
     * The specific network is discoverable.
     * @type {boolean}
     * @memberof NetworkIdResponseAllOf
     */
    'isDiscoverable'?: boolean;
}
/**
 * 
 * @export
 * @interface NetworkIdRoutingPolicy
 */
export interface NetworkIdRoutingPolicy {
    /**
     * 
     * @type {NetworkIdRoutingPolicyCrypto}
     * @memberof NetworkIdRoutingPolicy
     */
    'crypto'?: NetworkIdRoutingPolicyCrypto;
    /**
     * 
     * @type {NetworkIdRoutingPolicySen}
     * @memberof NetworkIdRoutingPolicy
     */
    'sen'?: NetworkIdRoutingPolicySen;
    /**
     * 
     * @type {NetworkIdRoutingPolicySen}
     * @memberof NetworkIdRoutingPolicy
     */
    'signet'?: NetworkIdRoutingPolicySen;
    /**
     * 
     * @type {NetworkIdRoutingPolicySenTest}
     * @memberof NetworkIdRoutingPolicy
     */
    'sen_test'?: NetworkIdRoutingPolicySenTest;
    /**
     * 
     * @type {NetworkIdRoutingPolicySenTest}
     * @memberof NetworkIdRoutingPolicy
     */
    'signet_test'?: NetworkIdRoutingPolicySenTest;
}
/**
 * @type NetworkIdRoutingPolicyCrypto
 * @export
 */
export type NetworkIdRoutingPolicyCrypto = CustomCryptoRoutingDest | NoneNetworkRoutingDest;

/**
 * @type NetworkIdRoutingPolicySen
 * @export
 */
export type NetworkIdRoutingPolicySen = CustomFiatRoutingDest | NoneNetworkRoutingDest;

/**
 * @type NetworkIdRoutingPolicySenTest
 * @export
 */
export type NetworkIdRoutingPolicySenTest = CustomFiatRoutingDest | NoneNetworkRoutingDest;

/**
 * 
 * @export
 * @interface NetworkRecord
 */
export interface NetworkRecord {
    /**
     * 
     * @type {SourceTransferPeerPathResponse}
     * @memberof NetworkRecord
     */
    'source'?: SourceTransferPeerPathResponse;
    /**
     * 
     * @type {DestinationTransferPeerPathResponse}
     * @memberof NetworkRecord
     */
    'destination'?: DestinationTransferPeerPathResponse;
    /**
     * 
     * @type {string}
     * @memberof NetworkRecord
     */
    'txHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkRecord
     */
    'networkFee'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkRecord
     */
    'assetId'?: string;
    /**
     * The net amount of the transaction, after fee deduction
     * @type {string}
     * @memberof NetworkRecord
     */
    'netAmount'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NetworkRecord
     */
    'isDropped'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NetworkRecord
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkRecord
     */
    'destinationAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkRecord
     */
    'sourceAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkRecord
     */
    'amountUSD'?: string;
    /**
     * 
     * @type {number}
     * @memberof NetworkRecord
     */
    'index'?: number;
    /**
     * 
     * @type {RewardInfo}
     * @memberof NetworkRecord
     */
    'rewardInfo'?: RewardInfo;
}
/**
 * 
 * @export
 * @interface NoneNetworkRoutingDest
 */
export interface NoneNetworkRoutingDest {
    /**
     * No network routing logic.
     * @type {string}
     * @memberof NoneNetworkRoutingDest
     */
    'scheme': NoneNetworkRoutingDestSchemeEnum;
}

export const NoneNetworkRoutingDestSchemeEnum = {
    None: 'NONE'
} as const;

export type NoneNetworkRoutingDestSchemeEnum = typeof NoneNetworkRoutingDestSchemeEnum[keyof typeof NoneNetworkRoutingDestSchemeEnum];

/**
 * 
 * @export
 * @interface OneTimeAddress
 */
export interface OneTimeAddress {
    /**
     * 
     * @type {string}
     * @memberof OneTimeAddress
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof OneTimeAddress
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface PaginatedAssetWalletResponse
 */
export interface PaginatedAssetWalletResponse {
    /**
     * 
     * @type {Array<AssetWallet>}
     * @memberof PaginatedAssetWalletResponse
     */
    'assetWallets'?: Array<AssetWallet>;
    /**
     * 
     * @type {PaginatedAssetWalletResponsePaging}
     * @memberof PaginatedAssetWalletResponse
     */
    'paging'?: PaginatedAssetWalletResponsePaging;
}
/**
 * 
 * @export
 * @interface PaginatedAssetWalletResponsePaging
 */
export interface PaginatedAssetWalletResponsePaging {
    /**
     * A string representing a cursor. Users can use this with a new request to this API endpoint as the â€œbeforeâ€ request parameter to fetch the previous page of results.
     * @type {string}
     * @memberof PaginatedAssetWalletResponsePaging
     */
    'before'?: string;
    /**
     * A string representing a cursor. Users can use this with a new request to this API endpoint as the â€œbeforeâ€ request parameter to fetch the next page of results.
     * @type {string}
     * @memberof PaginatedAssetWalletResponsePaging
     */
    'after'?: string;
}
/**
 * 
 * @export
 * @interface Paging
 */
export interface Paging {
    /**
     * Cursor to the next page
     * @type {string}
     * @memberof Paging
     */
    'next': string;
}
/**
 * 
 * @export
 * @interface PayeeAccount
 */
export interface PayeeAccount {
    /**
     * 
     * @type {string}
     * @memberof PayeeAccount
     */
    'id': string;
    /**
     * 
     * @type {PayeeAccountType}
     * @memberof PayeeAccount
     */
    'type': PayeeAccountType;
}


/**
 * 
 * @export
 * @interface PayeeAccountResponse
 */
export interface PayeeAccountResponse {
    /**
     * 
     * @type {string}
     * @memberof PayeeAccountResponse
     */
    'id'?: string;
    /**
     * 
     * @type {PayeeAccountType}
     * @memberof PayeeAccountResponse
     */
    'type'?: PayeeAccountType;
}


/**
 * - VAULT_ACCOUNT   a native Fireblocks vault account - EXCHANGE_ACCOUNT  a third-party exchange account - INTERNAL_WALLET  a whitelisted address marked as internal to the workspace/organization - EXTERNAL_WALLET a whitelisted address marked as external - NETWORK_CONNECTION a member of the Fireblocks network - FIAT_ACCOUNT a third-party account of a fiat bank (Signature, BCB, etc) 
 * @export
 * @enum {string}
 */

export const PayeeAccountType = {
    VaultAccount: 'VAULT_ACCOUNT',
    ExchangeAccount: 'EXCHANGE_ACCOUNT',
    InternalWallet: 'INTERNAL_WALLET',
    ExternalWallet: 'EXTERNAL_WALLET',
    NetworkConnection: 'NETWORK_CONNECTION',
    FiatAccount: 'FIAT_ACCOUNT'
} as const;

export type PayeeAccountType = typeof PayeeAccountType[keyof typeof PayeeAccountType];


/**
 * 
 * @export
 * @interface PaymentAccount
 */
export interface PaymentAccount {
    /**
     * 
     * @type {string}
     * @memberof PaymentAccount
     */
    'id': string;
    /**
     * 
     * @type {PaymentAccountType}
     * @memberof PaymentAccount
     */
    'type': PaymentAccountType;
}


/**
 * 
 * @export
 * @interface PaymentAccountResponse
 */
export interface PaymentAccountResponse {
    /**
     * 
     * @type {string}
     * @memberof PaymentAccountResponse
     */
    'id'?: string;
    /**
     * 
     * @type {PaymentAccountType}
     * @memberof PaymentAccountResponse
     */
    'type'?: PaymentAccountType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentAccountType = {
    VaultAccount: 'VAULT_ACCOUNT',
    ExchangeAccount: 'EXCHANGE_ACCOUNT',
    FiatAccount: 'FIAT_ACCOUNT'
} as const;

export type PaymentAccountType = typeof PaymentAccountType[keyof typeof PaymentAccountType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PayoutInitMethod = {
    File: 'FILE',
    Api: 'API'
} as const;

export type PayoutInitMethod = typeof PayoutInitMethod[keyof typeof PayoutInitMethod];


/**
 * 
 * @export
 * @interface PayoutInstruction
 */
export interface PayoutInstruction {
    /**
     * 
     * @type {string}
     * @memberof PayoutInstruction
     */
    'id'?: string;
    /**
     * 
     * @type {PayeeAccount}
     * @memberof PayoutInstruction
     */
    'payeeAccount': PayeeAccount;
    /**
     * 
     * @type {InstructionAmount}
     * @memberof PayoutInstruction
     */
    'amount': InstructionAmount;
}
/**
 * 
 * @export
 * @interface PayoutInstructionResponse
 */
export interface PayoutInstructionResponse {
    /**
     * 
     * @type {string}
     * @memberof PayoutInstructionResponse
     */
    'id'?: string;
    /**
     * 
     * @type {PayeeAccountResponse}
     * @memberof PayoutInstructionResponse
     */
    'payeeAccount': PayeeAccountResponse;
    /**
     * 
     * @type {InstructionAmount}
     * @memberof PayoutInstructionResponse
     */
    'amount': InstructionAmount;
    /**
     * 
     * @type {PayoutInstructionState}
     * @memberof PayoutInstructionResponse
     */
    'state': PayoutInstructionState;
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof PayoutInstructionResponse
     */
    'transactions': Array<Transaction>;
}


/**
 * - NOT_STARTED - waiting to start - TRANSACTION_SENT - an underlying transaction was sent - COMPLETED - completed successfully - FAILED - failed - TRANSLATION_ERROR -lookup of the destination failed (due to changes in the underlying whitelisted external wallet or similar) - SKIPPED- no transaction(s) created for this instruction 
 * @export
 * @enum {string}
 */

export const PayoutInstructionState = {
    NotStarted: 'NOT_STARTED',
    TransactionSent: 'TRANSACTION_SENT',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    TranslationError: 'TRANSLATION_ERROR',
    Skipped: 'SKIPPED'
} as const;

export type PayoutInstructionState = typeof PayoutInstructionState[keyof typeof PayoutInstructionState];


/**
 * 
 * @export
 * @interface PayoutResponse
 */
export interface PayoutResponse {
    /**
     * 
     * @type {string}
     * @memberof PayoutResponse
     */
    'payoutId': string;
    /**
     * 
     * @type {PaymentAccountResponse}
     * @memberof PayoutResponse
     */
    'paymentAccount': PaymentAccountResponse;
    /**
     * 
     * @type {number}
     * @memberof PayoutResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {PayoutState}
     * @memberof PayoutResponse
     */
    'state': PayoutState;
    /**
     * 
     * @type {PayoutStatus}
     * @memberof PayoutResponse
     */
    'status': PayoutStatus;
    /**
     * <ul>  <li> INSUFFICIENT_BALANCE</li> <li> SOURCE_TRANSLATION</li> <li> SOURCE_NOT_UNIQUE</li> <li> SOURCE_NOT_FOUND</li> <li> SOURCE_TYPE_NOT_SUPPORTED</li> <li> EMPTY_SOURCE</li> <li> DESTINATION_TRANSLATION</li> <li> DESTINATION_NOT_UNIQUE</li> <li> DESTINATION_NOT_FOUND</li> <li> EMPTY_DESTINATION</li> <li> PARSING </li> <li> UNKNOWN</li> <li> FIREBLOCKS_CLIENT</li> <li> TRANSACTION_SUBMISSION</li> </ul> 
     * @type {string}
     * @memberof PayoutResponse
     */
    'reasonOfFailure'?: string;
    /**
     * 
     * @type {PayoutInitMethod}
     * @memberof PayoutResponse
     */
    'initMethod'?: PayoutInitMethod;
    /**
     * 
     * @type {Array<PayoutInstructionResponse>}
     * @memberof PayoutResponse
     */
    'instructionSet': Array<PayoutInstructionResponse>;
    /**
     * 
     * @type {string}
     * @memberof PayoutResponse
     */
    'reportUrl'?: string;
}


/**
 * - CREATED - payout instruction set created with all its details - FILE_FOUND - new file found in the FTP - REQUESTED - payout requested with all its details - TRANSLATED - payout instruction account IDs identified and translated - PROCESSING - payout instruction set executed and is processing - SUBMITTED - transactions submitted for payout instructions - FINALIZED - payout finished processing, all transactions processed successfully - INSUFFICIENT_BALANCE - insufficient balance in the payment account (can be a temporary state) - FAILED - one or more of the payout instructions failed 
 * @export
 * @enum {string}
 */

export const PayoutState = {
    Created: 'CREATED',
    FileFound: 'FILE_FOUND',
    Requested: 'REQUESTED',
    Translated: 'TRANSLATED',
    Processing: 'PROCESSING',
    Submitted: 'SUBMITTED',
    Finalized: 'FINALIZED',
    InsufficientBalance: 'INSUFFICIENT_BALANCE',
    Failed: 'FAILED'
} as const;

export type PayoutState = typeof PayoutState[keyof typeof PayoutState];


/**
 * - REQUESTED payout requested with all its details - VERIFIED payout instruction set details were verified - PROCESSING payout instruction set executed and is processing - FINALIZED payout done (all payout instructions completed successfully) - INSUFFICIENT_BALANCE insufficient balance in the payment account (can be a temporary state) - FAILED one or more of the payout instructions failed 
 * @export
 * @enum {string}
 */

export const PayoutStatus = {
    Registered: 'REGISTERED',
    Verifying: 'VERIFYING',
    InProgress: 'IN_PROGRESS',
    Done: 'DONE',
    InsufficientBalance: 'INSUFFICIENT_BALANCE',
    Failed: 'FAILED'
} as const;

export type PayoutStatus = typeof PayoutStatus[keyof typeof PayoutStatus];


/**
 * 
 * @export
 * @interface PublicKeyInformation
 */
export interface PublicKeyInformation {
    /**
     * 
     * @type {string}
     * @memberof PublicKeyInformation
     */
    'algorithm'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PublicKeyInformation
     */
    'derivationPath'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyInformation
     */
    'publicKey'?: string;
}
/**
 * 
 * @export
 * @interface RedeemFundsToLinkedDDARequest
 */
export interface RedeemFundsToLinkedDDARequest {
    /**
     * 
     * @type {number}
     * @memberof RedeemFundsToLinkedDDARequest
     */
    'amount'?: number;
}
/**
 * 
 * @export
 * @interface RemoveCollateralRequestBody
 */
export interface RemoveCollateralRequestBody {
    /**
     * 
     * @type {TransactionRequest}
     * @memberof RemoveCollateralRequestBody
     */
    'transactionRequest'?: TransactionRequest;
    /**
     * optional
     * @type {boolean}
     * @memberof RemoveCollateralRequestBody
     */
    'isDstCollateral'?: boolean;
}
/**
 * 
 * @export
 * @interface ResendWebhooksForTransactionRequest
 */
export interface ResendWebhooksForTransactionRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ResendWebhooksForTransactionRequest
     */
    'resendCreated'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResendWebhooksForTransactionRequest
     */
    'resendStatusUpdated'?: boolean;
}
/**
 * 
 * @export
 * @interface ResendWebhooksResponse
 */
export interface ResendWebhooksResponse {
    /**
     * 
     * @type {number}
     * @memberof ResendWebhooksResponse
     */
    'messagesCount'?: number;
}
/**
 * 
 * @export
 * @interface RespondToConnectionRequest
 */
export interface RespondToConnectionRequest {
    /**
     * Approval of the initiated Web3 connection.
     * @type {boolean}
     * @memberof RespondToConnectionRequest
     */
    'approve': boolean;
}
/**
 * This field is relevant only for Algorand transactions. Both `srcRewards` and `destRewards` will appear only for Vault to Vault transactions, otherwise you will receive only the Fireblocksâ€™ side of the transaction.
 * @export
 * @interface RewardInfo
 */
export interface RewardInfo {
    /**
     * 
     * @type {string}
     * @memberof RewardInfo
     */
    'srcRewards'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewardInfo
     */
    'destRewards'?: string;
}
/**
 * 
 * @export
 * @interface RewardsInfo
 */
export interface RewardsInfo {
    /**
     * Amount that is pending for rewards
     * @type {string}
     * @memberof RewardsInfo
     */
    'pendingRewards'?: string;
}
/**
 * 
 * @export
 * @interface SessionDTO
 */
export interface SessionDTO {
    /**
     * Id of the connection
     * @type {string}
     * @memberof SessionDTO
     */
    'id': string;
    /**
     * Id of the user that created the connection
     * @type {string}
     * @memberof SessionDTO
     */
    'userId': string;
    /**
     * 
     * @type {SessionDTOSessionMetadata}
     * @memberof SessionDTO
     */
    'sessionMetadata': SessionDTOSessionMetadata;
    /**
     * The vault to connect
     * @type {number}
     * @memberof SessionDTO
     */
    'vaultAccountId': number;
    /**
     * The default fee level
     * @type {string}
     * @memberof SessionDTO
     */
    'feeLevel': SessionDTOFeeLevelEnum;
    /**
     * The chains approved for the connection
     * @type {Array<string>}
     * @memberof SessionDTO
     */
    'chainIds': Array<string>;
    /**
     * The connection\'s type
     * @type {string}
     * @memberof SessionDTO
     */
    'connectionType': SessionDTOConnectionTypeEnum;
    /**
     * The method through which the connection was established
     * @type {string}
     * @memberof SessionDTO
     */
    'connectionMethod': SessionDTOConnectionMethodEnum;
    /**
     * Timestamp of the session\'s creation
     * @type {string}
     * @memberof SessionDTO
     */
    'creationDate': string;
}

export const SessionDTOFeeLevelEnum = {
    Medium: 'MEDIUM',
    High: 'HIGH'
} as const;

export type SessionDTOFeeLevelEnum = typeof SessionDTOFeeLevelEnum[keyof typeof SessionDTOFeeLevelEnum];
export const SessionDTOConnectionTypeEnum = {
    WalletConnect: 'WalletConnect'
} as const;

export type SessionDTOConnectionTypeEnum = typeof SessionDTOConnectionTypeEnum[keyof typeof SessionDTOConnectionTypeEnum];
export const SessionDTOConnectionMethodEnum = {
    Desktop: 'DESKTOP',
    Mobile: 'MOBILE',
    Api: 'API'
} as const;

export type SessionDTOConnectionMethodEnum = typeof SessionDTOConnectionMethodEnum[keyof typeof SessionDTOConnectionMethodEnum];

/**
 * Metadata of the connection (provided by the dapp)
 * @export
 * @interface SessionDTOSessionMetadata
 */
export interface SessionDTOSessionMetadata {
    /**
     * 
     * @type {string}
     * @memberof SessionDTOSessionMetadata
     */
    'appUrl': string;
    /**
     * 
     * @type {string}
     * @memberof SessionDTOSessionMetadata
     */
    'appName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionDTOSessionMetadata
     */
    'appDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionDTOSessionMetadata
     */
    'appIcon'?: string;
}
/**
 * 
 * @export
 * @interface SessionMetadata
 */
export interface SessionMetadata {
    /**
     * 
     * @type {string}
     * @memberof SessionMetadata
     */
    'appUrl': string;
    /**
     * 
     * @type {string}
     * @memberof SessionMetadata
     */
    'appName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionMetadata
     */
    'appDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionMetadata
     */
    'appIcon'?: string;
}
/**
 * 
 * @export
 * @interface SetAutoFuelForVaultAccountRequest
 */
export interface SetAutoFuelForVaultAccountRequest {
    /**
     * Auto Fuel
     * @type {boolean}
     * @memberof SetAutoFuelForVaultAccountRequest
     */
    'autoFuel'?: boolean;
}
/**
 * 
 * @export
 * @interface SetConfirmationsThresholdRequest
 */
export interface SetConfirmationsThresholdRequest {
    /**
     * 
     * @type {number}
     * @memberof SetConfirmationsThresholdRequest
     */
    'numOfConfirmations'?: number;
}
/**
 * 
 * @export
 * @interface SetConfirmationsThresholdResponse
 */
export interface SetConfirmationsThresholdResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SetConfirmationsThresholdResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof SetConfirmationsThresholdResponse
     */
    'transactions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SetCustomerRefIdForVaultAccountRequest
 */
export interface SetCustomerRefIdForVaultAccountRequest {
    /**
     * Customer reference ID
     * @type {string}
     * @memberof SetCustomerRefIdForVaultAccountRequest
     */
    'customerRefId'?: string;
}
/**
 * 
 * @export
 * @interface SetDiscoverabilityForNetworkIdRequest
 */
export interface SetDiscoverabilityForNetworkIdRequest {
    /**
     * 
     * @type {boolean}
     * @memberof SetDiscoverabilityForNetworkIdRequest
     */
    'isDiscoverable': boolean;
}
/**
 * 
 * @export
 * @interface SetNetworkIdNameRequest
 */
export interface SetNetworkIdNameRequest {
    /**
     * 
     * @type {string}
     * @memberof SetNetworkIdNameRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SetRoutingPolicyForNetworkConnection200Response
 */
export interface SetRoutingPolicyForNetworkConnection200Response {
    /**
     * 
     * @type {boolean}
     * @memberof SetRoutingPolicyForNetworkConnection200Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface SetRoutingPolicyForNetworkConnectionRequest
 */
export interface SetRoutingPolicyForNetworkConnectionRequest {
    /**
     * 
     * @type {NetworkConnectionRoutingPolicy}
     * @memberof SetRoutingPolicyForNetworkConnectionRequest
     */
    'routingPolicy': NetworkConnectionRoutingPolicy;
}
/**
 * 
 * @export
 * @interface SetRoutingPolicyForNetworkIdRequest
 */
export interface SetRoutingPolicyForNetworkIdRequest {
    /**
     * 
     * @type {NetworkIdRoutingPolicy}
     * @memberof SetRoutingPolicyForNetworkIdRequest
     */
    'routingPolicy': NetworkIdRoutingPolicy;
}
/**
 * 
 * @export
 * @interface SettlementRequestBody
 */
export interface SettlementRequestBody {
    /**
     * 
     * @type {string}
     * @memberof SettlementRequestBody
     */
    'mainExchangeAccountId'?: string;
}
/**
 * 
 * @export
 * @interface SettlementResponse
 */
export interface SettlementResponse {
    /**
     * 
     * @type {string}
     * @memberof SettlementResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SettlementResponse
     */
    'initiator'?: string;
    /**
     * 
     * @type {string}
     * @memberof SettlementResponse
     */
    'exchangeReply'?: string;
    /**
     * 
     * @type {object}
     * @memberof SettlementResponse
     */
    'fireblocksInitiatedTransactions'?: object;
    /**
     * 
     * @type {SettlementResponse}
     * @memberof SettlementResponse
     */
    'exchangeRequestedTransactions'?: SettlementResponse;
}
/**
 * A list of signed messages returned for raw signing.
 * @export
 * @interface SignedMessage
 */
export interface SignedMessage {
    /**
     * 
     * @type {string}
     * @memberof SignedMessage
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignedMessage
     */
    'algorithm'?: SignedMessageAlgorithmEnum;
    /**
     * 
     * @type {Array<number>}
     * @memberof SignedMessage
     */
    'derivationPath'?: Array<number>;
    /**
     * 
     * @type {SignedMessageSignature}
     * @memberof SignedMessage
     */
    'signature'?: SignedMessageSignature;
    /**
     * 
     * @type {string}
     * @memberof SignedMessage
     */
    'publicKey'?: string;
}

export const SignedMessageAlgorithmEnum = {
    EcdsaSecp256K1: 'MPC_ECDSA_SECP256K1',
    EddsaEd25519: 'MPC_EDDSA_ED25519'
} as const;

export type SignedMessageAlgorithmEnum = typeof SignedMessageAlgorithmEnum[keyof typeof SignedMessageAlgorithmEnum];

/**
 * 
 * @export
 * @interface SignedMessageSignature
 */
export interface SignedMessageSignature {
    /**
     * 
     * @type {string}
     * @memberof SignedMessageSignature
     */
    'fullSig'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignedMessageSignature
     */
    'r'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignedMessageSignature
     */
    's'?: string;
    /**
     * 
     * @type {number}
     * @memberof SignedMessageSignature
     */
    'v'?: number;
}
/**
 * 
 * @export
 * @interface SourceTransferPeerPathResponse
 */
export interface SourceTransferPeerPathResponse {
    /**
     * 
     * @type {string}
     * @memberof SourceTransferPeerPathResponse
     */
    'type': SourceTransferPeerPathResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SourceTransferPeerPathResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceTransferPeerPathResponse
     */
    'walletId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceTransferPeerPathResponse
     */
    'name'?: string;
    /**
     * The specific exchange, fiat account or unmanaged wallet (either INTERNAL / EXTERNAL)
     * @type {string}
     * @memberof SourceTransferPeerPathResponse
     */
    'subType'?: string;
}

export const SourceTransferPeerPathResponseTypeEnum = {
    VaultAccount: 'VAULT_ACCOUNT',
    ExchangeAccount: 'EXCHANGE_ACCOUNT',
    InternalWallet: 'INTERNAL_WALLET',
    ExternalWallet: 'EXTERNAL_WALLET',
    NetworkConnection: 'NETWORK_CONNECTION',
    FiatAccount: 'FIAT_ACCOUNT',
    Compound: 'COMPOUND',
    GasStation: 'GAS_STATION',
    OneTimeAddress: 'ONE_TIME_ADDRESS',
    Unknown: 'UNKNOWN',
    EndUserWallet: 'END_USER_WALLET'
} as const;

export type SourceTransferPeerPathResponseTypeEnum = typeof SourceTransferPeerPathResponseTypeEnum[keyof typeof SourceTransferPeerPathResponseTypeEnum];

/**
 * The transactionâ€™s source.
 * @export
 * @interface SourceTransferPeerPathResponseAllOf
 */
export interface SourceTransferPeerPathResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof SourceTransferPeerPathResponseAllOf
     */
    'name'?: string;
    /**
     * The specific exchange, fiat account or unmanaged wallet (either INTERNAL / EXTERNAL)
     * @type {string}
     * @memberof SourceTransferPeerPathResponseAllOf
     */
    'subType'?: string;
}
/**
 * 
 * @export
 * @interface SystemMessageInfo
 */
export interface SystemMessageInfo {
    /**
     * 
     * @type {string}
     * @memberof SystemMessageInfo
     */
    'type'?: SystemMessageInfoTypeEnum;
    /**
     * A response from Fireblocks that communicates a message about the health of the process being performed. If this object is returned with data, you should expect potential delays or incomplete transaction statuses.
     * @type {string}
     * @memberof SystemMessageInfo
     */
    'message'?: string;
}

export const SystemMessageInfoTypeEnum = {
    Warn: 'WARN',
    Block: 'BLOCK'
} as const;

export type SystemMessageInfoTypeEnum = typeof SystemMessageInfoTypeEnum[keyof typeof SystemMessageInfoTypeEnum];

/**
 * 
 * @export
 * @interface Term
 */
export interface Term {
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'networkConnectionId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Term
     */
    'outgoing'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'asset'?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof Term
     */
    'operation'?: string;
}
/**
 * 
 * @export
 * @interface ToCollateralTransaction
 */
export interface ToCollateralTransaction {
    /**
     * 
     * @type {string}
     * @memberof ToCollateralTransaction
     */
    'asset'?: string;
    /**
     * 
     * @type {string}
     * @memberof ToCollateralTransaction
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof ToCollateralTransaction
     */
    'srcAddress'?: string;
    /**
     * optional
     * @type {string}
     * @memberof ToCollateralTransaction
     */
    'srcTag'?: string;
    /**
     * optional
     * @type {string}
     * @memberof ToCollateralTransaction
     */
    'fee'?: string;
}
/**
 * 
 * @export
 * @interface ToExchangeTransaction
 */
export interface ToExchangeTransaction {
    /**
     * 
     * @type {string}
     * @memberof ToExchangeTransaction
     */
    'assetId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ToExchangeTransaction
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof ToExchangeTransaction
     */
    'dstAddress'?: string;
    /**
     * optional
     * @type {string}
     * @memberof ToExchangeTransaction
     */
    'dstTag'?: string;
}
/**
 * 
 * @export
 * @interface TokenCollectionResponse
 */
export interface TokenCollectionResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenCollectionResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TokenCollectionResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TokenCollectionResponse
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface TokenOwnershipResponse
 */
export interface TokenOwnershipResponse {
    /**
     * The Fireblocks NFT asset id
     * @type {string}
     * @memberof TokenOwnershipResponse
     */
    'id': string;
    /**
     * Token id within the contract/collection
     * @type {string}
     * @memberof TokenOwnershipResponse
     */
    'tokenId': string;
    /**
     * ERC721 / ERC1155
     * @type {string}
     * @memberof TokenOwnershipResponse
     */
    'standard': string;
    /**
     * URL of the original token JSON metadata
     * @type {string}
     * @memberof TokenOwnershipResponse
     */
    'metadataURI'?: string;
    /**
     * URL of the cached token JSON metadata
     * @type {string}
     * @memberof TokenOwnershipResponse
     */
    'cachedMetadataURI'?: string;
    /**
     * Media items extracted from metadata JSON
     * @type {Array<MediaEntityResponse>}
     * @memberof TokenOwnershipResponse
     */
    'media': Array<MediaEntityResponse>;
    /**
     * 
     * @type {TokenResponseCollection}
     * @memberof TokenOwnershipResponse
     */
    'collection'?: TokenResponseCollection;
    /**
     * 
     * @type {string}
     * @memberof TokenOwnershipResponse
     */
    'balance': string;
    /**
     * 
     * @type {string}
     * @memberof TokenOwnershipResponse
     */
    'vaultAccountId': string;
    /**
     * 
     * @type {number}
     * @memberof TokenOwnershipResponse
     */
    'ownershipStartTime': number;
    /**
     * 
     * @type {number}
     * @memberof TokenOwnershipResponse
     */
    'ownershipLastUpdateTime': number;
    /**
     * 
     * @type {string}
     * @memberof TokenOwnershipResponse
     */
    'blockchainDescriptor': TokenOwnershipResponseBlockchainDescriptorEnum;
    /**
     * 
     * @type {string}
     * @memberof TokenOwnershipResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TokenOwnershipResponse
     */
    'name': string;
}

export const TokenOwnershipResponseBlockchainDescriptorEnum = {
    Eth: 'ETH',
    EthTest3: 'ETH_TEST3',
    Polygon: 'POLYGON',
    PolygonTestMumbai: 'POLYGON_TEST_MUMBAI'
} as const;

export type TokenOwnershipResponseBlockchainDescriptorEnum = typeof TokenOwnershipResponseBlockchainDescriptorEnum[keyof typeof TokenOwnershipResponseBlockchainDescriptorEnum];

/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * The Fireblocks NFT asset id
     * @type {string}
     * @memberof TokenResponse
     */
    'id': string;
    /**
     * Token id within the contract/collection
     * @type {string}
     * @memberof TokenResponse
     */
    'tokenId': string;
    /**
     * ERC721 / ERC1155
     * @type {string}
     * @memberof TokenResponse
     */
    'standard': string;
    /**
     * URL of the original token JSON metadata
     * @type {string}
     * @memberof TokenResponse
     */
    'metadataURI'?: string;
    /**
     * URL of the cached token JSON metadata
     * @type {string}
     * @memberof TokenResponse
     */
    'cachedMetadataURI'?: string;
    /**
     * Media items extracted from metadata JSON
     * @type {Array<MediaEntityResponse>}
     * @memberof TokenResponse
     */
    'media': Array<MediaEntityResponse>;
    /**
     * 
     * @type {TokenResponseCollection}
     * @memberof TokenResponse
     */
    'collection'?: TokenResponseCollection;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'blockchainDescriptor': TokenResponseBlockchainDescriptorEnum;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'name': string;
}

export const TokenResponseBlockchainDescriptorEnum = {
    Eth: 'ETH',
    EthTest3: 'ETH_TEST3',
    Polygon: 'POLYGON',
    PolygonTestMumbai: 'POLYGON_TEST_MUMBAI'
} as const;

export type TokenResponseBlockchainDescriptorEnum = typeof TokenResponseBlockchainDescriptorEnum[keyof typeof TokenResponseBlockchainDescriptorEnum];

/**
 * Parent collection information
 * @export
 * @interface TokenResponseCollection
 */
export interface TokenResponseCollection {
    /**
     * 
     * @type {string}
     * @memberof TokenResponseCollection
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponseCollection
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponseCollection
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TradingAccountType = {
    CoinFutures: 'COIN_FUTURES',
    CoinMarginedSwap: 'COIN_MARGINED_SWAP',
    Exchange: 'EXCHANGE',
    Funding: 'FUNDING',
    Fundable: 'FUNDABLE',
    Futures: 'FUTURES',
    FuturesCross: 'FUTURES_CROSS',
    Margin: 'MARGIN',
    MarginCross: 'MARGIN_CROSS',
    Options: 'OPTIONS',
    Spot: 'SPOT',
    UsdtMarginedSwapCross: 'USDT_MARGINED_SWAP_CROSS',
    UsdtFutures: 'USDT_FUTURES',
    Unified: 'UNIFIED'
} as const;

export type TradingAccountType = typeof TradingAccountType[keyof typeof TradingAccountType];


/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'state': TransactionStateEnum;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'instructionId'?: string;
}

export const TransactionStateEnum = {
    Submitted: 'SUBMITTED',
    Queued: 'QUEUED',
    PendingAuthorization: 'PENDING_AUTHORIZATION',
    PendingSignature: 'PENDING_SIGNATURE',
    Broadcasting: 'BROADCASTING',
    Pending3RdPartyManualApproval: 'PENDING_3RD_PARTY_MANUAL_APPROVAL',
    Pending3RdParty: 'PENDING_3RD_PARTY',
    Pending: 'PENDING',
    Confirming: 'CONFIRMING',
    Confirmed: 'CONFIRMED',
    Completed: 'COMPLETED',
    PartiallyCompleted: 'PARTIALLY_COMPLETED',
    PendingAmlScreening: 'PENDING_AML_SCREENING',
    Cancelling: 'CANCELLING',
    Cancelled: 'CANCELLED',
    Rejected: 'REJECTED',
    Blocked: 'BLOCKED',
    Failed: 'FAILED',
    Timeout: 'TIMEOUT'
} as const;

export type TransactionStateEnum = typeof TransactionStateEnum[keyof typeof TransactionStateEnum];

/**
 * 
 * @export
 * @interface TransactionFee
 */
export interface TransactionFee {
    /**
     * 
     * @type {string}
     * @memberof TransactionFee
     */
    'feePerByte'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionFee
     */
    'gasPrice'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionFee
     */
    'gasLimit'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionFee
     */
    'networkFee'?: string;
    /**
     * (optional) Base Fee according to EIP-1559 (ETH assets)
     * @type {string}
     * @memberof TransactionFee
     */
    'baseFee'?: string;
    /**
     * (optional) Priority Fee according to EIP-1559 (ETH assets)
     * @type {string}
     * @memberof TransactionFee
     */
    'priorityFee'?: string;
}
/**
 * * `TRANSFER` - The default value for an operation. Transfers funds from one account to another. UTXO blockchains allow multi-input and multi-output transfers. All other blockchains allow transfers with one source address and one destination address. * `MINT` - Mints new tokens. Supported for Stellar, Ripple and EVM-based blockchains. * `BURN` - Burns tokens. Supported for Stellar, Ripple and EVM-based blockchains. * `CONTRACT_CALL` - Calls a smart contract method for web3 operations on any EVM blockchain. The Fireblocks [development libraries](https://developers.fireblocks.com/docs/ethereum-development#convenience-libraries) are recommended for building contract call transactions. * `TYPED_MESSAGE` - An off-chain message in either Ethereum Personal Message or EIP712 format. Use it to sign specific readable messages that are not actual transactions. [Learn more about typed messages](https://developers.fireblocks.com/docs/typed-message-signing). * `RAW` - An off-chain message with no predefined format. Use it to sign any message with your private key, including protocols such as blockchains and custom transaction types that are not natively supported by Fireblocks. [Learn more about raw signing transactions.](https://developers.fireblocks.com/docs/raw-message-signing) 
 * @export
 * @enum {string}
 */

export const TransactionOperation = {
    Transfer: 'TRANSFER',
    Burn: 'BURN',
    ContractCall: 'CONTRACT_CALL',
    Mint: 'MINT',
    Raw: 'RAW',
    TypedMessage: 'TYPED_MESSAGE'
} as const;

export type TransactionOperation = typeof TransactionOperation[keyof typeof TransactionOperation];


/**
 * 
 * @export
 * @interface TransactionRequest
 */
export interface TransactionRequest {
    /**
     * 
     * @type {TransactionOperation}
     * @memberof TransactionRequest
     */
    'operation'?: TransactionOperation;
    /**
     * Custom note, not sent to the blockchain, to describe the transaction at your Fireblocks workspace.
     * @type {string}
     * @memberof TransactionRequest
     */
    'note'?: string;
    /**
     * An optional but highly recommended parameter. Fireblocks will reject future transactions with same ID.  You should set this to a unique ID representing the transaction, to avoid submitting the same transaction twice. This helps with cases where submitting the transaction responds with an error code due to Internet interruptions, but the transaction was actually sent and processed. To validate whether a transaction has been processed, [Find a specific transaction by external transaction ID](https://developers.fireblocks.com/reference/get_transactions-external-tx-id-externaltxid). There is no specific format required for this parameter.
     * @type {string}
     * @memberof TransactionRequest
     */
    'externalTxId'?: string;
    /**
     * The ID of the asset to transfer, for `TRANSFER`, `MINT` or `BURN` operations. [See the list of supported assets and their IDs on Fireblocks.](https://developers.fireblocks.com/reference/get_supported-assets)
     * @type {string}
     * @memberof TransactionRequest
     */
    'assetId'?: string;
    /**
     * 
     * @type {TransferPeerPath}
     * @memberof TransactionRequest
     */
    'source'?: TransferPeerPath;
    /**
     * 
     * @type {DestinationTransferPeerPath}
     * @memberof TransactionRequest
     */
    'destination'?: DestinationTransferPeerPath;
    /**
     * For UTXO based blockchains, you can send a single transaction to multiple destinations.
     * @type {Array<TransactionRequestDestination>}
     * @memberof TransactionRequest
     */
    'destinations'?: Array<TransactionRequestDestination>;
    /**
     * 
     * @type {TransactionRequestAmount}
     * @memberof TransactionRequest
     */
    'amount'?: TransactionRequestAmount;
    /**
     * When set to `true`, the fee will be deducted from the requested amount.
     * @type {boolean}
     * @memberof TransactionRequest
     */
    'treatAsGrossAmount'?: boolean;
    /**
     * For Polkadot, Kusama and Westend transactions only. When set to true, Fireblocks will empty the asset wallet.     **Note:** If set to true when the source account is exactly 1 DOT, the transaction will fail. Any amount more or less than 1 DOT succeeds. This is a Polkadot blockchain limitation.
     * @type {boolean}
     * @memberof TransactionRequest
     */
    'forceSweep'?: boolean;
    /**
     * For UTXO or EVM-based blockchains only. Defines the blockchain fee level which will be payed for the transaction. Alternatively, specific fee estimation parameters exist below.
     * @type {string}
     * @memberof TransactionRequest
     */
    'feeLevel'?: TransactionRequestFeeLevelEnum;
    /**
     * 
     * @type {TransactionRequestFee}
     * @memberof TransactionRequest
     */
    'fee'?: TransactionRequestFee;
    /**
     * 
     * @type {TransactionRequestPriorityFee}
     * @memberof TransactionRequest
     */
    'priorityFee'?: TransactionRequestPriorityFee;
    /**
     * When set to `true`, in case the current `MEDIUM` fee level is higher than the one specified in the transaction, the transaction will fail to avoid getting stuck with no confirmations.
     * @type {boolean}
     * @memberof TransactionRequest
     */
    'failOnLowFee'?: boolean;
    /**
     * The maximum fee (gas price or fee per byte) that should be payed for the transaction.  In case the current value of the requested `feeLevel` is higher than this requested maximum fee.  Represented by a numeric string for accurate precision.
     * @type {string}
     * @memberof TransactionRequest
     */
    'maxFee'?: string;
    /**
     * 
     * @type {TransactionRequestGasLimit}
     * @memberof TransactionRequest
     */
    'gasLimit'?: TransactionRequestGasLimit;
    /**
     * 
     * @type {TransactionRequestGasPrice}
     * @memberof TransactionRequest
     */
    'gasPrice'?: TransactionRequestGasPrice;
    /**
     * 
     * @type {TransactionRequestNetworkFee}
     * @memberof TransactionRequest
     */
    'networkFee'?: TransactionRequestNetworkFee;
    /**
     * For EVM-based blockchains only. In case a transaction is stuck, specify the hash of the stuck transaction to replace it by this transaction with a higher fee, or to replace it with this transaction with a zero fee and drop it from the blockchain.
     * @type {string}
     * @memberof TransactionRequest
     */
    'replaceTxByHash'?: string;
    /**
     * Additional protocol / operation specific key-value parameters:  For UTXO-based blockchain input selection, add the key `inputsSelection` with the value set the [input selection structure.](https://developers.fireblocks.com/reference/transaction-objects#inputsselection) The inputs can be retrieved from the [Retrieve Unspent Inputs endpoint.](https://developers.fireblocks.com/reference/get_vault-accounts-vaultaccountid-assetid-unspent-inputs)  For `RAW` operations, add the key `rawMessageData` with the value set to the [raw message data structure.](https://developers.fireblocks.com/reference/raw-signing-objects#rawmessagedata)  For `CONTRACT_CALL` operations, add the key `contractCallData` with the value set to the Ethereum smart contract Application Binary Interface (ABI) payload. The Fireblocks [development libraries](https://developers.fireblocks.com/docs/ethereum-development#convenience-libraries) are recommended for building contract call transactions. 
     * @type {object}
     * @memberof TransactionRequest
     */
    'extraParameters'?: object;
    /**
     * The ID for AML providers to associate the owner of funds with transactions.
     * @type {string}
     * @memberof TransactionRequest
     */
    'customerRefId'?: string;
    /**
     * This feature is no longer supported.
     * @type {boolean}
     * @memberof TransactionRequest
     * @deprecated
     */
    'autoStaking'?: boolean;
    /**
     * 
     * @type {TransactionRequestNetworkStaking}
     * @memberof TransactionRequest
     * @deprecated
     */
    'networkStaking'?: TransactionRequestNetworkStaking;
    /**
     * 
     * @type {TransactionRequestNetworkStaking}
     * @memberof TransactionRequest
     * @deprecated
     */
    'cpuStaking'?: TransactionRequestNetworkStaking;
}

export const TransactionRequestFeeLevelEnum = {
    Low: 'LOW',
    Medium: 'MEDIUM',
    High: 'HIGH'
} as const;

export type TransactionRequestFeeLevelEnum = typeof TransactionRequestFeeLevelEnum[keyof typeof TransactionRequestFeeLevelEnum];

/**
 * @type TransactionRequestAmount
 * For `TRANSFER` operations, the requested amount to transfer, in the assetâ€™s unit. Fireblocks recommends using a numeric string for accurate precision. Although a number input exists, it is deprecated.
 * @export
 */
export type TransactionRequestAmount = number | string;

/**
 * 
 * @export
 * @interface TransactionRequestDestination
 */
export interface TransactionRequestDestination {
    /**
     * 
     * @type {string}
     * @memberof TransactionRequestDestination
     */
    'amount'?: string;
    /**
     * 
     * @type {DestinationTransferPeerPath}
     * @memberof TransactionRequestDestination
     */
    'destination'?: DestinationTransferPeerPath;
}
/**
 * @type TransactionRequestFee
 * For UTXO-based blockchains, the fee per bytes in the assetâ€™s smallest unit (Satoshi, Latoshi, etc.).  For Ripple, the fee for the transaction. Fireblocks recommends using a numeric string for accurate precision. Although a number input exists, it is deprecated.
 * @export
 */
export type TransactionRequestFee = number | string;

/**
 * @type TransactionRequestGasLimit
 * For EVM-based blockchains only. Units of gas required to process the transaction. Note: Only two of the three arguments can be specified in a single transaction: `gasLimit`, `gasPrice` and `networkFee`. Fireblocks recommends using a numeric string for accurate precision. Although a number input exists, it is deprecated.
 * @export
 */
export type TransactionRequestGasLimit = number | string;

/**
 * @type TransactionRequestGasPrice
 * For non-EIP-1559, EVM-based transactions. Price per gas unit (in Ethereum this is specified in Gwei).  Note: Only two of the three arguments can be specified in a single transaction: `gasLimit`, `gasPrice` and `networkFee`. Fireblocks recommends using a numeric string for accurate precision.  Although a number input exists, it is deprecated.
 * @export
 */
export type TransactionRequestGasPrice = number | string;

/**
 * @type TransactionRequestNetworkFee
 * For EVM-based blockchains only. The total transaction fee in the blockchainâ€™s largest unit. Note: Only two of the three arguments can be specified in a single transaction: `gasLimit`, `gasPrice` and `networkFee`. Fireblocks recommends using a numeric string for accurate precision. Although a number input exists, it is deprecated. - The transaction blockchain fee. - For Ethereum, you can\'t pass gasPrice, gasLimit and networkFee all together. - A numeric value representation is required.
 * @export
 */
export type TransactionRequestNetworkFee = number | string;

/**
 * @type TransactionRequestNetworkStaking
 * This feature is no longer supported.
 * @export
 */
export type TransactionRequestNetworkStaking = number | string;

/**
 * @type TransactionRequestPriorityFee
 * For Ethereum-based blockchains only, the fee for EIP-1559 transaction pricing mechanism. Value is in Gwei.  Fireblocks recommends using a numeric string for accurate precision. Although a number input exists, it is deprecated.
 * @export
 */
export type TransactionRequestPriorityFee = number | string;

/**
 * 
 * @export
 * @interface TransactionResponse
 */
export interface TransactionResponse {
    /**
     * ID of the transaction.
     * @type {string}
     * @memberof TransactionResponse
     */
    'id'?: string;
    /**
     * Unique transaction ID provided by the user. Fireblocks highly recommends setting an `externalTxId` for every transaction created, to avoid submitting the same transaction twice.
     * @type {string}
     * @memberof TransactionResponse
     */
    'externalTxId'?: string;
    /**
     * The primary status of the transaction. For details, see [Primary transaction statuses](https://developers.fireblocks.com/reference/primary-transaction-statuses).
     * @type {string}
     * @memberof TransactionResponse
     */
    'status'?: string;
    /**
     * See [Transaction substatuses](https://developers.fireblocks.com/reference/transaction-substatuses) for the list of transaction sub statuses.
     * @type {string}
     * @memberof TransactionResponse
     */
    'subStatus'?: string;
    /**
     * The hash of the transaction on the blockchain.  * This parameter exists if at least one of the following conditions is met:       1. The transactionâ€™s source type is `UNKNOWN`, `WHITELISTED_ADDRESS`, `NETWORK_CONNECTION`, `ONE_TIME_ADDRESS`, `FIAT_ACCOUNT` or `GAS_STATION`.       2. The transactionâ€™s source type is `VAULT` and the status is either: `CONFIRMING`, `COMPLETED`, or was in any of these statuses prior to changing to `FAILED` or `REJECTED`. In some instances, transactions in status `BROADCASTING` will include the txHash as well.       3. The transactionâ€™s source type is `EXCHANGE_ACCOUNT` and the transactionâ€™s destination type is `VAULT`, and the status is either: `CONFIRMING`, `COMPLETED`, or was in any of these status prior to changing to `FAILED`.   * In addition, the following conditions must be met:      1. The asset is a crypto asset (not fiat).      2. The transaction operation is not RAW or `TYPED_MESSAGE`.
     * @type {string}
     * @memberof TransactionResponse
     */
    'txHash'?: string;
    /**
     * 
     * @type {GetTransactionOperation}
     * @memberof TransactionResponse
     */
    'operation'?: GetTransactionOperation;
    /**
     * Custom note, not sent to the blockchain, that describes the transaction at your Fireblocks workspace.
     * @type {string}
     * @memberof TransactionResponse
     */
    'note'?: string;
    /**
     * The ID of the asset to transfer, for `TRANSFER`, `MINT`, `BURN`, `ENABLE_ASSET`,`STAKE` ,`UNSTAKE` or `WITHDRAW` operations. [See the list of supported assets and their IDs on Fireblocks.](https://developers.fireblocks.com/reference/get_supported-assets)
     * @type {string}
     * @memberof TransactionResponse
     */
    'assetId'?: string;
    /**
     * 
     * @type {SourceTransferPeerPathResponse}
     * @memberof TransactionResponse
     */
    'source'?: SourceTransferPeerPathResponse;
    /**
     * For account based assets only, the source address of the transaction. **Note:** If the status is `CONFIRMING`, `COMPLETED`, or has been `CONFIRMING`; then moved forward to `FAILED` or `REJECTED`, then this parameter will contain the source address. In any other case, this parameter will be empty.
     * @type {string}
     * @memberof TransactionResponse
     */
    'sourceAddress'?: string;
    /**
     * Source address tag for XRP, used as memo for EOS/XLM, or Bank Transfer Description for the fiat provider BLINC (by BCB Group).
     * @type {string}
     * @memberof TransactionResponse
     */
    'tag'?: string;
    /**
     * 
     * @type {DestinationTransferPeerPathResponse}
     * @memberof TransactionResponse
     */
    'destination'?: DestinationTransferPeerPathResponse;
    /**
     * The transactionâ€™s destinations. **Note:** In case the transaction is sent to a single destination, the `destination` parameter is used instead of this.
     * @type {Array<TransactionResponseDestination>}
     * @memberof TransactionResponse
     */
    'destinations'?: Array<TransactionResponseDestination>;
    /**
     * Address where the asset were transferred. Notes:   - For [Multi destination transactions](https://support.fireblocks.io/hc/en-us/articles/360018447980-Multi-destination-transactions), this parameter will be empty. In this case, you should refer to the destinations field.   - If the status is `CONFIRMING`, `COMPLETED`, or has been `CONFIRMING`; then moved forward to `FAILED` or `REJECTED`, then this parameter will contain the destination address. In any other case, this parameter will be empty.
     * @type {string}
     * @memberof TransactionResponse
     */
    'destinationAddress'?: string;
    /**
     * Description of the address.
     * @type {string}
     * @memberof TransactionResponse
     */
    'destinationAddressDescription'?: string;
    /**
     * Destination address tag for XRP, used as memo for EOS/XLM, or Bank Transfer Description for the fiat provider BLINC (by BCB Group).
     * @type {string}
     * @memberof TransactionResponse
     */
    'destinationTag'?: string;
    /**
     * 
     * @type {TransactionResponseContractCallDecodedData}
     * @memberof TransactionResponse
     */
    'contractCallDecodedData'?: TransactionResponseContractCallDecodedData;
    /**
     * 
     * @type {AmountInfo}
     * @memberof TransactionResponse
     */
    'amountInfo'?: AmountInfo;
    /**
     * For transactions initiated via this Fireblocks workspace, when set to `true`, the fee is deducted from the requested amount.
     * @type {boolean}
     * @memberof TransactionResponse
     */
    'treatAsGrossAmount'?: boolean;
    /**
     * 
     * @type {FeeInfo}
     * @memberof TransactionResponse
     */
    'feeInfo'?: FeeInfo;
    /**
     * The asset which was withdrawn to pay the transaction fee, for example ETH for EVM-based blockchains, BTC for Tether Omni.
     * @type {string}
     * @memberof TransactionResponse
     */
    'feeCurrency'?: string;
    /**
     * In case a single transaction resulted with multiple transfers, for example a result of a contract call, then this parameter specifies each transfer that took place on the blockchain. In case of a single transfer transaction, this parameter is empty.
     * @type {Array<NetworkRecord>}
     * @memberof TransactionResponse
     */
    'networkRecords'?: Array<NetworkRecord>;
    /**
     * The transactionâ€™s creation date and time, in unix timestamp.
     * @type {number}
     * @memberof TransactionResponse
     */
    'createdAt'?: number;
    /**
     * The transactionâ€™s last update date and time, in unix timestamp.
     * @type {number}
     * @memberof TransactionResponse
     */
    'lastUpdated'?: number;
    /**
     * User ID of the initiator of the transaction.
     * @type {string}
     * @memberof TransactionResponse
     */
    'createdBy'?: string;
    /**
     * User IDâ€™s of the signers of the transaction.
     * @type {Array<string>}
     * @memberof TransactionResponse
     */
    'signedBy'?: Array<string>;
    /**
     * User ID of the user that rejected the transaction (in case it was rejected).
     * @type {string}
     * @memberof TransactionResponse
     */
    'rejectedBy'?: string;
    /**
     * 
     * @type {AuthorizationInfo}
     * @memberof TransactionResponse
     */
    'authorizationInfo'?: AuthorizationInfo;
    /**
     * If the transaction originated from an exchange, this is the ID of this transaction at the exchange.
     * @type {string}
     * @memberof TransactionResponse
     */
    'exchangeTxId'?: string;
    /**
     * The ID for AML providers to associate the owner of funds with transactions.
     * @type {string}
     * @memberof TransactionResponse
     */
    'customerRefId'?: string;
    /**
     * 
     * @type {AmlScreeningResult}
     * @memberof TransactionResponse
     */
    'amlScreeningResult'?: AmlScreeningResult;
    /**
     * Additional protocol / operation specific key-value parameters:  For UTXO-based blockchain input selection, add the key `inputsSelection` with the value set the [input selection structure.](https://developers.fireblocks.com/reference/transaction-objects#inputsselection) The inputs can be retrieved from the [Retrieve Unspent Inputs endpoint.](https://developers.fireblocks.com/reference/get_vault-accounts-vaultaccountid-assetid-unspent-inputs)  For `RAW` operations, add the key `rawMessageData` with the value set to the [raw message data structure.](https://developers.fireblocks.com/reference/raw-signing-objects#rawmessagedata)  For `CONTRACT_CALL` operations, add the key `contractCallData` with the value set to the Ethereum smart contract Application Binary Interface (ABI) payload. The Fireblocks [development libraries](https://developers.fireblocks.com/docs/ethereum-development#convenience-libraries) are recommended for building contract call transactions. 
     * @type {object}
     * @memberof TransactionResponse
     */
    'extraParameters'?: object;
    /**
     * 
     * @type {SignedMessage}
     * @memberof TransactionResponse
     */
    'signedMessages'?: SignedMessage;
    /**
     * The number of confirmations of the transaction. The number will increase until the transaction will be considered completed according to the confirmation policy.
     * @type {number}
     * @memberof TransactionResponse
     */
    'numOfConfirmations'?: number;
    /**
     * 
     * @type {BlockInfo}
     * @memberof TransactionResponse
     */
    'blockInfo'?: BlockInfo;
    /**
     * For UTXO based assets this is the vOut, for Ethereum based, this is the index of the event of the contract call.  **Note:** This field is not returned if a transaction uses the `destinations` object with more than one value.
     * @type {number}
     * @memberof TransactionResponse
     */
    'index'?: number;
    /**
     * 
     * @type {RewardInfo}
     * @memberof TransactionResponse
     */
    'rewardInfo'?: RewardInfo;
    /**
     * 
     * @type {SystemMessageInfo}
     * @memberof TransactionResponse
     */
    'systemMessages'?: SystemMessageInfo;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponse
     */
    'addressType'?: TransactionResponseAddressTypeEnum;
    /**
     * The amount requested by the user. Deprecated - please use the `amountInfo` field for accuracy.
     * @type {number}
     * @memberof TransactionResponse
     * @deprecated
     */
    'requestedAmount'?: number;
    /**
     * If the transfer is a withdrawal from an exchange, the actual amount that was requested to be transferred. Otherwise, the requested amount. Deprecated - please use the `amountInfo` field for accuracy.
     * @type {number}
     * @memberof TransactionResponse
     * @deprecated
     */
    'amount'?: number;
    /**
     * The net amount of the transaction, after fee deduction. Deprecated - please use the `amountInfo` field for accuracy.
     * @type {number}
     * @memberof TransactionResponse
     * @deprecated
     */
    'netAmount'?: number;
    /**
     * The USD value of the requested amount. Deprecated - please use the `amountInfo` field for accuracy.
     * @type {number}
     * @memberof TransactionResponse
     * @deprecated
     */
    'amountUSD'?: number | null;
    /**
     * The total fee deducted by the exchange from the actual requested amount (`serviceFee` = `amount` - `netAmount`). Deprecated - please use the `feeInfo` field for accuracy.
     * @type {number}
     * @memberof TransactionResponse
     * @deprecated
     */
    'serviceFee'?: number;
    /**
     * Deprecated - please use the `feeInfo` field for accuracy.
     * @type {number}
     * @memberof TransactionResponse
     * @deprecated
     */
    'fee'?: number;
    /**
     * The fee paid to the network. Deprecated - please use the `feeInfo` field for accuracy.
     * @type {number}
     * @memberof TransactionResponse
     * @deprecated
     */
    'networkFee'?: number;
}

export const TransactionResponseAddressTypeEnum = {
    Whitelisted: 'WHITELISTED',
    OneTime: 'ONE_TIME'
} as const;

export type TransactionResponseAddressTypeEnum = typeof TransactionResponseAddressTypeEnum[keyof typeof TransactionResponseAddressTypeEnum];

/**
 * Decoded data for `CONTRACT_CALL` operations. The Fireblocks [development libraries](https://developers.fireblocks.com/docs/ethereum-development#convenience-libraries) are recommended for setting this parameter\'s value.
 * @export
 * @interface TransactionResponseContractCallDecodedData
 */
export interface TransactionResponseContractCallDecodedData {
    /**
     * 
     * @type {string}
     * @memberof TransactionResponseContractCallDecodedData
     */
    'contractName'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof TransactionResponseContractCallDecodedData
     */
    'functionCalls'?: Array<object>;
}
/**
 * 
 * @export
 * @interface TransactionResponseDestination
 */
export interface TransactionResponseDestination {
    /**
     * 
     * @type {string}
     * @memberof TransactionResponseDestination
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionResponseDestination
     */
    'amountUSD'?: string;
    /**
     * 
     * @type {AmlScreeningResult}
     * @memberof TransactionResponseDestination
     */
    'amlScreeningResult'?: AmlScreeningResult;
    /**
     * 
     * @type {DestinationTransferPeerPathResponse}
     * @memberof TransactionResponseDestination
     */
    'destination'?: DestinationTransferPeerPathResponse;
    /**
     * 
     * @type {AuthorizationInfo}
     * @memberof TransactionResponseDestination
     */
    'authorizationInfo'?: AuthorizationInfo;
}
/**
 * 
 * @export
 * @interface TransferPeerPath
 */
export interface TransferPeerPath {
    /**
     * 
     * @type {string}
     * @memberof TransferPeerPath
     */
    'type': TransferPeerPathTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TransferPeerPath
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferPeerPath
     */
    'walletId'?: string;
}

export const TransferPeerPathTypeEnum = {
    VaultAccount: 'VAULT_ACCOUNT',
    ExchangeAccount: 'EXCHANGE_ACCOUNT',
    InternalWallet: 'INTERNAL_WALLET',
    ExternalWallet: 'EXTERNAL_WALLET',
    NetworkConnection: 'NETWORK_CONNECTION',
    FiatAccount: 'FIAT_ACCOUNT',
    Compound: 'COMPOUND',
    GasStation: 'GAS_STATION',
    OneTimeAddress: 'ONE_TIME_ADDRESS',
    Unknown: 'UNKNOWN',
    EndUserWallet: 'END_USER_WALLET'
} as const;

export type TransferPeerPathTypeEnum = typeof TransferPeerPathTypeEnum[keyof typeof TransferPeerPathTypeEnum];

/**
 * 
 * @export
 * @interface TravelRuleAddress
 */
export interface TravelRuleAddress {
    /**
     * Street address
     * @type {string}
     * @memberof TravelRuleAddress
     */
    'street': string;
    /**
     * City
     * @type {string}
     * @memberof TravelRuleAddress
     */
    'city': string;
    /**
     * State or province
     * @type {string}
     * @memberof TravelRuleAddress
     */
    'state': string;
    /**
     * Postal or ZIP code
     * @type {string}
     * @memberof TravelRuleAddress
     */
    'postalCode': string;
}
/**
 * 
 * @export
 * @interface TravelRuleGetAllVASPsResponse
 */
export interface TravelRuleGetAllVASPsResponse {
    /**
     * 
     * @type {Array<TravelRuleVASP>}
     * @memberof TravelRuleGetAllVASPsResponse
     */
    'vasps': Array<TravelRuleVASP>;
}
/**
 * 
 * @export
 * @interface TravelRuleIssuer
 */
export interface TravelRuleIssuer {
    /**
     * 
     * @type {string}
     * @memberof TravelRuleIssuer
     */
    'issuerDid': string;
}
/**
 * 
 * @export
 * @interface TravelRuleIssuers
 */
export interface TravelRuleIssuers {
    /**
     * 
     * @type {TravelRuleIssuer}
     * @memberof TravelRuleIssuers
     */
    'yearFounded': TravelRuleIssuer;
    /**
     * 
     * @type {TravelRuleIssuer}
     * @memberof TravelRuleIssuers
     */
    'isRegulated': TravelRuleIssuer;
    /**
     * 
     * @type {TravelRuleIssuer}
     * @memberof TravelRuleIssuers
     */
    'regulatoryAuthorities': TravelRuleIssuer;
    /**
     * 
     * @type {TravelRuleIssuer}
     * @memberof TravelRuleIssuers
     */
    'name': TravelRuleIssuer;
    /**
     * 
     * @type {TravelRuleIssuer}
     * @memberof TravelRuleIssuers
     */
    'logo': TravelRuleIssuer;
    /**
     * 
     * @type {TravelRuleIssuer}
     * @memberof TravelRuleIssuers
     */
    'website': TravelRuleIssuer;
    /**
     * 
     * @type {TravelRuleIssuer}
     * @memberof TravelRuleIssuers
     */
    'legalName': TravelRuleIssuer;
    /**
     * 
     * @type {TravelRuleIssuer}
     * @memberof TravelRuleIssuers
     */
    'legalStructure': TravelRuleIssuer;
    /**
     * 
     * @type {TravelRuleIssuer}
     * @memberof TravelRuleIssuers
     */
    'incorporationCountry': TravelRuleIssuer;
    /**
     * 
     * @type {TravelRuleIssuer}
     * @memberof TravelRuleIssuers
     */
    'businessNumber': TravelRuleIssuer;
    /**
     * 
     * @type {TravelRuleIssuer}
     * @memberof TravelRuleIssuers
     */
    'addressLine1': TravelRuleIssuer;
    /**
     * 
     * @type {TravelRuleIssuer}
     * @memberof TravelRuleIssuers
     */
    'city': TravelRuleIssuer;
    /**
     * 
     * @type {TravelRuleIssuer}
     * @memberof TravelRuleIssuers
     */
    'country': TravelRuleIssuer;
    /**
     * 
     * @type {TravelRuleIssuer}
     * @memberof TravelRuleIssuers
     */
    'description': TravelRuleIssuer;
}
/**
 * 
 * @export
 * @interface TravelRuleOwnershipProof
 */
export interface TravelRuleOwnershipProof {
    /**
     * Type of ownership proof
     * @type {string}
     * @memberof TravelRuleOwnershipProof
     */
    'type': string;
    /**
     * Identification number
     * @type {string}
     * @memberof TravelRuleOwnershipProof
     */
    'id': string;
    /**
     * Name of owner
     * @type {string}
     * @memberof TravelRuleOwnershipProof
     */
    'name': string;
    /**
     * Country of issuance
     * @type {string}
     * @memberof TravelRuleOwnershipProof
     */
    'country': string;
    /**
     * Date of issuance
     * @type {string}
     * @memberof TravelRuleOwnershipProof
     */
    'issueDate': string;
    /**
     * Name of issuing entity
     * @type {string}
     * @memberof TravelRuleOwnershipProof
     */
    'issuer': string;
}
/**
 * 
 * @export
 * @interface TravelRulePiiIVMS
 */
export interface TravelRulePiiIVMS {
    /**
     * 
     * @type {string}
     * @memberof TravelRulePiiIVMS
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRulePiiIVMS
     */
    'dateOfBirth': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRulePiiIVMS
     */
    'placeOfBirth': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRulePiiIVMS
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRulePiiIVMS
     */
    'identificationNumber': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRulePiiIVMS
     */
    'nationality': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRulePiiIVMS
     */
    'countryOfResidence': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRulePiiIVMS
     */
    'taxIdentificationNumber': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRulePiiIVMS
     */
    'customerNumber': string;
}
/**
 * 
 * @export
 * @interface TravelRuleTransactionBlockchainInfo
 */
export interface TravelRuleTransactionBlockchainInfo {
    /**
     * 
     * @type {string}
     * @memberof TravelRuleTransactionBlockchainInfo
     */
    'txHash': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleTransactionBlockchainInfo
     */
    'origin': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleTransactionBlockchainInfo
     */
    'destination': string;
}
/**
 * 
 * @export
 * @interface TravelRuleUpdateVASPDetails
 */
export interface TravelRuleUpdateVASPDetails {
    /**
     * The decentralized identifier of the VASP
     * @type {string}
     * @memberof TravelRuleUpdateVASPDetails
     */
    'did': string;
    /**
     * The PII DID key of the VASP
     * @type {string}
     * @memberof TravelRuleUpdateVASPDetails
     */
    'pii_didkey': string;
}
/**
 * 
 * @export
 * @interface TravelRuleVASP
 */
export interface TravelRuleVASP {
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'did': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'verificationStatus': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'addressLine1': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'addressLine2': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'emailDomains': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'website': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'legalStructure': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'legalName': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'yearFounded': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'incorporationCountry': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'isRegulated': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'otherNames': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'identificationType': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'identificationCountry': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'businessNumber': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'regulatoryAuthorities': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'jurisdictions': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'street': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'number': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'unit': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'postCode': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'certificates': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'travelRule_OPENVASP': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'travelRule_SYGNA': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'travelRule_TRISA': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'travelRule_TRLIGHT': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'travelRule_EMAIL': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'travelRule_TRP': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'travelRule_SHYFT': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'travelRule_USTRAVELRULEWG': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'updatedBy': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'lastSentDate': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'lastReceivedDate': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleVASP
     */
    'documents': string;
    /**
     * 
     * @type {boolean}
     * @memberof TravelRuleVASP
     */
    'hasAdmin': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TravelRuleVASP
     */
    'isNotifiable': boolean;
    /**
     * 
     * @type {TravelRuleIssuers}
     * @memberof TravelRuleVASP
     */
    'issuers': TravelRuleIssuers;
}
/**
 * 
 * @export
 * @interface TravelRuleValidateFullTransactionRequest
 */
export interface TravelRuleValidateFullTransactionRequest {
    /**
     * The asset involved in the transaction
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'transactionAsset': string;
    /**
     * The amount of the transaction
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'transactionAmount': string;
    /**
     * The DID of the transaction originator
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'originatorDid': string;
    /**
     * The DID of the transaction beneficiary
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'beneficiaryDid': string;
    /**
     * The VASP ID of the transaction originator
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'originatorVASPdid': string;
    /**
     * The VASP ID of the transaction beneficiary
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'beneficiaryVASPdid': string;
    /**
     * The name of the VASP acting as the beneficiary
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'beneficiaryVASPname': string;
    /**
     * 
     * @type {TravelRuleValidateFullTransactionRequestTransactionBlockchainInfo}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'transactionBlockchainInfo': TravelRuleValidateFullTransactionRequestTransactionBlockchainInfo;
    /**
     * 
     * @type {TravelRuleValidateFullTransactionRequestOriginator}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'originator': TravelRuleValidateFullTransactionRequestOriginator;
    /**
     * 
     * @type {TravelRuleValidateFullTransactionRequestBeneficiary}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'beneficiary': TravelRuleValidateFullTransactionRequestBeneficiary;
    /**
     * Encrypted data related to the transaction
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'encrypted': string;
    /**
     * The protocol used to perform the travel rule
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'protocol': string;
    /**
     * The email address where a notification should be sent upon completion of the travel rule
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'notificationEmail': string;
    /**
     * Whether to skip validation of beneficiary data
     * @type {boolean}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'skipBeneficiaryDataValidation': boolean;
    /**
     * Whether to check if the transaction is a TRAVEL_RULE in the beneficiary VASP\'s jurisdiction
     * @type {boolean}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'travelRuleBehavior': boolean;
    /**
     * 
     * @type {TravelRuleValidateFullTransactionRequestOriginatorProof}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'originatorProof': TravelRuleValidateFullTransactionRequestOriginatorProof;
    /**
     * 
     * @type {TravelRuleValidateFullTransactionRequestBeneficiaryProof}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'beneficiaryProof': TravelRuleValidateFullTransactionRequestBeneficiaryProof;
    /**
     * 
     * @type {TravelRuleValidateFullTransactionRequestPii}
     * @memberof TravelRuleValidateFullTransactionRequest
     */
    'pii': TravelRuleValidateFullTransactionRequestPii;
}
/**
 * Information about the beneficiary of the transaction
 * @export
 * @interface TravelRuleValidateFullTransactionRequestBeneficiary
 */
export interface TravelRuleValidateFullTransactionRequestBeneficiary {
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestBeneficiary
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestBeneficiary
     */
    'dateOfBirth': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestBeneficiary
     */
    'placeOfBirth': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestBeneficiary
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestBeneficiary
     */
    'identificationNumber': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestBeneficiary
     */
    'nationality': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestBeneficiary
     */
    'countryOfResidence': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestBeneficiary
     */
    'taxIdentificationNumber': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestBeneficiary
     */
    'customerNumber': string;
}
/**
 * Ownership proof related to the beneficiary of the transaction
 * @export
 * @interface TravelRuleValidateFullTransactionRequestBeneficiaryProof
 */
export interface TravelRuleValidateFullTransactionRequestBeneficiaryProof {
    /**
     * Type of ownership proof
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestBeneficiaryProof
     */
    'type': string;
    /**
     * Identification number
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestBeneficiaryProof
     */
    'id': string;
    /**
     * Name of owner
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestBeneficiaryProof
     */
    'name': string;
    /**
     * Country of issuance
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestBeneficiaryProof
     */
    'country': string;
    /**
     * Date of issuance
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestBeneficiaryProof
     */
    'issueDate': string;
    /**
     * Name of issuing entity
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestBeneficiaryProof
     */
    'issuer': string;
}
/**
 * Information about the originator of the transaction
 * @export
 * @interface TravelRuleValidateFullTransactionRequestOriginator
 */
export interface TravelRuleValidateFullTransactionRequestOriginator {
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestOriginator
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestOriginator
     */
    'dateOfBirth': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestOriginator
     */
    'placeOfBirth': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestOriginator
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestOriginator
     */
    'identificationNumber': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestOriginator
     */
    'nationality': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestOriginator
     */
    'countryOfResidence': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestOriginator
     */
    'taxIdentificationNumber': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestOriginator
     */
    'customerNumber': string;
}
/**
 * Ownership proof related to the originator of the transaction
 * @export
 * @interface TravelRuleValidateFullTransactionRequestOriginatorProof
 */
export interface TravelRuleValidateFullTransactionRequestOriginatorProof {
    /**
     * Type of ownership proof
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestOriginatorProof
     */
    'type': string;
    /**
     * Identification number
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestOriginatorProof
     */
    'id': string;
    /**
     * Name of owner
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestOriginatorProof
     */
    'name': string;
    /**
     * Country of issuance
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestOriginatorProof
     */
    'country': string;
    /**
     * Date of issuance
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestOriginatorProof
     */
    'issueDate': string;
    /**
     * Name of issuing entity
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestOriginatorProof
     */
    'issuer': string;
}
/**
 * Personal identifiable information related to the transaction
 * @export
 * @interface TravelRuleValidateFullTransactionRequestPii
 */
export interface TravelRuleValidateFullTransactionRequestPii {
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestPii
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestPii
     */
    'dateOfBirth': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestPii
     */
    'placeOfBirth': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestPii
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestPii
     */
    'identificationNumber': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestPii
     */
    'nationality': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestPii
     */
    'countryOfResidence': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestPii
     */
    'taxIdentificationNumber': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestPii
     */
    'customerNumber': string;
}
/**
 * Information about the blockchain transaction
 * @export
 * @interface TravelRuleValidateFullTransactionRequestTransactionBlockchainInfo
 */
export interface TravelRuleValidateFullTransactionRequestTransactionBlockchainInfo {
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestTransactionBlockchainInfo
     */
    'txHash': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestTransactionBlockchainInfo
     */
    'origin': string;
    /**
     * 
     * @type {string}
     * @memberof TravelRuleValidateFullTransactionRequestTransactionBlockchainInfo
     */
    'destination': string;
}
/**
 * 
 * @export
 * @interface TravelRuleValidateTransactionRequest
 */
export interface TravelRuleValidateTransactionRequest {
    /**
     * Transaction asset symbol BTC,ETH)
     * @type {string}
     * @memberof TravelRuleValidateTransactionRequest
     */
    'transactionAsset': string;
    /**
     * Transaction destination address
     * @type {string}
     * @memberof TravelRuleValidateTransactionRequest
     */
    'destination': string;
    /**
     * Transaction amount in the transaction asset
     * @type {string}
     * @memberof TravelRuleValidateTransactionRequest
     */
    'transactionAmount': string;
    /**
     * This is the identifier assigned to your VASP
     * @type {string}
     * @memberof TravelRuleValidateTransactionRequest
     */
    'originatorVASPdid': string;
    /**
     * \"True\" if the originator and beneficiary is the same person and you therefore do not need to collect any information. \"False\" if it is a third-party transfer.
     * @type {boolean}
     * @memberof TravelRuleValidateTransactionRequest
     */
    'originatorEqualsBeneficiary': boolean;
    /**
     * This will also check if the transaction is a TRAVEL_RULE in the beneficiary VASP\'s jurisdiction
     * @type {boolean}
     * @memberof TravelRuleValidateTransactionRequest
     */
    'travelRuleBehavior': boolean;
    /**
     * This is the identifier assigned to the VASP the funds are being sent to
     * @type {string}
     * @memberof TravelRuleValidateTransactionRequest
     */
    'beneficiaryVASPdid': string;
    /**
     * Beneficiary VASP name
     * @type {string}
     * @memberof TravelRuleValidateTransactionRequest
     */
    'beneficiaryVASPname': string;
    /**
     * Beneficiary  name
     * @type {string}
     * @memberof TravelRuleValidateTransactionRequest
     */
    'beneficiaryName': string;
    /**
     * Beneficiary  name
     * @type {string}
     * @memberof TravelRuleValidateTransactionRequest
     */
    'beneficiaryAccountNumber': string;
    /**
     * 
     * @type {TravelRuleValidateTransactionRequestBeneficiaryAddress}
     * @memberof TravelRuleValidateTransactionRequest
     */
    'beneficiaryAddress': TravelRuleValidateTransactionRequestBeneficiaryAddress;
}
/**
 * Beneficiary  name
 * @export
 * @interface TravelRuleValidateTransactionRequestBeneficiaryAddress
 */
export interface TravelRuleValidateTransactionRequestBeneficiaryAddress {
    /**
     * Street address
     * @type {string}
     * @memberof TravelRuleValidateTransactionRequestBeneficiaryAddress
     */
    'street': string;
    /**
     * City
     * @type {string}
     * @memberof TravelRuleValidateTransactionRequestBeneficiaryAddress
     */
    'city': string;
    /**
     * State or province
     * @type {string}
     * @memberof TravelRuleValidateTransactionRequestBeneficiaryAddress
     */
    'state': string;
    /**
     * Postal or ZIP code
     * @type {string}
     * @memberof TravelRuleValidateTransactionRequestBeneficiaryAddress
     */
    'postalCode': string;
}
/**
 * 
 * @export
 * @interface TravelRuleValidateTransactionResponse
 */
export interface TravelRuleValidateTransactionResponse {
    /**
     * \"isValid\" will tell you if you have collected all the information needed for the travel rule data transfer. Once this field = \"true\", you can move on to the next step which is to transfer the front-end information to your back-end and perform Travel Rule Transaction create
     * @type {boolean}
     * @memberof TravelRuleValidateTransactionResponse
     */
    'isValid': boolean;
    /**
     * \"type\" will tell you if the virtual asset value converted to FIAT value of the withdrawal request is above (=TRAVELRULE) or below (=BELOW_THRESHOLD) the threshold in your jurisdiction. If it is to an unhosted wallet which does not require travel rule information to  be sent and only collected, it will say NON_CUSTODIAL.
     * @type {string}
     * @memberof TravelRuleValidateTransactionResponse
     */
    'type': string;
    /**
     * \"beneficiaryAddressType\" will tell you if your blockchain analytics provider or internal address book has been able to identify the wallet address.
     * @type {string}
     * @memberof TravelRuleValidateTransactionResponse
     */
    'beneficiaryAddressType': string;
    /**
     * \"addressSource\" will tell you if the address was found in your internal address book or identified by the blockchain analytics provider.
     * @type {string}
     * @memberof TravelRuleValidateTransactionResponse
     */
    'addressSource': string;
    /**
     * The VASP DID of the beneficiary VASP
     * @type {string}
     * @memberof TravelRuleValidateTransactionResponse
     */
    'beneficiaryVASPdid': string;
    /**
     * \"beneficiaryVASPname\" will tell you the name of the VASP that has been identified as the owner of the wallet address. This name is used in a subsequent call to get its DID.
     * @type {string}
     * @memberof TravelRuleValidateTransactionResponse
     */
    'beneficiaryVASPname': string;
    /**
     * \"errors/warnings\" will tell you what information about the beneficiary you need to collect from the sender.
     * @type {Array<string>}
     * @memberof TravelRuleValidateTransactionResponse
     */
    'warnings': Array<string>;
}
/**
 * 
 * @export
 * @interface UnfreezeTransactionResponse
 */
export interface UnfreezeTransactionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UnfreezeTransactionResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface UnmanagedWallet
 */
export interface UnmanagedWallet {
    /**
     * 
     * @type {string}
     * @memberof UnmanagedWallet
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UnmanagedWallet
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UnmanagedWallet
     */
    'customerRefId'?: string;
    /**
     * 
     * @type {Array<WalletAsset>}
     * @memberof UnmanagedWallet
     */
    'assets'?: Array<WalletAsset>;
}
/**
 * 
 * @export
 * @interface UnsignedMessage
 */
export interface UnsignedMessage {
    /**
     * 
     * @type {string}
     * @memberof UnsignedMessage
     */
    'content': string;
    /**
     * 
     * @type {number}
     * @memberof UnsignedMessage
     */
    'bip44addressIndex'?: number;
    /**
     * 
     * @type {number}
     * @memberof UnsignedMessage
     */
    'bip44change'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof UnsignedMessage
     */
    'derivationPath'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UnspentInput
 */
export interface UnspentInput {
    /**
     * 
     * @type {string}
     * @memberof UnspentInput
     */
    'txHash'?: string;
    /**
     * 
     * @type {number}
     * @memberof UnspentInput
     */
    'index'?: number;
}
/**
 * 
 * @export
 * @interface UnspentInputsResponse
 */
export interface UnspentInputsResponse {
    /**
     * 
     * @type {UnspentInput}
     * @memberof UnspentInputsResponse
     */
    'input'?: UnspentInput;
    /**
     * 
     * @type {string}
     * @memberof UnspentInputsResponse
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnspentInputsResponse
     */
    'amount'?: string;
    /**
     * 
     * @type {number}
     * @memberof UnspentInputsResponse
     */
    'confirmations'?: number;
    /**
     * 
     * @type {string}
     * @memberof UnspentInputsResponse
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTokenOwnershipStatusDto
 */
export interface UpdateTokenOwnershipStatusDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTokenOwnershipStatusDto
     */
    'status': UpdateTokenOwnershipStatusDtoStatusEnum;
}

export const UpdateTokenOwnershipStatusDtoStatusEnum = {
    Listed: 'LISTED',
    Archived: 'ARCHIVED'
} as const;

export type UpdateTokenOwnershipStatusDtoStatusEnum = typeof UpdateTokenOwnershipStatusDtoStatusEnum[keyof typeof UpdateTokenOwnershipStatusDtoStatusEnum];

/**
 * 
 * @export
 * @interface UpdateVaultAccountAssetAddressRequest
 */
export interface UpdateVaultAccountAssetAddressRequest {
    /**
     * The address description
     * @type {string}
     * @memberof UpdateVaultAccountAssetAddressRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateVaultAccountRequest
 */
export interface UpdateVaultAccountRequest {
    /**
     * Account Name
     * @type {string}
     * @memberof UpdateVaultAccountRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponse
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface ValidateAddressResponse
 */
export interface ValidateAddressResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ValidateAddressResponse
     */
    'isValid'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ValidateAddressResponse
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ValidateAddressResponse
     */
    'requiresTag'?: boolean;
}
/**
 * 
 * @export
 * @interface VaultAccount
 */
export interface VaultAccount {
    /**
     * 
     * @type {string}
     * @memberof VaultAccount
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultAccount
     */
    'name'?: string;
    /**
     * 
     * @type {Array<VaultAsset>}
     * @memberof VaultAccount
     */
    'assets'?: Array<VaultAsset>;
    /**
     * 
     * @type {boolean}
     * @memberof VaultAccount
     */
    'hiddenOnUI'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VaultAccount
     */
    'customerRefId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VaultAccount
     */
    'autoFuel'?: boolean;
}
/**
 * 
 * @export
 * @interface VaultAccountsPagedResponse
 */
export interface VaultAccountsPagedResponse {
    /**
     * 
     * @type {Array<VaultAccount>}
     * @memberof VaultAccountsPagedResponse
     */
    'accounts'?: Array<VaultAccount>;
    /**
     * 
     * @type {VaultAccountsPagedResponsePaging}
     * @memberof VaultAccountsPagedResponse
     */
    'paging'?: VaultAccountsPagedResponsePaging;
    /**
     * 
     * @type {string}
     * @memberof VaultAccountsPagedResponse
     */
    'previousUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultAccountsPagedResponse
     */
    'nextUrl'?: string;
}
/**
 * 
 * @export
 * @interface VaultAccountsPagedResponsePaging
 */
export interface VaultAccountsPagedResponsePaging {
    /**
     * 
     * @type {string}
     * @memberof VaultAccountsPagedResponsePaging
     */
    'before'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultAccountsPagedResponsePaging
     */
    'after'?: string;
}
/**
 * 
 * @export
 * @interface VaultAsset
 */
export interface VaultAsset {
    /**
     * 
     * @type {string}
     * @memberof VaultAsset
     */
    'id'?: string;
    /**
     * The total wallet balance. In EOS this value includes the network balance, self staking and pending refund. For all other coins it is the balance as it appears on the blockchain.
     * @type {string}
     * @memberof VaultAsset
     */
    'total'?: string;
    /**
     * Deprecated - replaced by \"total\"
     * @type {string}
     * @memberof VaultAsset
     * @deprecated
     */
    'balance'?: string;
    /**
     * Funds available for transfer. Equals the blockchain balance minus any locked amounts
     * @type {string}
     * @memberof VaultAsset
     */
    'available'?: string;
    /**
     * The cumulative balance of all transactions pending to be cleared
     * @type {string}
     * @memberof VaultAsset
     */
    'pending'?: string;
    /**
     * The cumulative frozen balance
     * @type {string}
     * @memberof VaultAsset
     */
    'frozen'?: string;
    /**
     * Funds in outgoing transactions that are not yet published to the network
     * @type {string}
     * @memberof VaultAsset
     */
    'lockedAmount'?: string;
    /**
     * Staked balance
     * @type {string}
     * @memberof VaultAsset
     */
    'staked'?: string;
    /**
     * The maximum BIP44 index used in deriving addresses for this wallet
     * @type {number}
     * @memberof VaultAsset
     */
    'maxBip44AddressIndexUsed'?: number;
    /**
     * The maximum BIP44 index used in deriving change addresses for this wallet
     * @type {number}
     * @memberof VaultAsset
     */
    'maxBip44ChangeAddressIndexUsed'?: number;
    /**
     * Deprecated
     * @type {number}
     * @memberof VaultAsset
     */
    'totalStakedCPU'?: number;
    /**
     * Deprecated
     * @type {string}
     * @memberof VaultAsset
     */
    'totalStakedNetwork'?: string;
    /**
     * Deprecated
     * @type {string}
     * @memberof VaultAsset
     */
    'selfStakedCPU'?: string;
    /**
     * Deprecated
     * @type {string}
     * @memberof VaultAsset
     */
    'selfStakedNetwork'?: string;
    /**
     * Deprecated
     * @type {string}
     * @memberof VaultAsset
     */
    'pendingRefundCPU'?: string;
    /**
     * Deprecated
     * @type {string}
     * @memberof VaultAsset
     */
    'pendingRefundNetwork'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultAsset
     */
    'blockHeight'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultAsset
     */
    'blockHash'?: string;
    /**
     * 
     * @type {RewardsInfo}
     * @memberof VaultAsset
     */
    'rewardsInfo'?: RewardsInfo;
}
/**
 * 
 * @export
 * @interface VaultWalletAddress
 */
export interface VaultWalletAddress {
    /**
     * 
     * @type {string}
     * @memberof VaultWalletAddress
     */
    'assetId'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultWalletAddress
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultWalletAddress
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultWalletAddress
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultWalletAddress
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultWalletAddress
     */
    'customerRefId'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultWalletAddress
     */
    'addressFormat'?: VaultWalletAddressAddressFormatEnum;
    /**
     * 
     * @type {string}
     * @memberof VaultWalletAddress
     */
    'legacyAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultWalletAddress
     */
    'enterpriseAddress'?: string;
    /**
     * 
     * @type {number}
     * @memberof VaultWalletAddress
     */
    'bip44AddressIndex'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VaultWalletAddress
     */
    'userDefined'?: boolean;
}

export const VaultWalletAddressAddressFormatEnum = {
    Segwit: 'SEGWIT',
    Legacy: 'LEGACY'
} as const;

export type VaultWalletAddressAddressFormatEnum = typeof VaultWalletAddressAddressFormatEnum[keyof typeof VaultWalletAddressAddressFormatEnum];

/**
 * 
 * @export
 * @interface WalletAsset
 */
export interface WalletAsset {
    /**
     * 
     * @type {string}
     * @memberof WalletAsset
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletAsset
     */
    'balance'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletAsset
     */
    'lockedAmount'?: string;
    /**
     * 
     * @type {ConfigChangeRequestStatus}
     * @memberof WalletAsset
     */
    'status'?: ConfigChangeRequestStatus;
    /**
     * 
     * @type {string}
     * @memberof WalletAsset
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletAsset
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletAsset
     */
    'activationTime'?: string;
}


/**
 * 
 * @export
 * @interface XBSettlementAsset
 */
export interface XBSettlementAsset {
    /**
     * 
     * @type {string}
     * @memberof XBSettlementAsset
     */
    'amount': string;
    /**
     * 
     * @type {XBSettlementAssetID}
     * @memberof XBSettlementAsset
     */
    'assetId'?: XBSettlementAssetID;
}
/**
 * @type XBSettlementAssetID
 * @export
 */
export type XBSettlementAssetID = XBSettlementCryptoAsset | XBSettlementFiatAsset;

/**
 * 
 * @export
 * @interface XBSettlementConfigCreationRequestBody
 */
export interface XBSettlementConfigCreationRequestBody {
    /**
     * The name for the cross-border settlement configuration
     * @type {string}
     * @memberof XBSettlementConfigCreationRequestBody
     */
    'name': string;
    /**
     * 
     * @type {XBSettlementCorridorId}
     * @memberof XBSettlementConfigCreationRequestBody
     */
    'corridorId': XBSettlementCorridorId;
    /**
     * 
     * @type {XBSettlementConfigStepsRecord}
     * @memberof XBSettlementConfigCreationRequestBody
     */
    'steps': XBSettlementConfigStepsRecord;
    /**
     * Slippage configuarion in basis points, the default value is 10%
     * @type {number}
     * @memberof XBSettlementConfigCreationRequestBody
     */
    'conversionSlippageBasisPoints'?: number;
}


/**
 * 
 * @export
 * @interface XBSettlementConfigEditRequestBody
 */
export interface XBSettlementConfigEditRequestBody {
    /**
     * The name for the cross-border settlement configuration
     * @type {string}
     * @memberof XBSettlementConfigEditRequestBody
     */
    'name': string;
    /**
     * 
     * @type {XBSettlementConfigStepsRecord}
     * @memberof XBSettlementConfigEditRequestBody
     */
    'steps': XBSettlementConfigStepsRecord;
    /**
     * Slippage configuarion in basis points, the default value is 10%
     * @type {number}
     * @memberof XBSettlementConfigEditRequestBody
     */
    'conversionSlippageBasisPoints'?: number;
}
/**
 * 
 * @export
 * @interface XBSettlementConfigModel
 */
export interface XBSettlementConfigModel {
    /**
     * Cross Bodrder configuraion unique id
     * @type {string}
     * @memberof XBSettlementConfigModel
     */
    'configId': string;
    /**
     * 
     * @type {XBSettlementCorridorId}
     * @memberof XBSettlementConfigModel
     */
    'corridorId': XBSettlementCorridorId;
    /**
     * The name for the cross-border ettlement configuration
     * @type {string}
     * @memberof XBSettlementConfigModel
     */
    'name': string;
    /**
     * 
     * @type {XBSettlementConfigStepsRecord}
     * @memberof XBSettlementConfigModel
     */
    'steps': XBSettlementConfigStepsRecord;
    /**
     * Slippage configuarion in basis points, the default value is 10%
     * @type {number}
     * @memberof XBSettlementConfigModel
     */
    'conversionSlippageBasisPoints': number;
    /**
     * The creation time in epoch format.
     * @type {number}
     * @memberof XBSettlementConfigModel
     */
    'createdAt': number;
}


/**
 * 
 * @export
 * @interface XBSettlementConfigStep
 */
export interface XBSettlementConfigStep {
    /**
     * 
     * @type {XBSettlementStepType}
     * @memberof XBSettlementConfigStep
     */
    'stepType': XBSettlementStepType;
    /**
     * 
     * @type {string}
     * @memberof XBSettlementConfigStep
     */
    'accountId': string;
}


/**
 * 
 * @export
 * @interface XBSettlementConfigStepsRecord
 */
export interface XBSettlementConfigStepsRecord {
    [key: string]: XBSettlementConfigStepsRecordValue | any;

    /**
     * 
     * @type {XBSettlementStepType}
     * @memberof XBSettlementConfigStepsRecord
     */
    'stepType'?: XBSettlementStepType;
}


/**
 * 
 * @export
 * @interface XBSettlementConfigStepsRecordValue
 */
export interface XBSettlementConfigStepsRecordValue {
    /**
     * 
     * @type {string}
     * @memberof XBSettlementConfigStepsRecordValue
     */
    'accountId': string;
    /**
     * 
     * @type {XBSettlementAssetID}
     * @memberof XBSettlementConfigStepsRecordValue
     */
    'inputAssetId'?: XBSettlementAssetID;
    /**
     * 
     * @type {XBSettlementAssetID}
     * @memberof XBSettlementConfigStepsRecordValue
     */
    'outputAssetId'?: XBSettlementAssetID;
}
/**
 * - MX_US : Mexico (MXN) to USA (USD) - CO_US : Colombia (COP) to USA (USD) - US_MX : USA (USD) to Mexico (MXN) - US_EU : USA (USD) to Europe Union (EUR) - US_UK : USA (USD) to United Kingdon (GBP) 
 * @export
 * @enum {string}
 */

export const XBSettlementCorridorId = {
    MxUs: 'MX_US',
    CoUs: 'CO_US',
    UsMx: 'US_MX',
    UsEu: 'US_EU',
    UsUk: 'US_UK'
} as const;

export type XBSettlementCorridorId = typeof XBSettlementCorridorId[keyof typeof XBSettlementCorridorId];


/**
 * 
 * @export
 * @interface XBSettlementCreateFlowRequestBody
 */
export interface XBSettlementCreateFlowRequestBody {
    /**
     * Cross Bodrder configuraion unique id
     * @type {string}
     * @memberof XBSettlementCreateFlowRequestBody
     */
    'configId': string;
    /**
     * The amount to transfer in this cross-border flow. The type of asset is defined by the cross-border settlement configuration.
     * @type {string}
     * @memberof XBSettlementCreateFlowRequestBody
     */
    'amount': string;
}
/**
 * - XLM_USDC_5F3T : USDC over Stellar network 
 * @export
 * @enum {string}
 */

export const XBSettlementCryptoAsset = {
    XlmUsdc5F3T: 'XLM_USDC_5F3T',
    Xlm: 'XLM'
} as const;

export type XBSettlementCryptoAsset = typeof XBSettlementCryptoAsset[keyof typeof XBSettlementCryptoAsset];


/**
 * 
 * @export
 * @enum {string}
 */

export const XBSettlementFiatAsset = {
    Usd: 'USD',
    Mxn: 'MXN',
    Cop: 'COP',
    Eur: 'EUR',
    Gbp: 'GBP'
} as const;

export type XBSettlementFiatAsset = typeof XBSettlementFiatAsset[keyof typeof XBSettlementFiatAsset];


/**
 * 
 * @export
 * @interface XBSettlementFlowExecutionModel
 */
export interface XBSettlementFlowExecutionModel {
    /**
     * The unique id for the cross-border flow.
     * @type {string}
     * @memberof XBSettlementFlowExecutionModel
     */
    'flowId': string;
    /**
     * Cross Bodrder configuraion unique id
     * @type {string}
     * @memberof XBSettlementFlowExecutionModel
     */
    'configId': string;
    /**
     * 
     * @type {XBSettlementAsset}
     * @memberof XBSettlementFlowExecutionModel
     */
    'inputAmount': XBSettlementAsset;
    /**
     * 
     * @type {XBSettlementAsset}
     * @memberof XBSettlementFlowExecutionModel
     */
    'outputAmount': XBSettlementAsset;
    /**
     * 
     * @type {XBSettlementAsset}
     * @memberof XBSettlementFlowExecutionModel
     */
    'totalFee': XBSettlementAsset;
    /**
     * The time the cross-border flow executed in epoch format.
     * @type {number}
     * @memberof XBSettlementFlowExecutionModel
     */
    'initiatedAt': number;
    /**
     * The id of the user which launched the flow
     * @type {string}
     * @memberof XBSettlementFlowExecutionModel
     */
    'initiatedBy': string;
    /**
     * 
     * @type {XBSettlementFlowExecutionStatus}
     * @memberof XBSettlementFlowExecutionModel
     */
    'state': XBSettlementFlowExecutionStatus;
    /**
     * 
     * @type {XBSettlementFlowStepsExecutionRecord}
     * @memberof XBSettlementFlowExecutionModel
     */
    'steps': XBSettlementFlowStepsExecutionRecord;
    /**
     * 
     * @type {XBSettlementFlowExecutionModelSelectedConversionSlippage}
     * @memberof XBSettlementFlowExecutionModel
     */
    'selectedConversionSlippage': XBSettlementFlowExecutionModelSelectedConversionSlippage;
}


/**
 * Indicates the selected slippage used during the flow since override logic may have taken place.
 * @export
 * @interface XBSettlementFlowExecutionModelSelectedConversionSlippage
 */
export interface XBSettlementFlowExecutionModelSelectedConversionSlippage {
    /**
     * 
     * @type {number}
     * @memberof XBSettlementFlowExecutionModelSelectedConversionSlippage
     */
    'basisPoints': number;
    /**
     * 
     * @type {XBSettlementFlowSelectedConversionSlippageReason}
     * @memberof XBSettlementFlowExecutionModelSelectedConversionSlippage
     */
    'reason': XBSettlementFlowSelectedConversionSlippageReason;
}


/**
 * 
 * @export
 * @interface XBSettlementFlowExecutionRequestBody
 */
export interface XBSettlementFlowExecutionRequestBody {
    /**
     * Slippage configuarion in basis points, the default value is 10%
     * @type {number}
     * @memberof XBSettlementFlowExecutionRequestBody
     */
    'conversionSlippageBasisPoints'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const XBSettlementFlowExecutionStatus = {
    NotLaunched: 'NOT_LAUNCHED',
    Processing: 'PROCESSING',
    Completed: 'COMPLETED',
    Failed: 'FAILED'
} as const;

export type XBSettlementFlowExecutionStatus = typeof XBSettlementFlowExecutionStatus[keyof typeof XBSettlementFlowExecutionStatus];


/**
 * 
 * @export
 * @interface XBSettlementFlowExecutionStep
 */
export interface XBSettlementFlowExecutionStep {
    /**
     * A unique id for the step execution
     * @type {string}
     * @memberof XBSettlementFlowExecutionStep
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof XBSettlementFlowExecutionStep
     */
    'accountId': string;
    /**
     * 
     * @type {XBSettlementFlowExecutionStepStatus}
     * @memberof XBSettlementFlowExecutionStep
     */
    'status': XBSettlementFlowExecutionStepStatus;
    /**
     * 
     * @type {XBSettlementAsset}
     * @memberof XBSettlementFlowExecutionStep
     */
    'inputAmount': XBSettlementAsset;
    /**
     * 
     * @type {XBSettlementAsset}
     * @memberof XBSettlementFlowExecutionStep
     */
    'outputAmount'?: XBSettlementAsset;
    /**
     * 
     * @type {XBSettlementAsset}
     * @memberof XBSettlementFlowExecutionStep
     */
    'fee'?: XBSettlementAsset;
    /**
     * The step execution start time in epoch format.
     * @type {number}
     * @memberof XBSettlementFlowExecutionStep
     */
    'startedAt'?: number;
    /**
     * The step execution end time in epoch format.
     * @type {number}
     * @memberof XBSettlementFlowExecutionStep
     */
    'completedAt'?: number;
    /**
     * Whether or not signing is required for executing the step.
     * @type {boolean}
     * @memberof XBSettlementFlowExecutionStep
     */
    'isSignRequired': boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const XBSettlementFlowExecutionStepStatus = {
    NotStarted: 'NOT_STARTED',
    Processing: 'PROCESSING',
    Completed: 'COMPLETED',
    Failed: 'FAILED'
} as const;

export type XBSettlementFlowExecutionStepStatus = typeof XBSettlementFlowExecutionStepStatus[keyof typeof XBSettlementFlowExecutionStepStatus];


/**
 * 
 * @export
 * @interface XBSettlementFlowPreviewModel
 */
export interface XBSettlementFlowPreviewModel {
    /**
     * The unique id for the cross-border flow.
     * @type {string}
     * @memberof XBSettlementFlowPreviewModel
     */
    'flowId': string;
    /**
     * Cross Bodrder configuraion unique id
     * @type {string}
     * @memberof XBSettlementFlowPreviewModel
     */
    'configId': string;
    /**
     * The conversion rate received from the on-ramp or off-ramp.
     * @type {string}
     * @memberof XBSettlementFlowPreviewModel
     */
    'conversionRate': string;
    /**
     * 
     * @type {XBSettlementAsset}
     * @memberof XBSettlementFlowPreviewModel
     */
    'inputAmount': XBSettlementAsset;
    /**
     * 
     * @type {XBSettlementAsset}
     * @memberof XBSettlementFlowPreviewModel
     */
    'estimatedOutputAmount': XBSettlementAsset;
    /**
     * 
     * @type {XBSettlementAsset}
     * @memberof XBSettlementFlowPreviewModel
     */
    'totalEstimatedFee': XBSettlementAsset;
    /**
     * The total *estimated* time for executing the cross-border flow.
     * @type {number}
     * @memberof XBSettlementFlowPreviewModel
     */
    'totalEstimatedTime': number;
    /**
     * 
     * @type {XBSettlementFlowStepsRecord}
     * @memberof XBSettlementFlowPreviewModel
     */
    'steps': XBSettlementFlowStepsRecord;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const XBSettlementFlowSelectedConversionSlippageReason = {
    Default: 'DEFAULT',
    Config: 'CONFIG',
    Flow: 'FLOW'
} as const;

export type XBSettlementFlowSelectedConversionSlippageReason = typeof XBSettlementFlowSelectedConversionSlippageReason[keyof typeof XBSettlementFlowSelectedConversionSlippageReason];


/**
 * 
 * @export
 * @interface XBSettlementFlowSetupStep
 */
export interface XBSettlementFlowSetupStep {
    /**
     * 
     * @type {string}
     * @memberof XBSettlementFlowSetupStep
     */
    'accountId': string;
    /**
     * 
     * @type {XBSettlementAsset}
     * @memberof XBSettlementFlowSetupStep
     */
    'inputAmount': XBSettlementAsset;
    /**
     * 
     * @type {XBSettlementAsset}
     * @memberof XBSettlementFlowSetupStep
     */
    'outputAmount': XBSettlementAsset;
    /**
     * 
     * @type {XBSettlementAsset}
     * @memberof XBSettlementFlowSetupStep
     */
    'estimatedFeeAmount': XBSettlementAsset;
    /**
     * The estimated time for executing the step.
     * @type {number}
     * @memberof XBSettlementFlowSetupStep
     */
    'estimatedTime': number;
    /**
     * Whether or not signing is required for executing the step.
     * @type {boolean}
     * @memberof XBSettlementFlowSetupStep
     */
    'isSignRequired': boolean;
}
/**
 * 
 * @export
 * @interface XBSettlementFlowStepsExecutionRecord
 */
export interface XBSettlementFlowStepsExecutionRecord {
    [key: string]: XBSettlementFlowExecutionStep | any;

    /**
     * 
     * @type {XBSettlementStepType}
     * @memberof XBSettlementFlowStepsExecutionRecord
     */
    'stepType'?: XBSettlementStepType;
}


/**
 * 
 * @export
 * @interface XBSettlementFlowStepsRecord
 */
export interface XBSettlementFlowStepsRecord {
    [key: string]: XBSettlementFlowSetupStep | any;

    /**
     * 
     * @type {XBSettlementStepType}
     * @memberof XBSettlementFlowStepsRecord
     */
    'stepType'?: XBSettlementStepType;
}


/**
 * 
 * @export
 * @interface XBSettlementGetAllConfigsResponse
 */
export interface XBSettlementGetAllConfigsResponse {
    /**
     * 
     * @type {Array<XBSettlementConfigModel>}
     * @memberof XBSettlementGetAllConfigsResponse
     */
    'configurations': Array<XBSettlementConfigModel>;
}
/**
 * 
 * @export
 * @interface XBSettlementGetFlowResponse
 */
export interface XBSettlementGetFlowResponse {
    /**
     * 
     * @type {XBSettlementFlowPreviewModel}
     * @memberof XBSettlementGetFlowResponse
     */
    'preview'?: XBSettlementFlowPreviewModel;
    /**
     * 
     * @type {XBSettlementFlowExecutionModel}
     * @memberof XBSettlementGetFlowResponse
     */
    'execution'?: XBSettlementFlowExecutionModel;
}
/**
 * - ON_RAMP : A service that allows for the exchange of fiat currencies for cryptocurrencies. An OnRamp input value will always be fiat and output value crypto asset. - VAULT_ACCOUNT : Fireblocks Vault account - OFF_RAMP : A service that allows for the exchange of cryptocurrencies for fiat. An OffRamp input value will always be a crypto asset and output value be fiat. - FIAT_DESTINATION : Fiat account 
 * @export
 * @enum {string}
 */

export const XBSettlementStepType = {
    OnRamp: 'ON_RAMP',
    VaultAccount: 'VAULT_ACCOUNT',
    OffRamp: 'OFF_RAMP',
    FiatDestination: 'FIAT_DESTINATION'
} as const;

export type XBSettlementStepType = typeof XBSettlementStepType[keyof typeof XBSettlementStepType];






    /**
 * AuditLogsApi - axios parameter creator
 * @export
 */
export const AuditLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all audits
         * @summary Get audit logs
         * @param {'DAY' | 'WEEK'} timePeriod The last time period to fetch audit logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudits: async (timePeriod: 'DAY' | 'WEEK', ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'timePeriod' is not null or undefined
            assertParamExists('getAudits', 'timePeriod', timePeriod)
            const localVarPath = `/audits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timePeriod !== undefined) {
                localVarQueryParameter['timePeriod'] = timePeriod;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditLogsApi - functional programming interface
 * @export
 */
export const AuditLogsApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = AuditLogsApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * Get all audits
         * @summary Get audit logs
         * @param {'DAY' | 'WEEK'} timePeriod The last time period to fetch audit logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAudits(timePeriod: 'DAY' | 'WEEK', ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAudits(timePeriod, );
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for getAudits operation in AuditLogsApi.
 * @export
 * @interface AuditLogsApiGetAuditsRequest
 */
export interface AuditLogsApiGetAuditsRequest {
    /**
     * The last time period to fetch audit logs
     * @type {'DAY' | 'WEEK'}
     * @memberof AuditLogsApiGetAudits
     */
    readonly timePeriod: 'DAY' | 'WEEK'
}

/**
 * AuditLogsApi - object-oriented interface
 * @export
 * @class AuditLogsApi
 * @extends {BaseAPI}
 */
export class AuditLogsApi extends BaseAPI {
    /**
     * Get all audits
     * @summary Get audit logs
     * @param {AuditLogsApiGetAuditsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogsApi
     */
    public getAudits(requestParameters: AuditLogsApiGetAuditsRequest, ) {
        return AuditLogsApiFp(this.httpClient).getAudits(requestParameters.timePeriod, );
    }
}





    /**
 * ContractsApi - axios parameter creator
 * @export
 */
export const ContractsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds an asset to an existing contract.
         * @summary Add an asset to a contract
         * @param {string} contractId The ID of the contract
         * @param {string} assetId The ID of the asset to add
         * @param {AddAssetToContractRequest} [addAssetToContractRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetToContract: async (contractId: string, assetId: string, addAssetToContractRequest?: AddAssetToContractRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('addAssetToContract', 'contractId', contractId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('addAssetToContract', 'assetId', assetId)
            const localVarPath = `/contracts/{contractId}/{assetId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = addAssetToContractRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Creates a new contract.
         * @summary Create a contract
         * @param {CreateContractRequest} [createContractRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContract: async (createContractRequest?: CreateContractRequest, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = createContractRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Deletes a contract by ID.
         * @summary Delete a contract
         * @param {string} contractId The ID of the contract to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContract: async (contractId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('deleteContract', 'contractId', contractId)
            const localVarPath = `/contracts/{contractId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'DELETE'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns a contract asset by ID.
         * @summary Find a contract asset
         * @param {string} contractId The ID of the contract
         * @param {string} assetId The ID of the asset to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetInContract: async (contractId: string, assetId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getAssetInContract', 'contractId', contractId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getAssetInContract', 'assetId', assetId)
            const localVarPath = `/contracts/{contractId}/{assetId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns a contract by ID.
         * @summary Find a specific contract
         * @param {string} contractId The ID of the contract to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractById: async (contractId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getContractById', 'contractId', contractId)
            const localVarPath = `/contracts/{contractId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Gets a list of contracts.
         * @summary List contracts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContracts: async (): Promise<AxiosRequestConfig> => {
            const localVarPath = `/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Deletes a contract asset by ID.
         * @summary Delete a contract asset
         * @param {string} contractId The ID of the contract
         * @param {string} assetId The ID of the asset to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetFromContract: async (contractId: string, assetId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('removeAssetFromContract', 'contractId', contractId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('removeAssetFromContract', 'assetId', assetId)
            const localVarPath = `/contracts/{contractId}/{assetId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'DELETE'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractsApi - functional programming interface
 * @export
 */
export const ContractsApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = ContractsApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * Adds an asset to an existing contract.
         * @summary Add an asset to a contract
         * @param {string} contractId The ID of the contract
         * @param {string} assetId The ID of the asset to add
         * @param {AddAssetToContractRequest} [addAssetToContractRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAssetToContract(contractId: string, assetId: string, addAssetToContractRequest?: AddAssetToContractRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalWalletAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAssetToContract(contractId, assetId, addAssetToContractRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Creates a new contract.
         * @summary Create a contract
         * @param {CreateContractRequest} [createContractRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContract(createContractRequest?: CreateContractRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnmanagedWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContract(createContractRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Deletes a contract by ID.
         * @summary Delete a contract
         * @param {string} contractId The ID of the contract to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContract(contractId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContract(contractId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns a contract asset by ID.
         * @summary Find a contract asset
         * @param {string} contractId The ID of the contract
         * @param {string} assetId The ID of the asset to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetInContract(contractId: string, assetId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalWalletAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetInContract(contractId, assetId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns a contract by ID.
         * @summary Find a specific contract
         * @param {string} contractId The ID of the contract to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractById(contractId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnmanagedWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractById(contractId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Gets a list of contracts.
         * @summary List contracts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContracts(): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UnmanagedWallet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContracts();
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Deletes a contract asset by ID.
         * @summary Delete a contract asset
         * @param {string} contractId The ID of the contract
         * @param {string} assetId The ID of the asset to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAssetFromContract(contractId: string, assetId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAssetFromContract(contractId, assetId, );
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for addAssetToContract operation in ContractsApi.
 * @export
 * @interface ContractsApiAddAssetToContractRequest
 */
export interface ContractsApiAddAssetToContractRequest {
    /**
     * The ID of the contract
     * @type {string}
     * @memberof ContractsApiAddAssetToContract
     */
    readonly contractId: string

    /**
     * The ID of the asset to add
     * @type {string}
     * @memberof ContractsApiAddAssetToContract
     */
    readonly assetId: string

    /**
     * 
     * @type {AddAssetToContractRequest}
     * @memberof ContractsApiAddAssetToContract
     */
    readonly addAssetToContractRequest?: AddAssetToContractRequest
}

/**
 * Request parameters for createContract operation in ContractsApi.
 * @export
 * @interface ContractsApiCreateContractRequest
 */
export interface ContractsApiCreateContractRequest {
    /**
     * 
     * @type {CreateContractRequest}
     * @memberof ContractsApiCreateContract
     */
    readonly createContractRequest?: CreateContractRequest
}

/**
 * Request parameters for deleteContract operation in ContractsApi.
 * @export
 * @interface ContractsApiDeleteContractRequest
 */
export interface ContractsApiDeleteContractRequest {
    /**
     * The ID of the contract to delete
     * @type {string}
     * @memberof ContractsApiDeleteContract
     */
    readonly contractId: string
}

/**
 * Request parameters for getAssetInContract operation in ContractsApi.
 * @export
 * @interface ContractsApiGetAssetInContractRequest
 */
export interface ContractsApiGetAssetInContractRequest {
    /**
     * The ID of the contract
     * @type {string}
     * @memberof ContractsApiGetAssetInContract
     */
    readonly contractId: string

    /**
     * The ID of the asset to return
     * @type {string}
     * @memberof ContractsApiGetAssetInContract
     */
    readonly assetId: string
}

/**
 * Request parameters for getContractById operation in ContractsApi.
 * @export
 * @interface ContractsApiGetContractByIdRequest
 */
export interface ContractsApiGetContractByIdRequest {
    /**
     * The ID of the contract to return
     * @type {string}
     * @memberof ContractsApiGetContractById
     */
    readonly contractId: string
}

/**
 * Request parameters for removeAssetFromContract operation in ContractsApi.
 * @export
 * @interface ContractsApiRemoveAssetFromContractRequest
 */
export interface ContractsApiRemoveAssetFromContractRequest {
    /**
     * The ID of the contract
     * @type {string}
     * @memberof ContractsApiRemoveAssetFromContract
     */
    readonly contractId: string

    /**
     * The ID of the asset to delete
     * @type {string}
     * @memberof ContractsApiRemoveAssetFromContract
     */
    readonly assetId: string
}

/**
 * ContractsApi - object-oriented interface
 * @export
 * @class ContractsApi
 * @extends {BaseAPI}
 */
export class ContractsApi extends BaseAPI {
    /**
     * Adds an asset to an existing contract.
     * @summary Add an asset to a contract
     * @param {ContractsApiAddAssetToContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public addAssetToContract(requestParameters: ContractsApiAddAssetToContractRequest, ) {
        return ContractsApiFp(this.httpClient).addAssetToContract(requestParameters.contractId, requestParameters.assetId, requestParameters.addAssetToContractRequest, );
    }

    /**
     * Creates a new contract.
     * @summary Create a contract
     * @param {ContractsApiCreateContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public createContract(requestParameters: ContractsApiCreateContractRequest = {}, ) {
        return ContractsApiFp(this.httpClient).createContract(requestParameters.createContractRequest, );
    }

    /**
     * Deletes a contract by ID.
     * @summary Delete a contract
     * @param {ContractsApiDeleteContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public deleteContract(requestParameters: ContractsApiDeleteContractRequest, ) {
        return ContractsApiFp(this.httpClient).deleteContract(requestParameters.contractId, );
    }

    /**
     * Returns a contract asset by ID.
     * @summary Find a contract asset
     * @param {ContractsApiGetAssetInContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getAssetInContract(requestParameters: ContractsApiGetAssetInContractRequest, ) {
        return ContractsApiFp(this.httpClient).getAssetInContract(requestParameters.contractId, requestParameters.assetId, );
    }

    /**
     * Returns a contract by ID.
     * @summary Find a specific contract
     * @param {ContractsApiGetContractByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getContractById(requestParameters: ContractsApiGetContractByIdRequest, ) {
        return ContractsApiFp(this.httpClient).getContractById(requestParameters.contractId, );
    }

    /**
     * Gets a list of contracts.
     * @summary List contracts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getContracts() {
        return ContractsApiFp(this.httpClient).getContracts();
    }

    /**
     * Deletes a contract asset by ID.
     * @summary Delete a contract asset
     * @param {ContractsApiRemoveAssetFromContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public removeAssetFromContract(requestParameters: ContractsApiRemoveAssetFromContractRequest, ) {
        return ContractsApiFp(this.httpClient).removeAssetFromContract(requestParameters.contractId, requestParameters.assetId, );
    }
}





    /**
 * ExchangeAccountsApi - axios parameter creator
 * @export
 */
export const ExchangeAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Convert assets within an exchange account
         * @summary Convert exchange account funds from the source asset to the destination asset. Coinbase (USD to USDC, USDC to USD) and Bitso (MXN to USD) are supported conversions.
         * @param {string} exchangeAccountId The ID of the exchange account. Please make sure the exchange supports conversions. To find the ID of your exchange account, use GET/exchange_accounts.
         * @param {ConvertExchangeAccountRequest} [convertExchangeAccountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertAssets: async (exchangeAccountId: string, convertExchangeAccountRequest?: ConvertExchangeAccountRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'exchangeAccountId' is not null or undefined
            assertParamExists('convertAssets', 'exchangeAccountId', exchangeAccountId)
            const localVarPath = `/exchange_accounts/{exchangeAccountId}/convert`
                .replace(`{${"exchangeAccountId"}}`, encodeURIComponent(String(exchangeAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = convertExchangeAccountRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns an asset for an exchange account.
         * @summary Find an asset for an exchange account
         * @param {string} exchangeAccountId The ID of the exchange account to return
         * @param {string} assetId The ID of the asset to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeAccountAsset: async (exchangeAccountId: string, assetId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'exchangeAccountId' is not null or undefined
            assertParamExists('getExchangeAccountAsset', 'exchangeAccountId', exchangeAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getExchangeAccountAsset', 'assetId', assetId)
            const localVarPath = `/exchange_accounts/{exchangeAccountId}/{assetId}`
                .replace(`{${"exchangeAccountId"}}`, encodeURIComponent(String(exchangeAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns an exchange account by ID.
         * @summary Find a specific exchange account
         * @param {string} exchangeAccountId The ID of the exchange account to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeAccountById: async (exchangeAccountId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'exchangeAccountId' is not null or undefined
            assertParamExists('getExchangeAccountById', 'exchangeAccountId', exchangeAccountId)
            const localVarPath = `/exchange_accounts/{exchangeAccountId}`
                .replace(`{${"exchangeAccountId"}}`, encodeURIComponent(String(exchangeAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns all exchange accounts.
         * @summary List exchange accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeAccounts: async (): Promise<AxiosRequestConfig> => {
            const localVarPath = `/exchange_accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Transfers funds between trading accounts under the same exchange account.
         * @summary Internal transfer for exchange accounts
         * @param {string} exchangeAccountId The ID of the exchange account to return
         * @param {CreateInternalTransferRequest} [createInternalTransferRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalTransfer: async (exchangeAccountId: string, createInternalTransferRequest?: CreateInternalTransferRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'exchangeAccountId' is not null or undefined
            assertParamExists('internalTransfer', 'exchangeAccountId', exchangeAccountId)
            const localVarPath = `/exchange_accounts/{exchangeAccountId}/internal_transfer`
                .replace(`{${"exchangeAccountId"}}`, encodeURIComponent(String(exchangeAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = createInternalTransferRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * ExchangeAccountsApi - functional programming interface
 * @export
 */
export const ExchangeAccountsApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = ExchangeAccountsApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * Convert assets within an exchange account
         * @summary Convert exchange account funds from the source asset to the destination asset. Coinbase (USD to USDC, USDC to USD) and Bitso (MXN to USD) are supported conversions.
         * @param {string} exchangeAccountId The ID of the exchange account. Please make sure the exchange supports conversions. To find the ID of your exchange account, use GET/exchange_accounts.
         * @param {ConvertExchangeAccountRequest} [convertExchangeAccountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async convertAssets(exchangeAccountId: string, convertExchangeAccountRequest?: ConvertExchangeAccountRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.convertAssets(exchangeAccountId, convertExchangeAccountRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns an asset for an exchange account.
         * @summary Find an asset for an exchange account
         * @param {string} exchangeAccountId The ID of the exchange account to return
         * @param {string} assetId The ID of the asset to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeAccountAsset(exchangeAccountId: string, assetId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeAccountAsset(exchangeAccountId, assetId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns an exchange account by ID.
         * @summary Find a specific exchange account
         * @param {string} exchangeAccountId The ID of the exchange account to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeAccountById(exchangeAccountId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeAccountById(exchangeAccountId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns all exchange accounts.
         * @summary List exchange accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeAccounts(): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExchangeAccount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeAccounts();
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Transfers funds between trading accounts under the same exchange account.
         * @summary Internal transfer for exchange accounts
         * @param {string} exchangeAccountId The ID of the exchange account to return
         * @param {CreateInternalTransferRequest} [createInternalTransferRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async internalTransfer(exchangeAccountId: string, createInternalTransferRequest?: CreateInternalTransferRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.internalTransfer(exchangeAccountId, createInternalTransferRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for convertAssets operation in ExchangeAccountsApi.
 * @export
 * @interface ExchangeAccountsApiConvertAssetsRequest
 */
export interface ExchangeAccountsApiConvertAssetsRequest {
    /**
     * The ID of the exchange account. Please make sure the exchange supports conversions. To find the ID of your exchange account, use GET/exchange_accounts.
     * @type {string}
     * @memberof ExchangeAccountsApiConvertAssets
     */
    readonly exchangeAccountId: string

    /**
     * 
     * @type {ConvertExchangeAccountRequest}
     * @memberof ExchangeAccountsApiConvertAssets
     */
    readonly convertExchangeAccountRequest?: ConvertExchangeAccountRequest
}

/**
 * Request parameters for getExchangeAccountAsset operation in ExchangeAccountsApi.
 * @export
 * @interface ExchangeAccountsApiGetExchangeAccountAssetRequest
 */
export interface ExchangeAccountsApiGetExchangeAccountAssetRequest {
    /**
     * The ID of the exchange account to return
     * @type {string}
     * @memberof ExchangeAccountsApiGetExchangeAccountAsset
     */
    readonly exchangeAccountId: string

    /**
     * The ID of the asset to return
     * @type {string}
     * @memberof ExchangeAccountsApiGetExchangeAccountAsset
     */
    readonly assetId: string
}

/**
 * Request parameters for getExchangeAccountById operation in ExchangeAccountsApi.
 * @export
 * @interface ExchangeAccountsApiGetExchangeAccountByIdRequest
 */
export interface ExchangeAccountsApiGetExchangeAccountByIdRequest {
    /**
     * The ID of the exchange account to return
     * @type {string}
     * @memberof ExchangeAccountsApiGetExchangeAccountById
     */
    readonly exchangeAccountId: string
}

/**
 * Request parameters for internalTransfer operation in ExchangeAccountsApi.
 * @export
 * @interface ExchangeAccountsApiInternalTransferRequest
 */
export interface ExchangeAccountsApiInternalTransferRequest {
    /**
     * The ID of the exchange account to return
     * @type {string}
     * @memberof ExchangeAccountsApiInternalTransfer
     */
    readonly exchangeAccountId: string

    /**
     * 
     * @type {CreateInternalTransferRequest}
     * @memberof ExchangeAccountsApiInternalTransfer
     */
    readonly createInternalTransferRequest?: CreateInternalTransferRequest
}

/**
 * ExchangeAccountsApi - object-oriented interface
 * @export
 * @class ExchangeAccountsApi
 * @extends {BaseAPI}
 */
export class ExchangeAccountsApi extends BaseAPI {
    /**
     * Convert assets within an exchange account
     * @summary Convert exchange account funds from the source asset to the destination asset. Coinbase (USD to USDC, USDC to USD) and Bitso (MXN to USD) are supported conversions.
     * @param {ExchangeAccountsApiConvertAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeAccountsApi
     */
    public convertAssets(requestParameters: ExchangeAccountsApiConvertAssetsRequest, ) {
        return ExchangeAccountsApiFp(this.httpClient).convertAssets(requestParameters.exchangeAccountId, requestParameters.convertExchangeAccountRequest, );
    }

    /**
     * Returns an asset for an exchange account.
     * @summary Find an asset for an exchange account
     * @param {ExchangeAccountsApiGetExchangeAccountAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeAccountsApi
     */
    public getExchangeAccountAsset(requestParameters: ExchangeAccountsApiGetExchangeAccountAssetRequest, ) {
        return ExchangeAccountsApiFp(this.httpClient).getExchangeAccountAsset(requestParameters.exchangeAccountId, requestParameters.assetId, );
    }

    /**
     * Returns an exchange account by ID.
     * @summary Find a specific exchange account
     * @param {ExchangeAccountsApiGetExchangeAccountByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeAccountsApi
     */
    public getExchangeAccountById(requestParameters: ExchangeAccountsApiGetExchangeAccountByIdRequest, ) {
        return ExchangeAccountsApiFp(this.httpClient).getExchangeAccountById(requestParameters.exchangeAccountId, );
    }

    /**
     * Returns all exchange accounts.
     * @summary List exchange accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeAccountsApi
     */
    public getExchangeAccounts() {
        return ExchangeAccountsApiFp(this.httpClient).getExchangeAccounts();
    }

    /**
     * Transfers funds between trading accounts under the same exchange account.
     * @summary Internal transfer for exchange accounts
     * @param {ExchangeAccountsApiInternalTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeAccountsApi
     */
    public internalTransfer(requestParameters: ExchangeAccountsApiInternalTransferRequest, ) {
        return ExchangeAccountsApiFp(this.httpClient).internalTransfer(requestParameters.exchangeAccountId, requestParameters.createInternalTransferRequest, );
    }
}





    /**
 * ExternalWalletsApi - axios parameter creator
 * @export
 */
export const ExternalWalletsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds an asset to an existing external wallet.
         * @summary Add an asset to an external wallet.
         * @param {string} walletId The ID of the wallet
         * @param {string} assetId The ID of the asset to add
         * @param {AddAssetToExternalWalletRequest} [addAssetToExternalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetToExternalWallet: async (walletId: string, assetId: string, addAssetToExternalWalletRequest?: AddAssetToExternalWalletRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('addAssetToExternalWallet', 'walletId', walletId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('addAssetToExternalWallet', 'assetId', assetId)
            const localVarPath = `/external_wallets/{walletId}/{assetId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = addAssetToExternalWalletRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Creates a new external wallet with the requested name.
         * @summary Create an external wallet
         * @param {CreateInternalWalletRequest} [createInternalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalWallet: async (createInternalWalletRequest?: CreateInternalWalletRequest, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/external_wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = createInternalWalletRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Deletes an external wallet by ID.
         * @summary Delete an external wallet
         * @param {string} walletId The ID of the wallet to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExternalWallet: async (walletId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('deleteExternalWallet', 'walletId', walletId)
            const localVarPath = `/external_wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'DELETE'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns an external wallet by wallet ID and asset ID.
         * @summary Get an asset from an external wallet
         * @param {string} walletId The ID of the wallet
         * @param {string} assetId The ID of the asset to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetInExternalWallet: async (walletId: string, assetId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getAssetInExternalWallet', 'walletId', walletId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getAssetInExternalWallet', 'assetId', assetId)
            const localVarPath = `/external_wallets/{walletId}/{assetId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns an external wallet by ID.
         * @summary Find an external wallet
         * @param {string} walletId The ID of the wallet to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalWalletById: async (walletId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getExternalWalletById', 'walletId', walletId)
            const localVarPath = `/external_wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Gets a list of external wallets under the workspace.
         * @summary List external wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalWallets: async (): Promise<AxiosRequestConfig> => {
            const localVarPath = `/external_wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Deletes an external wallet asset by ID.
         * @summary Delete an asset from an external wallet
         * @param {string} walletId The ID of the wallet
         * @param {string} assetId The ID of the asset to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetFromExternalWallet: async (walletId: string, assetId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('removeAssetFromExternalWallet', 'walletId', walletId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('removeAssetFromExternalWallet', 'assetId', assetId)
            const localVarPath = `/external_wallets/{walletId}/{assetId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'DELETE'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Sets an AML/KYT customer reference ID for the specific external wallet.
         * @summary Set an AML customer reference ID for an external wallet
         * @param {string} walletId The wallet ID
         * @param {SetCustomerRefIdForVaultAccountRequest} setCustomerRefIdForVaultAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomerRefIdForExternalWallet: async (walletId: string, setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('setCustomerRefIdForExternalWallet', 'walletId', walletId)
            // verify required parameter 'setCustomerRefIdForVaultAccountRequest' is not null or undefined
            assertParamExists('setCustomerRefIdForExternalWallet', 'setCustomerRefIdForVaultAccountRequest', setCustomerRefIdForVaultAccountRequest)
            const localVarPath = `/external_wallets/{walletId}/set_customer_ref_id`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = setCustomerRefIdForVaultAccountRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * ExternalWalletsApi - functional programming interface
 * @export
 */
export const ExternalWalletsApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = ExternalWalletsApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * Adds an asset to an existing external wallet.
         * @summary Add an asset to an external wallet.
         * @param {string} walletId The ID of the wallet
         * @param {string} assetId The ID of the asset to add
         * @param {AddAssetToExternalWalletRequest} [addAssetToExternalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAssetToExternalWallet(walletId: string, assetId: string, addAssetToExternalWalletRequest?: AddAssetToExternalWalletRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalWalletAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAssetToExternalWallet(walletId, assetId, addAssetToExternalWalletRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Creates a new external wallet with the requested name.
         * @summary Create an external wallet
         * @param {CreateInternalWalletRequest} [createInternalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExternalWallet(createInternalWalletRequest?: CreateInternalWalletRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnmanagedWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExternalWallet(createInternalWalletRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Deletes an external wallet by ID.
         * @summary Delete an external wallet
         * @param {string} walletId The ID of the wallet to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExternalWallet(walletId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExternalWallet(walletId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns an external wallet by wallet ID and asset ID.
         * @summary Get an asset from an external wallet
         * @param {string} walletId The ID of the wallet
         * @param {string} assetId The ID of the asset to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetInExternalWallet(walletId: string, assetId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalWalletAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetInExternalWallet(walletId, assetId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns an external wallet by ID.
         * @summary Find an external wallet
         * @param {string} walletId The ID of the wallet to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalWalletById(walletId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnmanagedWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalWalletById(walletId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Gets a list of external wallets under the workspace.
         * @summary List external wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalWallets(): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UnmanagedWallet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalWallets();
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Deletes an external wallet asset by ID.
         * @summary Delete an asset from an external wallet
         * @param {string} walletId The ID of the wallet
         * @param {string} assetId The ID of the asset to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAssetFromExternalWallet(walletId: string, assetId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAssetFromExternalWallet(walletId, assetId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Sets an AML/KYT customer reference ID for the specific external wallet.
         * @summary Set an AML customer reference ID for an external wallet
         * @param {string} walletId The wallet ID
         * @param {SetCustomerRefIdForVaultAccountRequest} setCustomerRefIdForVaultAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCustomerRefIdForExternalWallet(walletId: string, setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCustomerRefIdForExternalWallet(walletId, setCustomerRefIdForVaultAccountRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for addAssetToExternalWallet operation in ExternalWalletsApi.
 * @export
 * @interface ExternalWalletsApiAddAssetToExternalWalletRequest
 */
export interface ExternalWalletsApiAddAssetToExternalWalletRequest {
    /**
     * The ID of the wallet
     * @type {string}
     * @memberof ExternalWalletsApiAddAssetToExternalWallet
     */
    readonly walletId: string

    /**
     * The ID of the asset to add
     * @type {string}
     * @memberof ExternalWalletsApiAddAssetToExternalWallet
     */
    readonly assetId: string

    /**
     * 
     * @type {AddAssetToExternalWalletRequest}
     * @memberof ExternalWalletsApiAddAssetToExternalWallet
     */
    readonly addAssetToExternalWalletRequest?: AddAssetToExternalWalletRequest
}

/**
 * Request parameters for createExternalWallet operation in ExternalWalletsApi.
 * @export
 * @interface ExternalWalletsApiCreateExternalWalletRequest
 */
export interface ExternalWalletsApiCreateExternalWalletRequest {
    /**
     * 
     * @type {CreateInternalWalletRequest}
     * @memberof ExternalWalletsApiCreateExternalWallet
     */
    readonly createInternalWalletRequest?: CreateInternalWalletRequest
}

/**
 * Request parameters for deleteExternalWallet operation in ExternalWalletsApi.
 * @export
 * @interface ExternalWalletsApiDeleteExternalWalletRequest
 */
export interface ExternalWalletsApiDeleteExternalWalletRequest {
    /**
     * The ID of the wallet to delete
     * @type {string}
     * @memberof ExternalWalletsApiDeleteExternalWallet
     */
    readonly walletId: string
}

/**
 * Request parameters for getAssetInExternalWallet operation in ExternalWalletsApi.
 * @export
 * @interface ExternalWalletsApiGetAssetInExternalWalletRequest
 */
export interface ExternalWalletsApiGetAssetInExternalWalletRequest {
    /**
     * The ID of the wallet
     * @type {string}
     * @memberof ExternalWalletsApiGetAssetInExternalWallet
     */
    readonly walletId: string

    /**
     * The ID of the asset to return
     * @type {string}
     * @memberof ExternalWalletsApiGetAssetInExternalWallet
     */
    readonly assetId: string
}

/**
 * Request parameters for getExternalWalletById operation in ExternalWalletsApi.
 * @export
 * @interface ExternalWalletsApiGetExternalWalletByIdRequest
 */
export interface ExternalWalletsApiGetExternalWalletByIdRequest {
    /**
     * The ID of the wallet to return
     * @type {string}
     * @memberof ExternalWalletsApiGetExternalWalletById
     */
    readonly walletId: string
}

/**
 * Request parameters for removeAssetFromExternalWallet operation in ExternalWalletsApi.
 * @export
 * @interface ExternalWalletsApiRemoveAssetFromExternalWalletRequest
 */
export interface ExternalWalletsApiRemoveAssetFromExternalWalletRequest {
    /**
     * The ID of the wallet
     * @type {string}
     * @memberof ExternalWalletsApiRemoveAssetFromExternalWallet
     */
    readonly walletId: string

    /**
     * The ID of the asset to delete
     * @type {string}
     * @memberof ExternalWalletsApiRemoveAssetFromExternalWallet
     */
    readonly assetId: string
}

/**
 * Request parameters for setCustomerRefIdForExternalWallet operation in ExternalWalletsApi.
 * @export
 * @interface ExternalWalletsApiSetCustomerRefIdForExternalWalletRequest
 */
export interface ExternalWalletsApiSetCustomerRefIdForExternalWalletRequest {
    /**
     * The wallet ID
     * @type {string}
     * @memberof ExternalWalletsApiSetCustomerRefIdForExternalWallet
     */
    readonly walletId: string

    /**
     * 
     * @type {SetCustomerRefIdForVaultAccountRequest}
     * @memberof ExternalWalletsApiSetCustomerRefIdForExternalWallet
     */
    readonly setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest
}

/**
 * ExternalWalletsApi - object-oriented interface
 * @export
 * @class ExternalWalletsApi
 * @extends {BaseAPI}
 */
export class ExternalWalletsApi extends BaseAPI {
    /**
     * Adds an asset to an existing external wallet.
     * @summary Add an asset to an external wallet.
     * @param {ExternalWalletsApiAddAssetToExternalWalletRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalWalletsApi
     */
    public addAssetToExternalWallet(requestParameters: ExternalWalletsApiAddAssetToExternalWalletRequest, ) {
        return ExternalWalletsApiFp(this.httpClient).addAssetToExternalWallet(requestParameters.walletId, requestParameters.assetId, requestParameters.addAssetToExternalWalletRequest, );
    }

    /**
     * Creates a new external wallet with the requested name.
     * @summary Create an external wallet
     * @param {ExternalWalletsApiCreateExternalWalletRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalWalletsApi
     */
    public createExternalWallet(requestParameters: ExternalWalletsApiCreateExternalWalletRequest = {}, ) {
        return ExternalWalletsApiFp(this.httpClient).createExternalWallet(requestParameters.createInternalWalletRequest, );
    }

    /**
     * Deletes an external wallet by ID.
     * @summary Delete an external wallet
     * @param {ExternalWalletsApiDeleteExternalWalletRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalWalletsApi
     */
    public deleteExternalWallet(requestParameters: ExternalWalletsApiDeleteExternalWalletRequest, ) {
        return ExternalWalletsApiFp(this.httpClient).deleteExternalWallet(requestParameters.walletId, );
    }

    /**
     * Returns an external wallet by wallet ID and asset ID.
     * @summary Get an asset from an external wallet
     * @param {ExternalWalletsApiGetAssetInExternalWalletRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalWalletsApi
     */
    public getAssetInExternalWallet(requestParameters: ExternalWalletsApiGetAssetInExternalWalletRequest, ) {
        return ExternalWalletsApiFp(this.httpClient).getAssetInExternalWallet(requestParameters.walletId, requestParameters.assetId, );
    }

    /**
     * Returns an external wallet by ID.
     * @summary Find an external wallet
     * @param {ExternalWalletsApiGetExternalWalletByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalWalletsApi
     */
    public getExternalWalletById(requestParameters: ExternalWalletsApiGetExternalWalletByIdRequest, ) {
        return ExternalWalletsApiFp(this.httpClient).getExternalWalletById(requestParameters.walletId, );
    }

    /**
     * Gets a list of external wallets under the workspace.
     * @summary List external wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalWalletsApi
     */
    public getExternalWallets() {
        return ExternalWalletsApiFp(this.httpClient).getExternalWallets();
    }

    /**
     * Deletes an external wallet asset by ID.
     * @summary Delete an asset from an external wallet
     * @param {ExternalWalletsApiRemoveAssetFromExternalWalletRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalWalletsApi
     */
    public removeAssetFromExternalWallet(requestParameters: ExternalWalletsApiRemoveAssetFromExternalWalletRequest, ) {
        return ExternalWalletsApiFp(this.httpClient).removeAssetFromExternalWallet(requestParameters.walletId, requestParameters.assetId, );
    }

    /**
     * Sets an AML/KYT customer reference ID for the specific external wallet.
     * @summary Set an AML customer reference ID for an external wallet
     * @param {ExternalWalletsApiSetCustomerRefIdForExternalWalletRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalWalletsApi
     */
    public setCustomerRefIdForExternalWallet(requestParameters: ExternalWalletsApiSetCustomerRefIdForExternalWalletRequest, ) {
        return ExternalWalletsApiFp(this.httpClient).setCustomerRefIdForExternalWallet(requestParameters.walletId, requestParameters.setCustomerRefIdForVaultAccountRequest, );
    }
}





    /**
 * FiatAccountsApi - axios parameter creator
 * @export
 */
export const FiatAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deposits funds from the linked DDA.
         * @summary Deposit funds from DDA
         * @param {string} accountId The ID of the fiat account to use
         * @param {RedeemFundsToLinkedDDARequest} [redeemFundsToLinkedDDARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositFundsFromLinkedDDA: async (accountId: string, redeemFundsToLinkedDDARequest?: RedeemFundsToLinkedDDARequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('depositFundsFromLinkedDDA', 'accountId', accountId)
            const localVarPath = `/fiat_accounts/{accountId}/deposit_from_linked_dda`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = redeemFundsToLinkedDDARequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns a fiat account by ID.
         * @summary Find a specific fiat account
         * @param {string} accountId The ID of the fiat account to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiatAccountById: async (accountId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getFiatAccountById', 'accountId', accountId)
            const localVarPath = `/fiat_accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns all fiat accounts.
         * @summary List fiat accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiatAccounts: async (): Promise<AxiosRequestConfig> => {
            const localVarPath = `/fiat_accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Redeems funds to the linked DDA.
         * @summary Redeem funds to DDA
         * @param {string} accountId The ID of the fiat account to use
         * @param {RedeemFundsToLinkedDDARequest} [redeemFundsToLinkedDDARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeemFundsToLinkedDDA: async (accountId: string, redeemFundsToLinkedDDARequest?: RedeemFundsToLinkedDDARequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('redeemFundsToLinkedDDA', 'accountId', accountId)
            const localVarPath = `/fiat_accounts/{accountId}/redeem_to_linked_dda`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = redeemFundsToLinkedDDARequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * FiatAccountsApi - functional programming interface
 * @export
 */
export const FiatAccountsApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = FiatAccountsApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * Deposits funds from the linked DDA.
         * @summary Deposit funds from DDA
         * @param {string} accountId The ID of the fiat account to use
         * @param {RedeemFundsToLinkedDDARequest} [redeemFundsToLinkedDDARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async depositFundsFromLinkedDDA(accountId: string, redeemFundsToLinkedDDARequest?: RedeemFundsToLinkedDDARequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.depositFundsFromLinkedDDA(accountId, redeemFundsToLinkedDDARequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns a fiat account by ID.
         * @summary Find a specific fiat account
         * @param {string} accountId The ID of the fiat account to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFiatAccountById(accountId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FiatAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFiatAccountById(accountId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns all fiat accounts.
         * @summary List fiat accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFiatAccounts(): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FiatAccount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFiatAccounts();
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Redeems funds to the linked DDA.
         * @summary Redeem funds to DDA
         * @param {string} accountId The ID of the fiat account to use
         * @param {RedeemFundsToLinkedDDARequest} [redeemFundsToLinkedDDARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeemFundsToLinkedDDA(accountId: string, redeemFundsToLinkedDDARequest?: RedeemFundsToLinkedDDARequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeemFundsToLinkedDDA(accountId, redeemFundsToLinkedDDARequest, );
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for depositFundsFromLinkedDDA operation in FiatAccountsApi.
 * @export
 * @interface FiatAccountsApiDepositFundsFromLinkedDDARequest
 */
export interface FiatAccountsApiDepositFundsFromLinkedDDARequest {
    /**
     * The ID of the fiat account to use
     * @type {string}
     * @memberof FiatAccountsApiDepositFundsFromLinkedDDA
     */
    readonly accountId: string

    /**
     * 
     * @type {RedeemFundsToLinkedDDARequest}
     * @memberof FiatAccountsApiDepositFundsFromLinkedDDA
     */
    readonly redeemFundsToLinkedDDARequest?: RedeemFundsToLinkedDDARequest
}

/**
 * Request parameters for getFiatAccountById operation in FiatAccountsApi.
 * @export
 * @interface FiatAccountsApiGetFiatAccountByIdRequest
 */
export interface FiatAccountsApiGetFiatAccountByIdRequest {
    /**
     * The ID of the fiat account to return
     * @type {string}
     * @memberof FiatAccountsApiGetFiatAccountById
     */
    readonly accountId: string
}

/**
 * Request parameters for redeemFundsToLinkedDDA operation in FiatAccountsApi.
 * @export
 * @interface FiatAccountsApiRedeemFundsToLinkedDDARequest
 */
export interface FiatAccountsApiRedeemFundsToLinkedDDARequest {
    /**
     * The ID of the fiat account to use
     * @type {string}
     * @memberof FiatAccountsApiRedeemFundsToLinkedDDA
     */
    readonly accountId: string

    /**
     * 
     * @type {RedeemFundsToLinkedDDARequest}
     * @memberof FiatAccountsApiRedeemFundsToLinkedDDA
     */
    readonly redeemFundsToLinkedDDARequest?: RedeemFundsToLinkedDDARequest
}

/**
 * FiatAccountsApi - object-oriented interface
 * @export
 * @class FiatAccountsApi
 * @extends {BaseAPI}
 */
export class FiatAccountsApi extends BaseAPI {
    /**
     * Deposits funds from the linked DDA.
     * @summary Deposit funds from DDA
     * @param {FiatAccountsApiDepositFundsFromLinkedDDARequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiatAccountsApi
     */
    public depositFundsFromLinkedDDA(requestParameters: FiatAccountsApiDepositFundsFromLinkedDDARequest, ) {
        return FiatAccountsApiFp(this.httpClient).depositFundsFromLinkedDDA(requestParameters.accountId, requestParameters.redeemFundsToLinkedDDARequest, );
    }

    /**
     * Returns a fiat account by ID.
     * @summary Find a specific fiat account
     * @param {FiatAccountsApiGetFiatAccountByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiatAccountsApi
     */
    public getFiatAccountById(requestParameters: FiatAccountsApiGetFiatAccountByIdRequest, ) {
        return FiatAccountsApiFp(this.httpClient).getFiatAccountById(requestParameters.accountId, );
    }

    /**
     * Returns all fiat accounts.
     * @summary List fiat accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiatAccountsApi
     */
    public getFiatAccounts() {
        return FiatAccountsApiFp(this.httpClient).getFiatAccounts();
    }

    /**
     * Redeems funds to the linked DDA.
     * @summary Redeem funds to DDA
     * @param {FiatAccountsApiRedeemFundsToLinkedDDARequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiatAccountsApi
     */
    public redeemFundsToLinkedDDA(requestParameters: FiatAccountsApiRedeemFundsToLinkedDDARequest, ) {
        return FiatAccountsApiFp(this.httpClient).redeemFundsToLinkedDDA(requestParameters.accountId, requestParameters.redeemFundsToLinkedDDARequest, );
    }
}





    /**
 * GasStationsApi - axios parameter creator
 * @export
 */
export const GasStationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns gas station settings and ETH balance.
         * @summary Get gas station settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGasStation: async (): Promise<AxiosRequestConfig> => {
            const localVarPath = `/gas_station`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns gas station settings and balances for a requested asset.
         * @summary Get gas station settings by asset
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGasStationByAssetId: async (assetId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getGasStationByAssetId', 'assetId', assetId)
            const localVarPath = `/gas_station/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Configures gas station settings for ETH.
         * @summary Edit gas station settings
         * @param {GasStationConfiguration} gasStationConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGasStationConfiguration: async (gasStationConfiguration: GasStationConfiguration, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'gasStationConfiguration' is not null or undefined
            assertParamExists('updateGasStationConfiguration', 'gasStationConfiguration', gasStationConfiguration)
            const localVarPath = `/gas_station/configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'PUT'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = gasStationConfiguration as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Configures gas station settings for a requested asset.
         * @summary Edit gas station settings for an asset
         * @param {string} assetId The ID of the asset
         * @param {GasStationConfiguration} gasStationConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGasStationConfigurationByAssetId: async (assetId: string, gasStationConfiguration: GasStationConfiguration, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('updateGasStationConfigurationByAssetId', 'assetId', assetId)
            // verify required parameter 'gasStationConfiguration' is not null or undefined
            assertParamExists('updateGasStationConfigurationByAssetId', 'gasStationConfiguration', gasStationConfiguration)
            const localVarPath = `/gas_station/configuration/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'PUT'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = gasStationConfiguration as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * GasStationsApi - functional programming interface
 * @export
 */
export const GasStationsApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = GasStationsApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * Returns gas station settings and ETH balance.
         * @summary Get gas station settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGasStation(): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GasStationPropertiesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGasStation();
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns gas station settings and balances for a requested asset.
         * @summary Get gas station settings by asset
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGasStationByAssetId(assetId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GasStationPropertiesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGasStationByAssetId(assetId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Configures gas station settings for ETH.
         * @summary Edit gas station settings
         * @param {GasStationConfiguration} gasStationConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGasStationConfiguration(gasStationConfiguration: GasStationConfiguration, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGasStationConfiguration(gasStationConfiguration, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Configures gas station settings for a requested asset.
         * @summary Edit gas station settings for an asset
         * @param {string} assetId The ID of the asset
         * @param {GasStationConfiguration} gasStationConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGasStationConfigurationByAssetId(assetId: string, gasStationConfiguration: GasStationConfiguration, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGasStationConfigurationByAssetId(assetId, gasStationConfiguration, );
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for getGasStationByAssetId operation in GasStationsApi.
 * @export
 * @interface GasStationsApiGetGasStationByAssetIdRequest
 */
export interface GasStationsApiGetGasStationByAssetIdRequest {
    /**
     * The ID of the asset
     * @type {string}
     * @memberof GasStationsApiGetGasStationByAssetId
     */
    readonly assetId: string
}

/**
 * Request parameters for updateGasStationConfiguration operation in GasStationsApi.
 * @export
 * @interface GasStationsApiUpdateGasStationConfigurationRequest
 */
export interface GasStationsApiUpdateGasStationConfigurationRequest {
    /**
     * 
     * @type {GasStationConfiguration}
     * @memberof GasStationsApiUpdateGasStationConfiguration
     */
    readonly gasStationConfiguration: GasStationConfiguration
}

/**
 * Request parameters for updateGasStationConfigurationByAssetId operation in GasStationsApi.
 * @export
 * @interface GasStationsApiUpdateGasStationConfigurationByAssetIdRequest
 */
export interface GasStationsApiUpdateGasStationConfigurationByAssetIdRequest {
    /**
     * The ID of the asset
     * @type {string}
     * @memberof GasStationsApiUpdateGasStationConfigurationByAssetId
     */
    readonly assetId: string

    /**
     * 
     * @type {GasStationConfiguration}
     * @memberof GasStationsApiUpdateGasStationConfigurationByAssetId
     */
    readonly gasStationConfiguration: GasStationConfiguration
}

/**
 * GasStationsApi - object-oriented interface
 * @export
 * @class GasStationsApi
 * @extends {BaseAPI}
 */
export class GasStationsApi extends BaseAPI {
    /**
     * Returns gas station settings and ETH balance.
     * @summary Get gas station settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GasStationsApi
     */
    public getGasStation() {
        return GasStationsApiFp(this.httpClient).getGasStation();
    }

    /**
     * Returns gas station settings and balances for a requested asset.
     * @summary Get gas station settings by asset
     * @param {GasStationsApiGetGasStationByAssetIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GasStationsApi
     */
    public getGasStationByAssetId(requestParameters: GasStationsApiGetGasStationByAssetIdRequest, ) {
        return GasStationsApiFp(this.httpClient).getGasStationByAssetId(requestParameters.assetId, );
    }

    /**
     * Configures gas station settings for ETH.
     * @summary Edit gas station settings
     * @param {GasStationsApiUpdateGasStationConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GasStationsApi
     */
    public updateGasStationConfiguration(requestParameters: GasStationsApiUpdateGasStationConfigurationRequest, ) {
        return GasStationsApiFp(this.httpClient).updateGasStationConfiguration(requestParameters.gasStationConfiguration, );
    }

    /**
     * Configures gas station settings for a requested asset.
     * @summary Edit gas station settings for an asset
     * @param {GasStationsApiUpdateGasStationConfigurationByAssetIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GasStationsApi
     */
    public updateGasStationConfigurationByAssetId(requestParameters: GasStationsApiUpdateGasStationConfigurationByAssetIdRequest, ) {
        return GasStationsApiFp(this.httpClient).updateGasStationConfigurationByAssetId(requestParameters.assetId, requestParameters.gasStationConfiguration, );
    }
}





    /**
 * InternalWalletsApi - axios parameter creator
 * @export
 */
export const InternalWalletsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new internal wallet with the requested name.
         * @summary Create an internal wallet
         * @param {CreateInternalWalletRequest} [createInternalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInternalWallet: async (createInternalWalletRequest?: CreateInternalWalletRequest, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/internal_wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = createInternalWalletRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Adds an asset to an existing internal wallet.
         * @summary Add an asset to an internal wallet
         * @param {string} walletId The ID of the wallet
         * @param {string} assetId The ID of the asset to add
         * @param {CreateInternalWalletAssetRequest} [createInternalWalletAssetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInternalWalletAsset: async (walletId: string, assetId: string, createInternalWalletAssetRequest?: CreateInternalWalletAssetRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('createInternalWalletAsset', 'walletId', walletId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('createInternalWalletAsset', 'assetId', assetId)
            const localVarPath = `/internal_wallets/{walletId}/{assetId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = createInternalWalletAssetRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Deletes an internal wallet by ID.
         * @summary Delete an internal wallet
         * @param {string} walletId The ID of the wallet to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInternalWallet: async (walletId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('deleteInternalWallet', 'walletId', walletId)
            const localVarPath = `/internal_wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'DELETE'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Deletes a whitelisted address (for an asset) from an internal wallet.
         * @summary Delete a whitelisted address from an internal wallet
         * @param {string} walletId The ID of the wallet
         * @param {string} assetId The ID of the asset to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInternalWalletAsset: async (walletId: string, assetId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('deleteInternalWalletAsset', 'walletId', walletId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('deleteInternalWalletAsset', 'assetId', assetId)
            const localVarPath = `/internal_wallets/{walletId}/{assetId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'DELETE'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns information for an asset in an internal wallet.
         * @summary Get an asset from an internal wallet
         * @param {string} walletId The ID of the wallet
         * @param {string} assetId The ID of the asset to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalWalletAsset: async (walletId: string, assetId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getInternalWalletAsset', 'walletId', walletId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getInternalWalletAsset', 'assetId', assetId)
            const localVarPath = `/internal_wallets/{walletId}/{assetId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns all assets in an internal wallet by ID.
         * @summary Get assets for internal wallet
         * @param {string} walletId The ID of the wallet to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalWalletById: async (walletId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('getInternalWalletById', 'walletId', walletId)
            const localVarPath = `/internal_wallets/{walletId}`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Gets a list of internal wallets.  **Note**: BTC-based assets belonging to whitelisted addresses cannot be retrieved between 00:00 UTC and 00:01 UTC daily due to third-party provider, Blockchair, being unavailable for this 60 second period. Please wait until the next minute to retrieve BTC-based assets. 
         * @summary List internal wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalWallets: async (): Promise<AxiosRequestConfig> => {
            const localVarPath = `/internal_wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Sets an AML/KYT customer reference ID for the specific internal wallet.
         * @summary Set an AML/KYT customer reference ID for an internal wallet
         * @param {string} walletId The wallet ID
         * @param {SetCustomerRefIdForVaultAccountRequest} setCustomerRefIdForVaultAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomerRefIdForInternalWallet: async (walletId: string, setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'walletId' is not null or undefined
            assertParamExists('setCustomerRefIdForInternalWallet', 'walletId', walletId)
            // verify required parameter 'setCustomerRefIdForVaultAccountRequest' is not null or undefined
            assertParamExists('setCustomerRefIdForInternalWallet', 'setCustomerRefIdForVaultAccountRequest', setCustomerRefIdForVaultAccountRequest)
            const localVarPath = `/internal_wallets/{walletId}/set_customer_ref_id`
                .replace(`{${"walletId"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = setCustomerRefIdForVaultAccountRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalWalletsApi - functional programming interface
 * @export
 */
export const InternalWalletsApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = InternalWalletsApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * Creates a new internal wallet with the requested name.
         * @summary Create an internal wallet
         * @param {CreateInternalWalletRequest} [createInternalWalletRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInternalWallet(createInternalWalletRequest?: CreateInternalWalletRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnmanagedWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInternalWallet(createInternalWalletRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Adds an asset to an existing internal wallet.
         * @summary Add an asset to an internal wallet
         * @param {string} walletId The ID of the wallet
         * @param {string} assetId The ID of the asset to add
         * @param {CreateInternalWalletAssetRequest} [createInternalWalletAssetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInternalWalletAsset(walletId: string, assetId: string, createInternalWalletAssetRequest?: CreateInternalWalletAssetRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInternalWalletAsset(walletId, assetId, createInternalWalletAssetRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Deletes an internal wallet by ID.
         * @summary Delete an internal wallet
         * @param {string} walletId The ID of the wallet to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInternalWallet(walletId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInternalWallet(walletId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Deletes a whitelisted address (for an asset) from an internal wallet.
         * @summary Delete a whitelisted address from an internal wallet
         * @param {string} walletId The ID of the wallet
         * @param {string} assetId The ID of the asset to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInternalWalletAsset(walletId: string, assetId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInternalWalletAsset(walletId, assetId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns information for an asset in an internal wallet.
         * @summary Get an asset from an internal wallet
         * @param {string} walletId The ID of the wallet
         * @param {string} assetId The ID of the asset to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInternalWalletAsset(walletId: string, assetId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInternalWalletAsset(walletId, assetId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns all assets in an internal wallet by ID.
         * @summary Get assets for internal wallet
         * @param {string} walletId The ID of the wallet to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInternalWalletById(walletId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnmanagedWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInternalWalletById(walletId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Gets a list of internal wallets.  **Note**: BTC-based assets belonging to whitelisted addresses cannot be retrieved between 00:00 UTC and 00:01 UTC daily due to third-party provider, Blockchair, being unavailable for this 60 second period. Please wait until the next minute to retrieve BTC-based assets. 
         * @summary List internal wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInternalWallets(): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UnmanagedWallet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInternalWallets();
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Sets an AML/KYT customer reference ID for the specific internal wallet.
         * @summary Set an AML/KYT customer reference ID for an internal wallet
         * @param {string} walletId The wallet ID
         * @param {SetCustomerRefIdForVaultAccountRequest} setCustomerRefIdForVaultAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCustomerRefIdForInternalWallet(walletId: string, setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCustomerRefIdForInternalWallet(walletId, setCustomerRefIdForVaultAccountRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for createInternalWallet operation in InternalWalletsApi.
 * @export
 * @interface InternalWalletsApiCreateInternalWalletRequest
 */
export interface InternalWalletsApiCreateInternalWalletRequest {
    /**
     * 
     * @type {CreateInternalWalletRequest}
     * @memberof InternalWalletsApiCreateInternalWallet
     */
    readonly createInternalWalletRequest?: CreateInternalWalletRequest
}

/**
 * Request parameters for createInternalWalletAsset operation in InternalWalletsApi.
 * @export
 * @interface InternalWalletsApiCreateInternalWalletAssetRequest
 */
export interface InternalWalletsApiCreateInternalWalletAssetRequest {
    /**
     * The ID of the wallet
     * @type {string}
     * @memberof InternalWalletsApiCreateInternalWalletAsset
     */
    readonly walletId: string

    /**
     * The ID of the asset to add
     * @type {string}
     * @memberof InternalWalletsApiCreateInternalWalletAsset
     */
    readonly assetId: string

    /**
     * 
     * @type {CreateInternalWalletAssetRequest}
     * @memberof InternalWalletsApiCreateInternalWalletAsset
     */
    readonly createInternalWalletAssetRequest?: CreateInternalWalletAssetRequest
}

/**
 * Request parameters for deleteInternalWallet operation in InternalWalletsApi.
 * @export
 * @interface InternalWalletsApiDeleteInternalWalletRequest
 */
export interface InternalWalletsApiDeleteInternalWalletRequest {
    /**
     * The ID of the wallet to delete
     * @type {string}
     * @memberof InternalWalletsApiDeleteInternalWallet
     */
    readonly walletId: string
}

/**
 * Request parameters for deleteInternalWalletAsset operation in InternalWalletsApi.
 * @export
 * @interface InternalWalletsApiDeleteInternalWalletAssetRequest
 */
export interface InternalWalletsApiDeleteInternalWalletAssetRequest {
    /**
     * The ID of the wallet
     * @type {string}
     * @memberof InternalWalletsApiDeleteInternalWalletAsset
     */
    readonly walletId: string

    /**
     * The ID of the asset to delete
     * @type {string}
     * @memberof InternalWalletsApiDeleteInternalWalletAsset
     */
    readonly assetId: string
}

/**
 * Request parameters for getInternalWalletAsset operation in InternalWalletsApi.
 * @export
 * @interface InternalWalletsApiGetInternalWalletAssetRequest
 */
export interface InternalWalletsApiGetInternalWalletAssetRequest {
    /**
     * The ID of the wallet
     * @type {string}
     * @memberof InternalWalletsApiGetInternalWalletAsset
     */
    readonly walletId: string

    /**
     * The ID of the asset to return
     * @type {string}
     * @memberof InternalWalletsApiGetInternalWalletAsset
     */
    readonly assetId: string
}

/**
 * Request parameters for getInternalWalletById operation in InternalWalletsApi.
 * @export
 * @interface InternalWalletsApiGetInternalWalletByIdRequest
 */
export interface InternalWalletsApiGetInternalWalletByIdRequest {
    /**
     * The ID of the wallet to return
     * @type {string}
     * @memberof InternalWalletsApiGetInternalWalletById
     */
    readonly walletId: string
}

/**
 * Request parameters for setCustomerRefIdForInternalWallet operation in InternalWalletsApi.
 * @export
 * @interface InternalWalletsApiSetCustomerRefIdForInternalWalletRequest
 */
export interface InternalWalletsApiSetCustomerRefIdForInternalWalletRequest {
    /**
     * The wallet ID
     * @type {string}
     * @memberof InternalWalletsApiSetCustomerRefIdForInternalWallet
     */
    readonly walletId: string

    /**
     * 
     * @type {SetCustomerRefIdForVaultAccountRequest}
     * @memberof InternalWalletsApiSetCustomerRefIdForInternalWallet
     */
    readonly setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest
}

/**
 * InternalWalletsApi - object-oriented interface
 * @export
 * @class InternalWalletsApi
 * @extends {BaseAPI}
 */
export class InternalWalletsApi extends BaseAPI {
    /**
     * Creates a new internal wallet with the requested name.
     * @summary Create an internal wallet
     * @param {InternalWalletsApiCreateInternalWalletRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalWalletsApi
     */
    public createInternalWallet(requestParameters: InternalWalletsApiCreateInternalWalletRequest = {}, ) {
        return InternalWalletsApiFp(this.httpClient).createInternalWallet(requestParameters.createInternalWalletRequest, );
    }

    /**
     * Adds an asset to an existing internal wallet.
     * @summary Add an asset to an internal wallet
     * @param {InternalWalletsApiCreateInternalWalletAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalWalletsApi
     */
    public createInternalWalletAsset(requestParameters: InternalWalletsApiCreateInternalWalletAssetRequest, ) {
        return InternalWalletsApiFp(this.httpClient).createInternalWalletAsset(requestParameters.walletId, requestParameters.assetId, requestParameters.createInternalWalletAssetRequest, );
    }

    /**
     * Deletes an internal wallet by ID.
     * @summary Delete an internal wallet
     * @param {InternalWalletsApiDeleteInternalWalletRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalWalletsApi
     */
    public deleteInternalWallet(requestParameters: InternalWalletsApiDeleteInternalWalletRequest, ) {
        return InternalWalletsApiFp(this.httpClient).deleteInternalWallet(requestParameters.walletId, );
    }

    /**
     * Deletes a whitelisted address (for an asset) from an internal wallet.
     * @summary Delete a whitelisted address from an internal wallet
     * @param {InternalWalletsApiDeleteInternalWalletAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalWalletsApi
     */
    public deleteInternalWalletAsset(requestParameters: InternalWalletsApiDeleteInternalWalletAssetRequest, ) {
        return InternalWalletsApiFp(this.httpClient).deleteInternalWalletAsset(requestParameters.walletId, requestParameters.assetId, );
    }

    /**
     * Returns information for an asset in an internal wallet.
     * @summary Get an asset from an internal wallet
     * @param {InternalWalletsApiGetInternalWalletAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalWalletsApi
     */
    public getInternalWalletAsset(requestParameters: InternalWalletsApiGetInternalWalletAssetRequest, ) {
        return InternalWalletsApiFp(this.httpClient).getInternalWalletAsset(requestParameters.walletId, requestParameters.assetId, );
    }

    /**
     * Returns all assets in an internal wallet by ID.
     * @summary Get assets for internal wallet
     * @param {InternalWalletsApiGetInternalWalletByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalWalletsApi
     */
    public getInternalWalletById(requestParameters: InternalWalletsApiGetInternalWalletByIdRequest, ) {
        return InternalWalletsApiFp(this.httpClient).getInternalWalletById(requestParameters.walletId, );
    }

    /**
     * Gets a list of internal wallets.  **Note**: BTC-based assets belonging to whitelisted addresses cannot be retrieved between 00:00 UTC and 00:01 UTC daily due to third-party provider, Blockchair, being unavailable for this 60 second period. Please wait until the next minute to retrieve BTC-based assets. 
     * @summary List internal wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalWalletsApi
     */
    public getInternalWallets() {
        return InternalWalletsApiFp(this.httpClient).getInternalWallets();
    }

    /**
     * Sets an AML/KYT customer reference ID for the specific internal wallet.
     * @summary Set an AML/KYT customer reference ID for an internal wallet
     * @param {InternalWalletsApiSetCustomerRefIdForInternalWalletRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalWalletsApi
     */
    public setCustomerRefIdForInternalWallet(requestParameters: InternalWalletsApiSetCustomerRefIdForInternalWalletRequest, ) {
        return InternalWalletsApiFp(this.httpClient).setCustomerRefIdForInternalWallet(requestParameters.walletId, requestParameters.setCustomerRefIdForVaultAccountRequest, );
    }
}





    /**
 * NFTsBetaApi - axios parameter creator
 * @export
 */
export const NFTsBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the requested token data.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
         * @summary List token data by ID
         * @param {string} id NFT ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFTTokenById: async (id: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNFTTokenById', 'id', id)
            const localVarPath = `/nfts/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns the requested tokens data  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
         * @summary List tokens by IDs
         * @param {string} ids A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<'collection.name' | 'name'>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {'DESC' | 'ASC'} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFTTokens: async (ids: string, pageCursor?: string, pageSize?: number, sort?: Array<'collection.name' | 'name'>, order?: 'DESC' | 'ASC', ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getNFTTokens', 'ids', ids)
            const localVarPath = `/nfts/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns all tokens and their data in your workspace.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
         * @summary List all owned tokens (paginated)
         * @param {'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI'} [blockchainDescriptor] Blockchain descriptor filter
         * @param {string} [vaultAccountIds] A comma separated list of Vault Account IDs. Up to 100 are allowed in a single request
         * @param {string} [ids] A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
         * @param {string} [collectionIds] A comma separated list of collection IDs. Up to 100 are allowed in a single request.
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<'ownershipLastUpdateTime' | 'name' | 'collection.name'>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {'DESC' | 'ASC'} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {'LISTED' | 'ARCHIVED'} [status] Token ownership status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnershipTokens: async (blockchainDescriptor?: 'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI', vaultAccountIds?: string, ids?: string, collectionIds?: string, pageCursor?: string, pageSize?: number, sort?: Array<'ownershipLastUpdateTime' | 'name' | 'collection.name'>, order?: 'DESC' | 'ASC', status?: 'LISTED' | 'ARCHIVED', ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/nfts/ownership/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blockchainDescriptor !== undefined) {
                localVarQueryParameter['blockchainDescriptor'] = blockchainDescriptor;
            }

            if (vaultAccountIds !== undefined) {
                localVarQueryParameter['vaultAccountIds'] = vaultAccountIds;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (collectionIds !== undefined) {
                localVarQueryParameter['collectionIds'] = collectionIds;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['pageCursor'] = pageCursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Updates the latest token metadata.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
         * @summary Refresh token metadata
         * @param {string} id NFT ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNFTTokenById: async (id: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateNFTTokenById', 'id', id)
            const localVarPath = `/nfts/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'PUT'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Updates token ownership status for a tenant, in all tenant vaults.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
         * @summary Update token ownership status
         * @param {string} id NFT ID
         * @param {UpdateTokenOwnershipStatusDto} updateTokenOwnershipStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNFTTokenStatus: async (id: string, updateTokenOwnershipStatusDto: UpdateTokenOwnershipStatusDto, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateNFTTokenStatus', 'id', id)
            // verify required parameter 'updateTokenOwnershipStatusDto' is not null or undefined
            assertParamExists('updateNFTTokenStatus', 'updateTokenOwnershipStatusDto', updateTokenOwnershipStatusDto)
            const localVarPath = `/nfts/ownership/tokens/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'PUT'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = updateTokenOwnershipStatusDto as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Updates all tokens and balances per blockchain and vault account.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
         * @summary Refresh vault account tokens
         * @param {'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI'} blockchainDescriptor Blockchain descriptor filter
         * @param {string} vaultAccountId Vault account filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOwnershipTokens: async (blockchainDescriptor: 'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI', vaultAccountId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'blockchainDescriptor' is not null or undefined
            assertParamExists('updateOwnershipTokens', 'blockchainDescriptor', blockchainDescriptor)
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('updateOwnershipTokens', 'vaultAccountId', vaultAccountId)
            const localVarPath = `/nfts/ownership/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'PUT'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (blockchainDescriptor !== undefined) {
                localVarQueryParameter['blockchainDescriptor'] = blockchainDescriptor;
            }

            if (vaultAccountId !== undefined) {
                localVarQueryParameter['vaultAccountId'] = vaultAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * NFTsBetaApi - functional programming interface
 * @export
 */
export const NFTsBetaApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = NFTsBetaApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * Returns the requested token data.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
         * @summary List token data by ID
         * @param {string} id NFT ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNFTTokenById(id: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNFTTokenById(id, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns the requested tokens data  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
         * @summary List tokens by IDs
         * @param {string} ids A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<'collection.name' | 'name'>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {'DESC' | 'ASC'} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNFTTokens(ids: string, pageCursor?: string, pageSize?: number, sort?: Array<'collection.name' | 'name'>, order?: 'DESC' | 'ASC', ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNFTTokens200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNFTTokens(ids, pageCursor, pageSize, sort, order, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns all tokens and their data in your workspace.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
         * @summary List all owned tokens (paginated)
         * @param {'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI'} [blockchainDescriptor] Blockchain descriptor filter
         * @param {string} [vaultAccountIds] A comma separated list of Vault Account IDs. Up to 100 are allowed in a single request
         * @param {string} [ids] A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
         * @param {string} [collectionIds] A comma separated list of collection IDs. Up to 100 are allowed in a single request.
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<'ownershipLastUpdateTime' | 'name' | 'collection.name'>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {'DESC' | 'ASC'} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {'LISTED' | 'ARCHIVED'} [status] Token ownership status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOwnershipTokens(blockchainDescriptor?: 'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI', vaultAccountIds?: string, ids?: string, collectionIds?: string, pageCursor?: string, pageSize?: number, sort?: Array<'ownershipLastUpdateTime' | 'name' | 'collection.name'>, order?: 'DESC' | 'ASC', status?: 'LISTED' | 'ARCHIVED', ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOwnershipTokens200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOwnershipTokens(blockchainDescriptor, vaultAccountIds, ids, collectionIds, pageCursor, pageSize, sort, order, status, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Updates the latest token metadata.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
         * @summary Refresh token metadata
         * @param {string} id NFT ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNFTTokenById(id: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNFTTokenById(id, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Updates token ownership status for a tenant, in all tenant vaults.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
         * @summary Update token ownership status
         * @param {string} id NFT ID
         * @param {UpdateTokenOwnershipStatusDto} updateTokenOwnershipStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNFTTokenStatus(id: string, updateTokenOwnershipStatusDto: UpdateTokenOwnershipStatusDto, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNFTTokenStatus(id, updateTokenOwnershipStatusDto, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Updates all tokens and balances per blockchain and vault account.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
         * @summary Refresh vault account tokens
         * @param {'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI'} blockchainDescriptor Blockchain descriptor filter
         * @param {string} vaultAccountId Vault account filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOwnershipTokens(blockchainDescriptor: 'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI', vaultAccountId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOwnershipTokens(blockchainDescriptor, vaultAccountId, );
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for getNFTTokenById operation in NFTsBetaApi.
 * @export
 * @interface NFTsBetaApiGetNFTTokenByIdRequest
 */
export interface NFTsBetaApiGetNFTTokenByIdRequest {
    /**
     * NFT ID
     * @type {string}
     * @memberof NFTsBetaApiGetNFTTokenById
     */
    readonly id: string
}

/**
 * Request parameters for getNFTTokens operation in NFTsBetaApi.
 * @export
 * @interface NFTsBetaApiGetNFTTokensRequest
 */
export interface NFTsBetaApiGetNFTTokensRequest {
    /**
     * A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
     * @type {string}
     * @memberof NFTsBetaApiGetNFTTokens
     */
    readonly ids: string

    /**
     * Page cursor to fetch
     * @type {string}
     * @memberof NFTsBetaApiGetNFTTokens
     */
    readonly pageCursor?: string

    /**
     * Items per page (max 100)
     * @type {number}
     * @memberof NFTsBetaApiGetNFTTokens
     */
    readonly pageSize?: number

    /**
     * Sort by param, it can be one param or a list of params separated by comma
     * @type {Array<'collection.name' | 'name'>}
     * @memberof NFTsBetaApiGetNFTTokens
     */
    readonly sort?: Array<'collection.name' | 'name'>

    /**
     * Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
     * @type {'DESC' | 'ASC'}
     * @memberof NFTsBetaApiGetNFTTokens
     */
    readonly order?: 'DESC' | 'ASC'
}

/**
 * Request parameters for getOwnershipTokens operation in NFTsBetaApi.
 * @export
 * @interface NFTsBetaApiGetOwnershipTokensRequest
 */
export interface NFTsBetaApiGetOwnershipTokensRequest {
    /**
     * Blockchain descriptor filter
     * @type {'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI'}
     * @memberof NFTsBetaApiGetOwnershipTokens
     */
    readonly blockchainDescriptor?: 'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI'

    /**
     * A comma separated list of Vault Account IDs. Up to 100 are allowed in a single request
     * @type {string}
     * @memberof NFTsBetaApiGetOwnershipTokens
     */
    readonly vaultAccountIds?: string

    /**
     * A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
     * @type {string}
     * @memberof NFTsBetaApiGetOwnershipTokens
     */
    readonly ids?: string

    /**
     * A comma separated list of collection IDs. Up to 100 are allowed in a single request.
     * @type {string}
     * @memberof NFTsBetaApiGetOwnershipTokens
     */
    readonly collectionIds?: string

    /**
     * Page cursor to fetch
     * @type {string}
     * @memberof NFTsBetaApiGetOwnershipTokens
     */
    readonly pageCursor?: string

    /**
     * Items per page (max 100)
     * @type {number}
     * @memberof NFTsBetaApiGetOwnershipTokens
     */
    readonly pageSize?: number

    /**
     * Sort by param, it can be one param or a list of params separated by comma
     * @type {Array<'ownershipLastUpdateTime' | 'name' | 'collection.name'>}
     * @memberof NFTsBetaApiGetOwnershipTokens
     */
    readonly sort?: Array<'ownershipLastUpdateTime' | 'name' | 'collection.name'>

    /**
     * Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
     * @type {'DESC' | 'ASC'}
     * @memberof NFTsBetaApiGetOwnershipTokens
     */
    readonly order?: 'DESC' | 'ASC'

    /**
     * Token ownership status
     * @type {'LISTED' | 'ARCHIVED'}
     * @memberof NFTsBetaApiGetOwnershipTokens
     */
    readonly status?: 'LISTED' | 'ARCHIVED'
}

/**
 * Request parameters for updateNFTTokenById operation in NFTsBetaApi.
 * @export
 * @interface NFTsBetaApiUpdateNFTTokenByIdRequest
 */
export interface NFTsBetaApiUpdateNFTTokenByIdRequest {
    /**
     * NFT ID
     * @type {string}
     * @memberof NFTsBetaApiUpdateNFTTokenById
     */
    readonly id: string
}

/**
 * Request parameters for updateNFTTokenStatus operation in NFTsBetaApi.
 * @export
 * @interface NFTsBetaApiUpdateNFTTokenStatusRequest
 */
export interface NFTsBetaApiUpdateNFTTokenStatusRequest {
    /**
     * NFT ID
     * @type {string}
     * @memberof NFTsBetaApiUpdateNFTTokenStatus
     */
    readonly id: string

    /**
     * 
     * @type {UpdateTokenOwnershipStatusDto}
     * @memberof NFTsBetaApiUpdateNFTTokenStatus
     */
    readonly updateTokenOwnershipStatusDto: UpdateTokenOwnershipStatusDto
}

/**
 * Request parameters for updateOwnershipTokens operation in NFTsBetaApi.
 * @export
 * @interface NFTsBetaApiUpdateOwnershipTokensRequest
 */
export interface NFTsBetaApiUpdateOwnershipTokensRequest {
    /**
     * Blockchain descriptor filter
     * @type {'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI'}
     * @memberof NFTsBetaApiUpdateOwnershipTokens
     */
    readonly blockchainDescriptor: 'ETH' | 'ETH_TEST3' | 'POLYGON' | 'POLYGON_TEST_MUMBAI'

    /**
     * Vault account filter
     * @type {string}
     * @memberof NFTsBetaApiUpdateOwnershipTokens
     */
    readonly vaultAccountId: string
}

/**
 * NFTsBetaApi - object-oriented interface
 * @export
 * @class NFTsBetaApi
 * @extends {BaseAPI}
 */
export class NFTsBetaApi extends BaseAPI {
    /**
     * Returns the requested token data.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
     * @summary List token data by ID
     * @param {NFTsBetaApiGetNFTTokenByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsBetaApi
     */
    public getNFTTokenById(requestParameters: NFTsBetaApiGetNFTTokenByIdRequest, ) {
        return NFTsBetaApiFp(this.httpClient).getNFTTokenById(requestParameters.id, );
    }

    /**
     * Returns the requested tokens data  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
     * @summary List tokens by IDs
     * @param {NFTsBetaApiGetNFTTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsBetaApi
     */
    public getNFTTokens(requestParameters: NFTsBetaApiGetNFTTokensRequest, ) {
        return NFTsBetaApiFp(this.httpClient).getNFTTokens(requestParameters.ids, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, );
    }

    /**
     * Returns all tokens and their data in your workspace.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
     * @summary List all owned tokens (paginated)
     * @param {NFTsBetaApiGetOwnershipTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsBetaApi
     */
    public getOwnershipTokens(requestParameters: NFTsBetaApiGetOwnershipTokensRequest = {}, ) {
        return NFTsBetaApiFp(this.httpClient).getOwnershipTokens(requestParameters.blockchainDescriptor, requestParameters.vaultAccountIds, requestParameters.ids, requestParameters.collectionIds, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.status, );
    }

    /**
     * Updates the latest token metadata.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
     * @summary Refresh token metadata
     * @param {NFTsBetaApiUpdateNFTTokenByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsBetaApi
     */
    public updateNFTTokenById(requestParameters: NFTsBetaApiUpdateNFTTokenByIdRequest, ) {
        return NFTsBetaApiFp(this.httpClient).updateNFTTokenById(requestParameters.id, );
    }

    /**
     * Updates token ownership status for a tenant, in all tenant vaults.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
     * @summary Update token ownership status
     * @param {NFTsBetaApiUpdateNFTTokenStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsBetaApi
     */
    public updateNFTTokenStatus(requestParameters: NFTsBetaApiUpdateNFTTokenStatusRequest, ) {
        return NFTsBetaApiFp(this.httpClient).updateNFTTokenStatus(requestParameters.id, requestParameters.updateTokenOwnershipStatusDto, );
    }

    /**
     * Updates all tokens and balances per blockchain and vault account.  **Note**: This endpoint is now in Beta, disabled for general availability at this time.  To enroll in beta & enable this endpoint, contact your Fireblocks Customer Success Manager or reach out to [CSM@fireblocks.com](mailto:CSM@fireblocks.com). 
     * @summary Refresh vault account tokens
     * @param {NFTsBetaApiUpdateOwnershipTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsBetaApi
     */
    public updateOwnershipTokens(requestParameters: NFTsBetaApiUpdateOwnershipTokensRequest, ) {
        return NFTsBetaApiFp(this.httpClient).updateOwnershipTokens(requestParameters.blockchainDescriptor, requestParameters.vaultAccountId, );
    }
}





    /**
 * NetworkConnectionsApi - axios parameter creator
 * @export
 */
export const NetworkConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The Fireblocks Network allows for flexibility around incoming deposits. A receiver can receive network deposits to locations other than Fireblocks. This endpoint validates whether future transactions are routed to the displayed recipient or to a 3rd party.
         * @summary Retrieve third-party network routing validation by asset type.
         * @param {string} connectionId The ID of the network connection
         * @param {'CRYPTO' | 'SIGNET' | 'SEN' | 'SIGNET_TEST' | 'SEN_TEST'} assetType The destination asset type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkThirdPartyRoutingForNetworkConnection: async (connectionId: string, assetType: 'CRYPTO' | 'SIGNET' | 'SEN' | 'SIGNET_TEST' | 'SEN_TEST', ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('checkThirdPartyRoutingForNetworkConnection', 'connectionId', connectionId)
            // verify required parameter 'assetType' is not null or undefined
            assertParamExists('checkThirdPartyRoutingForNetworkConnection', 'assetType', assetType)
            const localVarPath = `/network_connections/{connectionId}/is_third_party_routing/{assetType}`
                .replace(`{${"connectionId"}}`, encodeURIComponent(String(connectionId)))
                .replace(`{${"assetType"}}`, encodeURIComponent(String(assetType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Initiates a new network connection.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Creates a new network connection
         * @param {NetworkConnection} [networkConnection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNetworkConnection: async (networkConnection?: NetworkConnection, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/network_connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = networkConnection as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Creates a new Network ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Creates a new Network ID
         * @param {CreateNetworkIdRequest} [createNetworkIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNetworkId: async (createNetworkIdRequest?: CreateNetworkIdRequest, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/network_ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = createNetworkIdRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing network connection specified by its connection ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Deletes a network connection by ID
         * @param {string} connectionId The ID of the network connection to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNetworkConnection: async (connectionId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('deleteNetworkConnection', 'connectionId', connectionId)
            const localVarPath = `/network_connections/{connectionId}`
                .replace(`{${"connectionId"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'DELETE'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Deletes a network by its ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Deletes specific network ID.
         * @param {string} networkId The ID of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNetworkId: async (networkId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('deleteNetworkId', 'networkId', networkId)
            const localVarPath = `/network_ids/{networkId}`
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'DELETE'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Gets a network connection by ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Get a network connection
         * @param {string} connectionId The ID of the connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkConnectionById: async (connectionId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('getNetworkConnectionById', 'connectionId', connectionId)
            const localVarPath = `/network_connections/{connectionId}`
                .replace(`{${"connectionId"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns all network connections.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary List network connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkConnections: async (): Promise<AxiosRequestConfig> => {
            const localVarPath = `/network_connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Retrieves a network by its ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Returns specific network ID.
         * @param {string} networkId The ID of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkIdById: async (networkId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('getNetworkIdById', 'networkId', networkId)
            const localVarPath = `/network_ids/{networkId}`
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all local and discoverable remote network IDs.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Returns all network IDs, both local IDs and discoverable remote IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkIds: async (): Promise<AxiosRequestConfig> => {
            const localVarPath = `/network_ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Update whether or not the network ID is discoverable by others.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Update network ID\'s discoverability.
         * @param {string} networkId The ID of the network
         * @param {SetDiscoverabilityForNetworkIdRequest} setDiscoverabilityForNetworkIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDiscoverabilityForNetworkId: async (networkId: string, setDiscoverabilityForNetworkIdRequest: SetDiscoverabilityForNetworkIdRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('setDiscoverabilityForNetworkId', 'networkId', networkId)
            // verify required parameter 'setDiscoverabilityForNetworkIdRequest' is not null or undefined
            assertParamExists('setDiscoverabilityForNetworkId', 'setDiscoverabilityForNetworkIdRequest', setDiscoverabilityForNetworkIdRequest)
            const localVarPath = `/network_ids/{networkId}/set_discoverability`
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'PATCH'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = setDiscoverabilityForNetworkIdRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Updates name of a specified network ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Update network ID\'s name.
         * @param {string} networkId The ID of the network
         * @param {SetNetworkIdNameRequest} setNetworkIdNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNetworkIdName: async (networkId: string, setNetworkIdNameRequest: SetNetworkIdNameRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('setNetworkIdName', 'networkId', networkId)
            // verify required parameter 'setNetworkIdNameRequest' is not null or undefined
            assertParamExists('setNetworkIdName', 'setNetworkIdNameRequest', setNetworkIdNameRequest)
            const localVarPath = `/network_ids/{networkId}/set_name`
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'PATCH'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = setNetworkIdNameRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Updates an existing network connection\'s routing policy.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Update network connection routing policy.
         * @param {string} connectionId The ID of the network connection
         * @param {SetRoutingPolicyForNetworkConnectionRequest} [setRoutingPolicyForNetworkConnectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoutingPolicyForNetworkConnection: async (connectionId: string, setRoutingPolicyForNetworkConnectionRequest?: SetRoutingPolicyForNetworkConnectionRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'connectionId' is not null or undefined
            assertParamExists('setRoutingPolicyForNetworkConnection', 'connectionId', connectionId)
            const localVarPath = `/network_connections/{connectionId}/set_routing_policy`
                .replace(`{${"connectionId"}}`, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'PATCH'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = setRoutingPolicyForNetworkConnectionRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Updates the routing policy of a specified network ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Update network id routing policy.
         * @param {string} networkId The ID of the network
         * @param {SetRoutingPolicyForNetworkIdRequest} [setRoutingPolicyForNetworkIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoutingPolicyForNetworkId: async (networkId: string, setRoutingPolicyForNetworkIdRequest?: SetRoutingPolicyForNetworkIdRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('setRoutingPolicyForNetworkId', 'networkId', networkId)
            const localVarPath = `/network_ids/{networkId}/set_routing_policy`
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'PATCH'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = setRoutingPolicyForNetworkIdRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkConnectionsApi - functional programming interface
 * @export
 */
export const NetworkConnectionsApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = NetworkConnectionsApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * The Fireblocks Network allows for flexibility around incoming deposits. A receiver can receive network deposits to locations other than Fireblocks. This endpoint validates whether future transactions are routed to the displayed recipient or to a 3rd party.
         * @summary Retrieve third-party network routing validation by asset type.
         * @param {string} connectionId The ID of the network connection
         * @param {'CRYPTO' | 'SIGNET' | 'SEN' | 'SIGNET_TEST' | 'SEN_TEST'} assetType The destination asset type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkThirdPartyRoutingForNetworkConnection(connectionId: string, assetType: 'CRYPTO' | 'SIGNET' | 'SEN' | 'SIGNET_TEST' | 'SEN_TEST', ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckThirdPartyRoutingForNetworkConnection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkThirdPartyRoutingForNetworkConnection(connectionId, assetType, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Initiates a new network connection.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Creates a new network connection
         * @param {NetworkConnection} [networkConnection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNetworkConnection(networkConnection?: NetworkConnection, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNetworkConnection(networkConnection, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Creates a new Network ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Creates a new Network ID
         * @param {CreateNetworkIdRequest} [createNetworkIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNetworkId(createNetworkIdRequest?: CreateNetworkIdRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNetworkId(createNetworkIdRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Deletes an existing network connection specified by its connection ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Deletes a network connection by ID
         * @param {string} connectionId The ID of the network connection to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNetworkConnection(connectionId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetRoutingPolicyForNetworkConnection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNetworkConnection(connectionId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Deletes a network by its ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Deletes specific network ID.
         * @param {string} networkId The ID of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNetworkId(networkId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetRoutingPolicyForNetworkConnection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNetworkId(networkId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Gets a network connection by ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Get a network connection
         * @param {string} connectionId The ID of the connection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkConnectionById(connectionId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkConnectionById(connectionId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns all network connections.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary List network connections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkConnections(): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NetworkConnectionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkConnections();
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Retrieves a network by its ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Returns specific network ID.
         * @param {string} networkId The ID of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkIdById(networkId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkIdById(networkId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Retrieves a list of all local and discoverable remote network IDs.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Returns all network IDs, both local IDs and discoverable remote IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkIds(): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetNetworkIds200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkIds();
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Update whether or not the network ID is discoverable by others.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Update network ID\'s discoverability.
         * @param {string} networkId The ID of the network
         * @param {SetDiscoverabilityForNetworkIdRequest} setDiscoverabilityForNetworkIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDiscoverabilityForNetworkId(networkId: string, setDiscoverabilityForNetworkIdRequest: SetDiscoverabilityForNetworkIdRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetRoutingPolicyForNetworkConnection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDiscoverabilityForNetworkId(networkId, setDiscoverabilityForNetworkIdRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Updates name of a specified network ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Update network ID\'s name.
         * @param {string} networkId The ID of the network
         * @param {SetNetworkIdNameRequest} setNetworkIdNameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setNetworkIdName(networkId: string, setNetworkIdNameRequest: SetNetworkIdNameRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetRoutingPolicyForNetworkConnection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setNetworkIdName(networkId, setNetworkIdNameRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Updates an existing network connection\'s routing policy.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Update network connection routing policy.
         * @param {string} connectionId The ID of the network connection
         * @param {SetRoutingPolicyForNetworkConnectionRequest} [setRoutingPolicyForNetworkConnectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRoutingPolicyForNetworkConnection(connectionId: string, setRoutingPolicyForNetworkConnectionRequest?: SetRoutingPolicyForNetworkConnectionRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetRoutingPolicyForNetworkConnection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRoutingPolicyForNetworkConnection(connectionId, setRoutingPolicyForNetworkConnectionRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Updates the routing policy of a specified network ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
         * @summary Update network id routing policy.
         * @param {string} networkId The ID of the network
         * @param {SetRoutingPolicyForNetworkIdRequest} [setRoutingPolicyForNetworkIdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRoutingPolicyForNetworkId(networkId: string, setRoutingPolicyForNetworkIdRequest?: SetRoutingPolicyForNetworkIdRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetRoutingPolicyForNetworkConnection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRoutingPolicyForNetworkId(networkId, setRoutingPolicyForNetworkIdRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for checkThirdPartyRoutingForNetworkConnection operation in NetworkConnectionsApi.
 * @export
 * @interface NetworkConnectionsApiCheckThirdPartyRoutingForNetworkConnectionRequest
 */
export interface NetworkConnectionsApiCheckThirdPartyRoutingForNetworkConnectionRequest {
    /**
     * The ID of the network connection
     * @type {string}
     * @memberof NetworkConnectionsApiCheckThirdPartyRoutingForNetworkConnection
     */
    readonly connectionId: string

    /**
     * The destination asset type
     * @type {'CRYPTO' | 'SIGNET' | 'SEN' | 'SIGNET_TEST' | 'SEN_TEST'}
     * @memberof NetworkConnectionsApiCheckThirdPartyRoutingForNetworkConnection
     */
    readonly assetType: 'CRYPTO' | 'SIGNET' | 'SEN' | 'SIGNET_TEST' | 'SEN_TEST'
}

/**
 * Request parameters for createNetworkConnection operation in NetworkConnectionsApi.
 * @export
 * @interface NetworkConnectionsApiCreateNetworkConnectionRequest
 */
export interface NetworkConnectionsApiCreateNetworkConnectionRequest {
    /**
     * 
     * @type {NetworkConnection}
     * @memberof NetworkConnectionsApiCreateNetworkConnection
     */
    readonly networkConnection?: NetworkConnection
}

/**
 * Request parameters for createNetworkId operation in NetworkConnectionsApi.
 * @export
 * @interface NetworkConnectionsApiCreateNetworkIdRequest
 */
export interface NetworkConnectionsApiCreateNetworkIdRequest {
    /**
     * 
     * @type {CreateNetworkIdRequest}
     * @memberof NetworkConnectionsApiCreateNetworkId
     */
    readonly createNetworkIdRequest?: CreateNetworkIdRequest
}

/**
 * Request parameters for deleteNetworkConnection operation in NetworkConnectionsApi.
 * @export
 * @interface NetworkConnectionsApiDeleteNetworkConnectionRequest
 */
export interface NetworkConnectionsApiDeleteNetworkConnectionRequest {
    /**
     * The ID of the network connection to delete
     * @type {string}
     * @memberof NetworkConnectionsApiDeleteNetworkConnection
     */
    readonly connectionId: string
}

/**
 * Request parameters for deleteNetworkId operation in NetworkConnectionsApi.
 * @export
 * @interface NetworkConnectionsApiDeleteNetworkIdRequest
 */
export interface NetworkConnectionsApiDeleteNetworkIdRequest {
    /**
     * The ID of the network
     * @type {string}
     * @memberof NetworkConnectionsApiDeleteNetworkId
     */
    readonly networkId: string
}

/**
 * Request parameters for getNetworkConnectionById operation in NetworkConnectionsApi.
 * @export
 * @interface NetworkConnectionsApiGetNetworkConnectionByIdRequest
 */
export interface NetworkConnectionsApiGetNetworkConnectionByIdRequest {
    /**
     * The ID of the connection
     * @type {string}
     * @memberof NetworkConnectionsApiGetNetworkConnectionById
     */
    readonly connectionId: string
}

/**
 * Request parameters for getNetworkIdById operation in NetworkConnectionsApi.
 * @export
 * @interface NetworkConnectionsApiGetNetworkIdByIdRequest
 */
export interface NetworkConnectionsApiGetNetworkIdByIdRequest {
    /**
     * The ID of the network
     * @type {string}
     * @memberof NetworkConnectionsApiGetNetworkIdById
     */
    readonly networkId: string
}

/**
 * Request parameters for setDiscoverabilityForNetworkId operation in NetworkConnectionsApi.
 * @export
 * @interface NetworkConnectionsApiSetDiscoverabilityForNetworkIdRequest
 */
export interface NetworkConnectionsApiSetDiscoverabilityForNetworkIdRequest {
    /**
     * The ID of the network
     * @type {string}
     * @memberof NetworkConnectionsApiSetDiscoverabilityForNetworkId
     */
    readonly networkId: string

    /**
     * 
     * @type {SetDiscoverabilityForNetworkIdRequest}
     * @memberof NetworkConnectionsApiSetDiscoverabilityForNetworkId
     */
    readonly setDiscoverabilityForNetworkIdRequest: SetDiscoverabilityForNetworkIdRequest
}

/**
 * Request parameters for setNetworkIdName operation in NetworkConnectionsApi.
 * @export
 * @interface NetworkConnectionsApiSetNetworkIdNameRequest
 */
export interface NetworkConnectionsApiSetNetworkIdNameRequest {
    /**
     * The ID of the network
     * @type {string}
     * @memberof NetworkConnectionsApiSetNetworkIdName
     */
    readonly networkId: string

    /**
     * 
     * @type {SetNetworkIdNameRequest}
     * @memberof NetworkConnectionsApiSetNetworkIdName
     */
    readonly setNetworkIdNameRequest: SetNetworkIdNameRequest
}

/**
 * Request parameters for setRoutingPolicyForNetworkConnection operation in NetworkConnectionsApi.
 * @export
 * @interface NetworkConnectionsApiSetRoutingPolicyForNetworkConnectionRequest
 */
export interface NetworkConnectionsApiSetRoutingPolicyForNetworkConnectionRequest {
    /**
     * The ID of the network connection
     * @type {string}
     * @memberof NetworkConnectionsApiSetRoutingPolicyForNetworkConnection
     */
    readonly connectionId: string

    /**
     * 
     * @type {SetRoutingPolicyForNetworkConnectionRequest}
     * @memberof NetworkConnectionsApiSetRoutingPolicyForNetworkConnection
     */
    readonly setRoutingPolicyForNetworkConnectionRequest?: SetRoutingPolicyForNetworkConnectionRequest
}

/**
 * Request parameters for setRoutingPolicyForNetworkId operation in NetworkConnectionsApi.
 * @export
 * @interface NetworkConnectionsApiSetRoutingPolicyForNetworkIdRequest
 */
export interface NetworkConnectionsApiSetRoutingPolicyForNetworkIdRequest {
    /**
     * The ID of the network
     * @type {string}
     * @memberof NetworkConnectionsApiSetRoutingPolicyForNetworkId
     */
    readonly networkId: string

    /**
     * 
     * @type {SetRoutingPolicyForNetworkIdRequest}
     * @memberof NetworkConnectionsApiSetRoutingPolicyForNetworkId
     */
    readonly setRoutingPolicyForNetworkIdRequest?: SetRoutingPolicyForNetworkIdRequest
}

/**
 * NetworkConnectionsApi - object-oriented interface
 * @export
 * @class NetworkConnectionsApi
 * @extends {BaseAPI}
 */
export class NetworkConnectionsApi extends BaseAPI {
    /**
     * The Fireblocks Network allows for flexibility around incoming deposits. A receiver can receive network deposits to locations other than Fireblocks. This endpoint validates whether future transactions are routed to the displayed recipient or to a 3rd party.
     * @summary Retrieve third-party network routing validation by asset type.
     * @param {NetworkConnectionsApiCheckThirdPartyRoutingForNetworkConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkConnectionsApi
     */
    public checkThirdPartyRoutingForNetworkConnection(requestParameters: NetworkConnectionsApiCheckThirdPartyRoutingForNetworkConnectionRequest, ) {
        return NetworkConnectionsApiFp(this.httpClient).checkThirdPartyRoutingForNetworkConnection(requestParameters.connectionId, requestParameters.assetType, );
    }

    /**
     * Initiates a new network connection.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
     * @summary Creates a new network connection
     * @param {NetworkConnectionsApiCreateNetworkConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkConnectionsApi
     */
    public createNetworkConnection(requestParameters: NetworkConnectionsApiCreateNetworkConnectionRequest = {}, ) {
        return NetworkConnectionsApiFp(this.httpClient).createNetworkConnection(requestParameters.networkConnection, );
    }

    /**
     * Creates a new Network ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
     * @summary Creates a new Network ID
     * @param {NetworkConnectionsApiCreateNetworkIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkConnectionsApi
     */
    public createNetworkId(requestParameters: NetworkConnectionsApiCreateNetworkIdRequest = {}, ) {
        return NetworkConnectionsApiFp(this.httpClient).createNetworkId(requestParameters.createNetworkIdRequest, );
    }

    /**
     * Deletes an existing network connection specified by its connection ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
     * @summary Deletes a network connection by ID
     * @param {NetworkConnectionsApiDeleteNetworkConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkConnectionsApi
     */
    public deleteNetworkConnection(requestParameters: NetworkConnectionsApiDeleteNetworkConnectionRequest, ) {
        return NetworkConnectionsApiFp(this.httpClient).deleteNetworkConnection(requestParameters.connectionId, );
    }

    /**
     * Deletes a network by its ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
     * @summary Deletes specific network ID.
     * @param {NetworkConnectionsApiDeleteNetworkIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkConnectionsApi
     */
    public deleteNetworkId(requestParameters: NetworkConnectionsApiDeleteNetworkIdRequest, ) {
        return NetworkConnectionsApiFp(this.httpClient).deleteNetworkId(requestParameters.networkId, );
    }

    /**
     * Gets a network connection by ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
     * @summary Get a network connection
     * @param {NetworkConnectionsApiGetNetworkConnectionByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkConnectionsApi
     */
    public getNetworkConnectionById(requestParameters: NetworkConnectionsApiGetNetworkConnectionByIdRequest, ) {
        return NetworkConnectionsApiFp(this.httpClient).getNetworkConnectionById(requestParameters.connectionId, );
    }

    /**
     * Returns all network connections.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
     * @summary List network connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkConnectionsApi
     */
    public getNetworkConnections() {
        return NetworkConnectionsApiFp(this.httpClient).getNetworkConnections();
    }

    /**
     * Retrieves a network by its ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
     * @summary Returns specific network ID.
     * @param {NetworkConnectionsApiGetNetworkIdByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkConnectionsApi
     */
    public getNetworkIdById(requestParameters: NetworkConnectionsApiGetNetworkIdByIdRequest, ) {
        return NetworkConnectionsApiFp(this.httpClient).getNetworkIdById(requestParameters.networkId, );
    }

    /**
     * Retrieves a list of all local and discoverable remote network IDs.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
     * @summary Returns all network IDs, both local IDs and discoverable remote IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkConnectionsApi
     */
    public getNetworkIds() {
        return NetworkConnectionsApiFp(this.httpClient).getNetworkIds();
    }

    /**
     * Update whether or not the network ID is discoverable by others.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
     * @summary Update network ID\'s discoverability.
     * @param {NetworkConnectionsApiSetDiscoverabilityForNetworkIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkConnectionsApi
     */
    public setDiscoverabilityForNetworkId(requestParameters: NetworkConnectionsApiSetDiscoverabilityForNetworkIdRequest, ) {
        return NetworkConnectionsApiFp(this.httpClient).setDiscoverabilityForNetworkId(requestParameters.networkId, requestParameters.setDiscoverabilityForNetworkIdRequest, );
    }

    /**
     * Updates name of a specified network ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
     * @summary Update network ID\'s name.
     * @param {NetworkConnectionsApiSetNetworkIdNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkConnectionsApi
     */
    public setNetworkIdName(requestParameters: NetworkConnectionsApiSetNetworkIdNameRequest, ) {
        return NetworkConnectionsApiFp(this.httpClient).setNetworkIdName(requestParameters.networkId, requestParameters.setNetworkIdNameRequest, );
    }

    /**
     * Updates an existing network connection\'s routing policy.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
     * @summary Update network connection routing policy.
     * @param {NetworkConnectionsApiSetRoutingPolicyForNetworkConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkConnectionsApi
     */
    public setRoutingPolicyForNetworkConnection(requestParameters: NetworkConnectionsApiSetRoutingPolicyForNetworkConnectionRequest, ) {
        return NetworkConnectionsApiFp(this.httpClient).setRoutingPolicyForNetworkConnection(requestParameters.connectionId, requestParameters.setRoutingPolicyForNetworkConnectionRequest, );
    }

    /**
     * Updates the routing policy of a specified network ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto â†’ **Custom**   - Network Profile FIAT â†’ **None**   - Network Connection Crypto â†’ **Default**   - Network Connection FIAT â†’ **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
     * @summary Update network id routing policy.
     * @param {NetworkConnectionsApiSetRoutingPolicyForNetworkIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkConnectionsApi
     */
    public setRoutingPolicyForNetworkId(requestParameters: NetworkConnectionsApiSetRoutingPolicyForNetworkIdRequest, ) {
        return NetworkConnectionsApiFp(this.httpClient).setRoutingPolicyForNetworkId(requestParameters.networkId, requestParameters.setRoutingPolicyForNetworkIdRequest, );
    }
}





    /**
 * OffExchangesApi - axios parameter creator
 * @export
 */
export const OffExchangesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * add collateral, create deposit request
         * @summary add collateral
         * @param {AddCollateralRequestBody} [addCollateralRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOffExchange: async (addCollateralRequestBody?: AddCollateralRequestBody, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/off_exchange/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = addCollateralRequestBody as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns a collateral account by mainExchangeAccountId.
         * @summary Find a specific collateral exchange account
         * @param {string} mainExchangeAccountId The id of the main exchange account for which the requested collateral account is associated with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffExchangeCollateralAccounts: async (mainExchangeAccountId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'mainExchangeAccountId' is not null or undefined
            assertParamExists('getOffExchangeCollateralAccounts', 'mainExchangeAccountId', mainExchangeAccountId)
            const localVarPath = `/off_exchange/collateral_accounts/{mainExchangeAccountId}`
                .replace(`{${"mainExchangeAccountId"}}`, encodeURIComponent(String(mainExchangeAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * get settlements transactions from exchange
         * @summary get settlements transactions from exchange
         * @param {string} mainExchangeAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffExchangeSettlementTransactions: async (mainExchangeAccountId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'mainExchangeAccountId' is not null or undefined
            assertParamExists('getOffExchangeSettlementTransactions', 'mainExchangeAccountId', mainExchangeAccountId)
            const localVarPath = `/off_exchange/settlements/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mainExchangeAccountId !== undefined) {
                localVarQueryParameter['mainExchangeAccountId'] = mainExchangeAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * remove collateral, create withdraw request
         * @summary remove collateral
         * @param {RemoveCollateralRequestBody} [removeCollateralRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOffExchange: async (removeCollateralRequestBody?: RemoveCollateralRequestBody, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/off_exchange/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = removeCollateralRequestBody as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * create settlement for a trader
         * @summary create settlement for a trader
         * @param {SettlementRequestBody} [settlementRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settleOffExchangeTrades: async (settlementRequestBody?: SettlementRequestBody, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/off_exchange/settlements/trader`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = settlementRequestBody as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * OffExchangesApi - functional programming interface
 * @export
 */
export const OffExchangesApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = OffExchangesApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * add collateral, create deposit request
         * @summary add collateral
         * @param {AddCollateralRequestBody} [addCollateralRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOffExchange(addCollateralRequestBody?: AddCollateralRequestBody, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOffExchange(addCollateralRequestBody, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns a collateral account by mainExchangeAccountId.
         * @summary Find a specific collateral exchange account
         * @param {string} mainExchangeAccountId The id of the main exchange account for which the requested collateral account is associated with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffExchangeCollateralAccounts(mainExchangeAccountId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOffExchangeCollateralAccounts(mainExchangeAccountId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * get settlements transactions from exchange
         * @summary get settlements transactions from exchange
         * @param {string} mainExchangeAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffExchangeSettlementTransactions(mainExchangeAccountId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettlementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOffExchangeSettlementTransactions(mainExchangeAccountId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * remove collateral, create withdraw request
         * @summary remove collateral
         * @param {RemoveCollateralRequestBody} [removeCollateralRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOffExchange(removeCollateralRequestBody?: RemoveCollateralRequestBody, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOffExchange(removeCollateralRequestBody, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * create settlement for a trader
         * @summary create settlement for a trader
         * @param {SettlementRequestBody} [settlementRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settleOffExchangeTrades(settlementRequestBody?: SettlementRequestBody, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettlementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settleOffExchangeTrades(settlementRequestBody, );
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for addOffExchange operation in OffExchangesApi.
 * @export
 * @interface OffExchangesApiAddOffExchangeRequest
 */
export interface OffExchangesApiAddOffExchangeRequest {
    /**
     * 
     * @type {AddCollateralRequestBody}
     * @memberof OffExchangesApiAddOffExchange
     */
    readonly addCollateralRequestBody?: AddCollateralRequestBody
}

/**
 * Request parameters for getOffExchangeCollateralAccounts operation in OffExchangesApi.
 * @export
 * @interface OffExchangesApiGetOffExchangeCollateralAccountsRequest
 */
export interface OffExchangesApiGetOffExchangeCollateralAccountsRequest {
    /**
     * The id of the main exchange account for which the requested collateral account is associated with
     * @type {string}
     * @memberof OffExchangesApiGetOffExchangeCollateralAccounts
     */
    readonly mainExchangeAccountId: string
}

/**
 * Request parameters for getOffExchangeSettlementTransactions operation in OffExchangesApi.
 * @export
 * @interface OffExchangesApiGetOffExchangeSettlementTransactionsRequest
 */
export interface OffExchangesApiGetOffExchangeSettlementTransactionsRequest {
    /**
     * 
     * @type {string}
     * @memberof OffExchangesApiGetOffExchangeSettlementTransactions
     */
    readonly mainExchangeAccountId: string
}

/**
 * Request parameters for removeOffExchange operation in OffExchangesApi.
 * @export
 * @interface OffExchangesApiRemoveOffExchangeRequest
 */
export interface OffExchangesApiRemoveOffExchangeRequest {
    /**
     * 
     * @type {RemoveCollateralRequestBody}
     * @memberof OffExchangesApiRemoveOffExchange
     */
    readonly removeCollateralRequestBody?: RemoveCollateralRequestBody
}

/**
 * Request parameters for settleOffExchangeTrades operation in OffExchangesApi.
 * @export
 * @interface OffExchangesApiSettleOffExchangeTradesRequest
 */
export interface OffExchangesApiSettleOffExchangeTradesRequest {
    /**
     * 
     * @type {SettlementRequestBody}
     * @memberof OffExchangesApiSettleOffExchangeTrades
     */
    readonly settlementRequestBody?: SettlementRequestBody
}

/**
 * OffExchangesApi - object-oriented interface
 * @export
 * @class OffExchangesApi
 * @extends {BaseAPI}
 */
export class OffExchangesApi extends BaseAPI {
    /**
     * add collateral, create deposit request
     * @summary add collateral
     * @param {OffExchangesApiAddOffExchangeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffExchangesApi
     */
    public addOffExchange(requestParameters: OffExchangesApiAddOffExchangeRequest = {}, ) {
        return OffExchangesApiFp(this.httpClient).addOffExchange(requestParameters.addCollateralRequestBody, );
    }

    /**
     * Returns a collateral account by mainExchangeAccountId.
     * @summary Find a specific collateral exchange account
     * @param {OffExchangesApiGetOffExchangeCollateralAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffExchangesApi
     */
    public getOffExchangeCollateralAccounts(requestParameters: OffExchangesApiGetOffExchangeCollateralAccountsRequest, ) {
        return OffExchangesApiFp(this.httpClient).getOffExchangeCollateralAccounts(requestParameters.mainExchangeAccountId, );
    }

    /**
     * get settlements transactions from exchange
     * @summary get settlements transactions from exchange
     * @param {OffExchangesApiGetOffExchangeSettlementTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffExchangesApi
     */
    public getOffExchangeSettlementTransactions(requestParameters: OffExchangesApiGetOffExchangeSettlementTransactionsRequest, ) {
        return OffExchangesApiFp(this.httpClient).getOffExchangeSettlementTransactions(requestParameters.mainExchangeAccountId, );
    }

    /**
     * remove collateral, create withdraw request
     * @summary remove collateral
     * @param {OffExchangesApiRemoveOffExchangeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffExchangesApi
     */
    public removeOffExchange(requestParameters: OffExchangesApiRemoveOffExchangeRequest = {}, ) {
        return OffExchangesApiFp(this.httpClient).removeOffExchange(requestParameters.removeCollateralRequestBody, );
    }

    /**
     * create settlement for a trader
     * @summary create settlement for a trader
     * @param {OffExchangesApiSettleOffExchangeTradesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffExchangesApi
     */
    public settleOffExchangeTrades(requestParameters: OffExchangesApiSettleOffExchangeTradesRequest = {}, ) {
        return OffExchangesApiFp(this.httpClient).settleOffExchangeTrades(requestParameters.settlementRequestBody, );
    }
}





    /**
 * PaymentsCrossBorderSettlementApi - axios parameter creator
 * @export
 */
export const PaymentsCrossBorderSettlementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <u><b>Create a new cross-border settlement configuration. </u></b></br>Configurations define the default assets, on-ramps, and off-ramps to use for the cross-border settlement. </br>  A configuration must contain at least two steps - `ON_RAMP` and `VAULT_ACCOUNT`. </br> All other steps (e.g., `OFF_RAMP`, `FIAT_DESTINATION`, etc.) are optional. </br> Every step must include the `accountId` to be used, while `inputAssetId` and `outputAssetId` are optional.  If those are not provided, a default value will be used from the Corridor Settings.</br> If the inputAssetId or the outputAssetId is provided for one of the objects, all assets in the objects must be consistent. For example, if the output asset of ON_RAMP is XLM_USDC_5F3T, then the input asset of the VAULT_ACCOUNT must also be XLM_USDC_5F3T..</br> You can set a slippage amount for your configuration. Slippage is defined by basis points (bps). This value can be overloaded on execution. If you do not configure a slippage amount, the default slippage of 10000 bps (10%) is used. </br> **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
         * @summary Create a new cross-border settlement configuration
         * @param {XBSettlementConfigCreationRequestBody} [xBSettlementConfigCreationRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createXBSettlementConfig: async (xBSettlementConfigCreationRequestBody?: XBSettlementConfigCreationRequestBody, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/payments/xb-settlements/configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = xBSettlementConfigCreationRequestBody as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Create a cross-border flow (based on a cross-border configuration) with an amount to transfer.  The assetId is defined by the cross-border configuration. Creating a flow triggers a calculation of the flow estimations, including FX rates, times, and fees based on the amount provided. Creating a cross-border flow will not execute the flow.  **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
         * @summary Create a new cross-border settlement flow
         * @param {XBSettlementCreateFlowRequestBody} [xBSettlementCreateFlowRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createXBSettlementFlow: async (xBSettlementCreateFlowRequestBody?: XBSettlementCreateFlowRequestBody, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/payments/xb-settlements/flows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = xBSettlementCreateFlowRequestBody as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Delete a cross-border settlement configuration. This does not delete or remove previously executed flows that used this configuration. **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
         * @summary Delete a cross-border settlement configuration
         * @param {string} configId The cross-border settlement configuration ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteXBSettlementConfig: async (configId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'configId' is not null or undefined
            assertParamExists('deleteXBSettlementConfig', 'configId', configId)
            const localVarPath = `/payments/xb-settlements/configs/{configId}`
                .replace(`{${"configId"}}`, encodeURIComponent(String(configId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'DELETE'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Send a payment flow with \'flowId\' for execution. If a differet slippage configuraion is needed for this execution than configured in the flow configuration, the request body must define the desired slippage configuration for this execution.  **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
         * @summary Execute cross-border settlement flow
         * @param {string} flowId The cross-border settlement flow ID.
         * @param {XBSettlementFlowExecutionRequestBody} [xBSettlementFlowExecutionRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeXBSettlementFlowAction: async (flowId: string, xBSettlementFlowExecutionRequestBody?: XBSettlementFlowExecutionRequestBody, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('executeXBSettlementFlowAction', 'flowId', flowId)
            const localVarPath = `/payments/xb-settlements/flows/{flowId}/actions/execute`
                .replace(`{${"flowId"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = xBSettlementFlowExecutionRequestBody as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Get a specific cross-border settlement configuration.</br> **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
         * @summary Get a specific cross-border settlement configuration
         * @param {string} configId The cross-border settlement configuration ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXBSettlementConfigById: async (configId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'configId' is not null or undefined
            assertParamExists('getXBSettlementConfigById', 'configId', configId)
            const localVarPath = `/payments/xb-settlements/configs/{configId}`
                .replace(`{${"configId"}}`, encodeURIComponent(String(configId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Get all the cross-border settlement configurations. </br> **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
         * @summary Get all the cross-border settlement configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXBSettlementConfigs: async (): Promise<AxiosRequestConfig> => {
            const localVarPath = `/payments/xb-settlements/configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Gets details for a specific cross-border settlement flow **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
         * @summary Get specific cross-border settlement flow details
         * @param {string} flowId The cross-border settlement flow ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXBSettlementFlowById: async (flowId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('getXBSettlementFlowById', 'flowId', flowId)
            const localVarPath = `/payments/xb-settlements/flows/{flowId}`
                .replace(`{${"flowId"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Edit a cross-border settlement configuration. Editing a configuration does not affect previously executed flows that used the configuration. **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
         * @summary Edit a cross-border settlement configuration
         * @param {string} configId The cross-border settlement configuration ID.
         * @param {XBSettlementConfigEditRequestBody} [xBSettlementConfigEditRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateXBSettlementConfig: async (configId: string, xBSettlementConfigEditRequestBody?: XBSettlementConfigEditRequestBody, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'configId' is not null or undefined
            assertParamExists('updateXBSettlementConfig', 'configId', configId)
            const localVarPath = `/payments/xb-settlements/configs/{configId}`
                .replace(`{${"configId"}}`, encodeURIComponent(String(configId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'PUT'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = xBSettlementConfigEditRequestBody as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsCrossBorderSettlementApi - functional programming interface
 * @export
 */
export const PaymentsCrossBorderSettlementApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = PaymentsCrossBorderSettlementApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * <u><b>Create a new cross-border settlement configuration. </u></b></br>Configurations define the default assets, on-ramps, and off-ramps to use for the cross-border settlement. </br>  A configuration must contain at least two steps - `ON_RAMP` and `VAULT_ACCOUNT`. </br> All other steps (e.g., `OFF_RAMP`, `FIAT_DESTINATION`, etc.) are optional. </br> Every step must include the `accountId` to be used, while `inputAssetId` and `outputAssetId` are optional.  If those are not provided, a default value will be used from the Corridor Settings.</br> If the inputAssetId or the outputAssetId is provided for one of the objects, all assets in the objects must be consistent. For example, if the output asset of ON_RAMP is XLM_USDC_5F3T, then the input asset of the VAULT_ACCOUNT must also be XLM_USDC_5F3T..</br> You can set a slippage amount for your configuration. Slippage is defined by basis points (bps). This value can be overloaded on execution. If you do not configure a slippage amount, the default slippage of 10000 bps (10%) is used. </br> **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
         * @summary Create a new cross-border settlement configuration
         * @param {XBSettlementConfigCreationRequestBody} [xBSettlementConfigCreationRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createXBSettlementConfig(xBSettlementConfigCreationRequestBody?: XBSettlementConfigCreationRequestBody, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<XBSettlementConfigModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createXBSettlementConfig(xBSettlementConfigCreationRequestBody, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Create a cross-border flow (based on a cross-border configuration) with an amount to transfer.  The assetId is defined by the cross-border configuration. Creating a flow triggers a calculation of the flow estimations, including FX rates, times, and fees based on the amount provided. Creating a cross-border flow will not execute the flow.  **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
         * @summary Create a new cross-border settlement flow
         * @param {XBSettlementCreateFlowRequestBody} [xBSettlementCreateFlowRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createXBSettlementFlow(xBSettlementCreateFlowRequestBody?: XBSettlementCreateFlowRequestBody, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<XBSettlementFlowPreviewModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createXBSettlementFlow(xBSettlementCreateFlowRequestBody, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Delete a cross-border settlement configuration. This does not delete or remove previously executed flows that used this configuration. **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
         * @summary Delete a cross-border settlement configuration
         * @param {string} configId The cross-border settlement configuration ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteXBSettlementConfig(configId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<XBSettlementConfigModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteXBSettlementConfig(configId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Send a payment flow with \'flowId\' for execution. If a differet slippage configuraion is needed for this execution than configured in the flow configuration, the request body must define the desired slippage configuration for this execution.  **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
         * @summary Execute cross-border settlement flow
         * @param {string} flowId The cross-border settlement flow ID.
         * @param {XBSettlementFlowExecutionRequestBody} [xBSettlementFlowExecutionRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeXBSettlementFlowAction(flowId: string, xBSettlementFlowExecutionRequestBody?: XBSettlementFlowExecutionRequestBody, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<XBSettlementFlowExecutionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeXBSettlementFlowAction(flowId, xBSettlementFlowExecutionRequestBody, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Get a specific cross-border settlement configuration.</br> **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
         * @summary Get a specific cross-border settlement configuration
         * @param {string} configId The cross-border settlement configuration ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getXBSettlementConfigById(configId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<XBSettlementConfigModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getXBSettlementConfigById(configId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Get all the cross-border settlement configurations. </br> **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
         * @summary Get all the cross-border settlement configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getXBSettlementConfigs(): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<XBSettlementGetAllConfigsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getXBSettlementConfigs();
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Gets details for a specific cross-border settlement flow **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
         * @summary Get specific cross-border settlement flow details
         * @param {string} flowId The cross-border settlement flow ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getXBSettlementFlowById(flowId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<XBSettlementGetFlowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getXBSettlementFlowById(flowId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Edit a cross-border settlement configuration. Editing a configuration does not affect previously executed flows that used the configuration. **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
         * @summary Edit a cross-border settlement configuration
         * @param {string} configId The cross-border settlement configuration ID.
         * @param {XBSettlementConfigEditRequestBody} [xBSettlementConfigEditRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateXBSettlementConfig(configId: string, xBSettlementConfigEditRequestBody?: XBSettlementConfigEditRequestBody, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<XBSettlementConfigModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateXBSettlementConfig(configId, xBSettlementConfigEditRequestBody, );
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for createXBSettlementConfig operation in PaymentsCrossBorderSettlementApi.
 * @export
 * @interface PaymentsCrossBorderSettlementApiCreateXBSettlementConfigRequest
 */
export interface PaymentsCrossBorderSettlementApiCreateXBSettlementConfigRequest {
    /**
     * 
     * @type {XBSettlementConfigCreationRequestBody}
     * @memberof PaymentsCrossBorderSettlementApiCreateXBSettlementConfig
     */
    readonly xBSettlementConfigCreationRequestBody?: XBSettlementConfigCreationRequestBody
}

/**
 * Request parameters for createXBSettlementFlow operation in PaymentsCrossBorderSettlementApi.
 * @export
 * @interface PaymentsCrossBorderSettlementApiCreateXBSettlementFlowRequest
 */
export interface PaymentsCrossBorderSettlementApiCreateXBSettlementFlowRequest {
    /**
     * 
     * @type {XBSettlementCreateFlowRequestBody}
     * @memberof PaymentsCrossBorderSettlementApiCreateXBSettlementFlow
     */
    readonly xBSettlementCreateFlowRequestBody?: XBSettlementCreateFlowRequestBody
}

/**
 * Request parameters for deleteXBSettlementConfig operation in PaymentsCrossBorderSettlementApi.
 * @export
 * @interface PaymentsCrossBorderSettlementApiDeleteXBSettlementConfigRequest
 */
export interface PaymentsCrossBorderSettlementApiDeleteXBSettlementConfigRequest {
    /**
     * The cross-border settlement configuration ID.
     * @type {string}
     * @memberof PaymentsCrossBorderSettlementApiDeleteXBSettlementConfig
     */
    readonly configId: string
}

/**
 * Request parameters for executeXBSettlementFlowAction operation in PaymentsCrossBorderSettlementApi.
 * @export
 * @interface PaymentsCrossBorderSettlementApiExecuteXBSettlementFlowActionRequest
 */
export interface PaymentsCrossBorderSettlementApiExecuteXBSettlementFlowActionRequest {
    /**
     * The cross-border settlement flow ID.
     * @type {string}
     * @memberof PaymentsCrossBorderSettlementApiExecuteXBSettlementFlowAction
     */
    readonly flowId: string

    /**
     * 
     * @type {XBSettlementFlowExecutionRequestBody}
     * @memberof PaymentsCrossBorderSettlementApiExecuteXBSettlementFlowAction
     */
    readonly xBSettlementFlowExecutionRequestBody?: XBSettlementFlowExecutionRequestBody
}

/**
 * Request parameters for getXBSettlementConfigById operation in PaymentsCrossBorderSettlementApi.
 * @export
 * @interface PaymentsCrossBorderSettlementApiGetXBSettlementConfigByIdRequest
 */
export interface PaymentsCrossBorderSettlementApiGetXBSettlementConfigByIdRequest {
    /**
     * The cross-border settlement configuration ID.
     * @type {string}
     * @memberof PaymentsCrossBorderSettlementApiGetXBSettlementConfigById
     */
    readonly configId: string
}

/**
 * Request parameters for getXBSettlementFlowById operation in PaymentsCrossBorderSettlementApi.
 * @export
 * @interface PaymentsCrossBorderSettlementApiGetXBSettlementFlowByIdRequest
 */
export interface PaymentsCrossBorderSettlementApiGetXBSettlementFlowByIdRequest {
    /**
     * The cross-border settlement flow ID.
     * @type {string}
     * @memberof PaymentsCrossBorderSettlementApiGetXBSettlementFlowById
     */
    readonly flowId: string
}

/**
 * Request parameters for updateXBSettlementConfig operation in PaymentsCrossBorderSettlementApi.
 * @export
 * @interface PaymentsCrossBorderSettlementApiUpdateXBSettlementConfigRequest
 */
export interface PaymentsCrossBorderSettlementApiUpdateXBSettlementConfigRequest {
    /**
     * The cross-border settlement configuration ID.
     * @type {string}
     * @memberof PaymentsCrossBorderSettlementApiUpdateXBSettlementConfig
     */
    readonly configId: string

    /**
     * 
     * @type {XBSettlementConfigEditRequestBody}
     * @memberof PaymentsCrossBorderSettlementApiUpdateXBSettlementConfig
     */
    readonly xBSettlementConfigEditRequestBody?: XBSettlementConfigEditRequestBody
}

/**
 * PaymentsCrossBorderSettlementApi - object-oriented interface
 * @export
 * @class PaymentsCrossBorderSettlementApi
 * @extends {BaseAPI}
 */
export class PaymentsCrossBorderSettlementApi extends BaseAPI {
    /**
     * <u><b>Create a new cross-border settlement configuration. </u></b></br>Configurations define the default assets, on-ramps, and off-ramps to use for the cross-border settlement. </br>  A configuration must contain at least two steps - `ON_RAMP` and `VAULT_ACCOUNT`. </br> All other steps (e.g., `OFF_RAMP`, `FIAT_DESTINATION`, etc.) are optional. </br> Every step must include the `accountId` to be used, while `inputAssetId` and `outputAssetId` are optional.  If those are not provided, a default value will be used from the Corridor Settings.</br> If the inputAssetId or the outputAssetId is provided for one of the objects, all assets in the objects must be consistent. For example, if the output asset of ON_RAMP is XLM_USDC_5F3T, then the input asset of the VAULT_ACCOUNT must also be XLM_USDC_5F3T..</br> You can set a slippage amount for your configuration. Slippage is defined by basis points (bps). This value can be overloaded on execution. If you do not configure a slippage amount, the default slippage of 10000 bps (10%) is used. </br> **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
     * @summary Create a new cross-border settlement configuration
     * @param {PaymentsCrossBorderSettlementApiCreateXBSettlementConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsCrossBorderSettlementApi
     */
    public createXBSettlementConfig(requestParameters: PaymentsCrossBorderSettlementApiCreateXBSettlementConfigRequest = {}, ) {
        return PaymentsCrossBorderSettlementApiFp(this.httpClient).createXBSettlementConfig(requestParameters.xBSettlementConfigCreationRequestBody, );
    }

    /**
     * Create a cross-border flow (based on a cross-border configuration) with an amount to transfer.  The assetId is defined by the cross-border configuration. Creating a flow triggers a calculation of the flow estimations, including FX rates, times, and fees based on the amount provided. Creating a cross-border flow will not execute the flow.  **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
     * @summary Create a new cross-border settlement flow
     * @param {PaymentsCrossBorderSettlementApiCreateXBSettlementFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsCrossBorderSettlementApi
     */
    public createXBSettlementFlow(requestParameters: PaymentsCrossBorderSettlementApiCreateXBSettlementFlowRequest = {}, ) {
        return PaymentsCrossBorderSettlementApiFp(this.httpClient).createXBSettlementFlow(requestParameters.xBSettlementCreateFlowRequestBody, );
    }

    /**
     * Delete a cross-border settlement configuration. This does not delete or remove previously executed flows that used this configuration. **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
     * @summary Delete a cross-border settlement configuration
     * @param {PaymentsCrossBorderSettlementApiDeleteXBSettlementConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsCrossBorderSettlementApi
     */
    public deleteXBSettlementConfig(requestParameters: PaymentsCrossBorderSettlementApiDeleteXBSettlementConfigRequest, ) {
        return PaymentsCrossBorderSettlementApiFp(this.httpClient).deleteXBSettlementConfig(requestParameters.configId, );
    }

    /**
     * Send a payment flow with \'flowId\' for execution. If a differet slippage configuraion is needed for this execution than configured in the flow configuration, the request body must define the desired slippage configuration for this execution.  **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
     * @summary Execute cross-border settlement flow
     * @param {PaymentsCrossBorderSettlementApiExecuteXBSettlementFlowActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsCrossBorderSettlementApi
     */
    public executeXBSettlementFlowAction(requestParameters: PaymentsCrossBorderSettlementApiExecuteXBSettlementFlowActionRequest, ) {
        return PaymentsCrossBorderSettlementApiFp(this.httpClient).executeXBSettlementFlowAction(requestParameters.flowId, requestParameters.xBSettlementFlowExecutionRequestBody, );
    }

    /**
     * Get a specific cross-border settlement configuration.</br> **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
     * @summary Get a specific cross-border settlement configuration
     * @param {PaymentsCrossBorderSettlementApiGetXBSettlementConfigByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsCrossBorderSettlementApi
     */
    public getXBSettlementConfigById(requestParameters: PaymentsCrossBorderSettlementApiGetXBSettlementConfigByIdRequest, ) {
        return PaymentsCrossBorderSettlementApiFp(this.httpClient).getXBSettlementConfigById(requestParameters.configId, );
    }

    /**
     * Get all the cross-border settlement configurations. </br> **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
     * @summary Get all the cross-border settlement configurations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsCrossBorderSettlementApi
     */
    public getXBSettlementConfigs() {
        return PaymentsCrossBorderSettlementApiFp(this.httpClient).getXBSettlementConfigs();
    }

    /**
     * Gets details for a specific cross-border settlement flow **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
     * @summary Get specific cross-border settlement flow details
     * @param {PaymentsCrossBorderSettlementApiGetXBSettlementFlowByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsCrossBorderSettlementApi
     */
    public getXBSettlementFlowById(requestParameters: PaymentsCrossBorderSettlementApiGetXBSettlementFlowByIdRequest, ) {
        return PaymentsCrossBorderSettlementApiFp(this.httpClient).getXBSettlementFlowById(requestParameters.flowId, );
    }

    /**
     * Edit a cross-border settlement configuration. Editing a configuration does not affect previously executed flows that used the configuration. **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts. These endpoints are currently in beta and might be subject to changes. If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com. 
     * @summary Edit a cross-border settlement configuration
     * @param {PaymentsCrossBorderSettlementApiUpdateXBSettlementConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsCrossBorderSettlementApi
     */
    public updateXBSettlementConfig(requestParameters: PaymentsCrossBorderSettlementApiUpdateXBSettlementConfigRequest, ) {
        return PaymentsCrossBorderSettlementApiFp(this.httpClient).updateXBSettlementConfig(requestParameters.configId, requestParameters.xBSettlementConfigEditRequestBody, );
    }
}





    /**
 * PaymentsPayoutApi - axios parameter creator
 * @export
 */
export const PaymentsPayoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoints include APIs available only for customers with Payments Engine enabled on their accounts. </br> </br>These endpoints are currently in beta and might be subject to changes.</br> </br>If you want to learn more about Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or email CSM@fireblocks.com. </br> </br> <b u>Create a payout instruction set.</b> </u></br> A payout instruction set is a set of instructions for distributing payments from a single payment account to a list of payee accounts. </br> The instruction set defines: </br> <ul> <li>the payment account and its account type (vault, exchange, or fiat). </li> <li>the account type (vault account, exchange account, whitelisted address, network connection, fiat account, or merchant account), the amount, and the asset of payment for each payee account.</li> </ul> 
         * @summary Create a payout instruction set
         * @param {CreatePayoutRequest} [createPayoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayout: async (createPayoutRequest?: CreatePayoutRequest, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/payments/payout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = createPayoutRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoints include APIs available only for customers with Payments Engine enabled on their accounts. </br> </br>These endpoints are currently in beta and might be subject to changes.</br> </br>If you want to learn more about Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or email CSM@fireblocks.com. </br> </br><b u>Execute a payout instruction set.</b> </u> </br> </br>The instruction set will be verified and executed.</br> <b><u>Source locking</br></b> </u> If you are executing a payout instruction set from a payment account with an already active payout the active payout will complete before the new payout instruction set can be executed. </br> You cannot execute the same payout instruction set more than once. 
         * @summary Execute a payout instruction set
         * @param {string} payoutId the payout id received from the creation of the payout instruction set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePayoutAction: async (payoutId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'payoutId' is not null or undefined
            assertParamExists('executePayoutAction', 'payoutId', payoutId)
            const localVarPath = `/payments/payout/{payoutId}/actions/execute`
                .replace(`{${"payoutId"}}`, encodeURIComponent(String(payoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoints include APIs available only for customers with Payments Engine enabled on their accounts. </br> </br>These endpoints are currently in beta and might be subject to changes.</br> </br>If you want to learn more about Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or email CSM@fireblocks.com. </br> 
         * @summary Get the status of a payout instruction set
         * @param {string} payoutId the payout id received from the creation of the payout instruction set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutById: async (payoutId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'payoutId' is not null or undefined
            assertParamExists('getPayoutById', 'payoutId', payoutId)
            const localVarPath = `/payments/payout/{payoutId}`
                .replace(`{${"payoutId"}}`, encodeURIComponent(String(payoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsPayoutApi - functional programming interface
 * @export
 */
export const PaymentsPayoutApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = PaymentsPayoutApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoints include APIs available only for customers with Payments Engine enabled on their accounts. </br> </br>These endpoints are currently in beta and might be subject to changes.</br> </br>If you want to learn more about Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or email CSM@fireblocks.com. </br> </br> <b u>Create a payout instruction set.</b> </u></br> A payout instruction set is a set of instructions for distributing payments from a single payment account to a list of payee accounts. </br> The instruction set defines: </br> <ul> <li>the payment account and its account type (vault, exchange, or fiat). </li> <li>the account type (vault account, exchange account, whitelisted address, network connection, fiat account, or merchant account), the amount, and the asset of payment for each payee account.</li> </ul> 
         * @summary Create a payout instruction set
         * @param {CreatePayoutRequest} [createPayoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayout(createPayoutRequest?: CreatePayoutRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayout(createPayoutRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoints include APIs available only for customers with Payments Engine enabled on their accounts. </br> </br>These endpoints are currently in beta and might be subject to changes.</br> </br>If you want to learn more about Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or email CSM@fireblocks.com. </br> </br><b u>Execute a payout instruction set.</b> </u> </br> </br>The instruction set will be verified and executed.</br> <b><u>Source locking</br></b> </u> If you are executing a payout instruction set from a payment account with an already active payout the active payout will complete before the new payout instruction set can be executed. </br> You cannot execute the same payout instruction set more than once. 
         * @summary Execute a payout instruction set
         * @param {string} payoutId the payout id received from the creation of the payout instruction set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePayoutAction(payoutId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DispatchPayoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePayoutAction(payoutId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoints include APIs available only for customers with Payments Engine enabled on their accounts. </br> </br>These endpoints are currently in beta and might be subject to changes.</br> </br>If you want to learn more about Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or email CSM@fireblocks.com. </br> 
         * @summary Get the status of a payout instruction set
         * @param {string} payoutId the payout id received from the creation of the payout instruction set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayoutById(payoutId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayoutById(payoutId, );
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for createPayout operation in PaymentsPayoutApi.
 * @export
 * @interface PaymentsPayoutApiCreatePayoutRequest
 */
export interface PaymentsPayoutApiCreatePayoutRequest {
    /**
     * 
     * @type {CreatePayoutRequest}
     * @memberof PaymentsPayoutApiCreatePayout
     */
    readonly createPayoutRequest?: CreatePayoutRequest
}

/**
 * Request parameters for executePayoutAction operation in PaymentsPayoutApi.
 * @export
 * @interface PaymentsPayoutApiExecutePayoutActionRequest
 */
export interface PaymentsPayoutApiExecutePayoutActionRequest {
    /**
     * the payout id received from the creation of the payout instruction set
     * @type {string}
     * @memberof PaymentsPayoutApiExecutePayoutAction
     */
    readonly payoutId: string
}

/**
 * Request parameters for getPayoutById operation in PaymentsPayoutApi.
 * @export
 * @interface PaymentsPayoutApiGetPayoutByIdRequest
 */
export interface PaymentsPayoutApiGetPayoutByIdRequest {
    /**
     * the payout id received from the creation of the payout instruction set
     * @type {string}
     * @memberof PaymentsPayoutApiGetPayoutById
     */
    readonly payoutId: string
}

/**
 * PaymentsPayoutApi - object-oriented interface
 * @export
 * @class PaymentsPayoutApi
 * @extends {BaseAPI}
 */
export class PaymentsPayoutApi extends BaseAPI {
    /**
     * **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoints include APIs available only for customers with Payments Engine enabled on their accounts. </br> </br>These endpoints are currently in beta and might be subject to changes.</br> </br>If you want to learn more about Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or email CSM@fireblocks.com. </br> </br> <b u>Create a payout instruction set.</b> </u></br> A payout instruction set is a set of instructions for distributing payments from a single payment account to a list of payee accounts. </br> The instruction set defines: </br> <ul> <li>the payment account and its account type (vault, exchange, or fiat). </li> <li>the account type (vault account, exchange account, whitelisted address, network connection, fiat account, or merchant account), the amount, and the asset of payment for each payee account.</li> </ul> 
     * @summary Create a payout instruction set
     * @param {PaymentsPayoutApiCreatePayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsPayoutApi
     */
    public createPayout(requestParameters: PaymentsPayoutApiCreatePayoutRequest = {}, ) {
        return PaymentsPayoutApiFp(this.httpClient).createPayout(requestParameters.createPayoutRequest, );
    }

    /**
     * **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoints include APIs available only for customers with Payments Engine enabled on their accounts. </br> </br>These endpoints are currently in beta and might be subject to changes.</br> </br>If you want to learn more about Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or email CSM@fireblocks.com. </br> </br><b u>Execute a payout instruction set.</b> </u> </br> </br>The instruction set will be verified and executed.</br> <b><u>Source locking</br></b> </u> If you are executing a payout instruction set from a payment account with an already active payout the active payout will complete before the new payout instruction set can be executed. </br> You cannot execute the same payout instruction set more than once. 
     * @summary Execute a payout instruction set
     * @param {PaymentsPayoutApiExecutePayoutActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsPayoutApi
     */
    public executePayoutAction(requestParameters: PaymentsPayoutApiExecutePayoutActionRequest, ) {
        return PaymentsPayoutApiFp(this.httpClient).executePayoutAction(requestParameters.payoutId, );
    }

    /**
     * **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoints include APIs available only for customers with Payments Engine enabled on their accounts. </br> </br>These endpoints are currently in beta and might be subject to changes.</br> </br>If you want to learn more about Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or email CSM@fireblocks.com. </br> 
     * @summary Get the status of a payout instruction set
     * @param {PaymentsPayoutApiGetPayoutByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsPayoutApi
     */
    public getPayoutById(requestParameters: PaymentsPayoutApiGetPayoutByIdRequest, ) {
        return PaymentsPayoutApiFp(this.httpClient).getPayoutById(requestParameters.payoutId, );
    }
}





    /**
 * SupportedAssetsApi - axios parameter creator
 * @export
 */
export const SupportedAssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all asset types supported by Fireblocks.
         * @summary List all asset types supported by Fireblocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedAssets: async (): Promise<AxiosRequestConfig> => {
            const localVarPath = `/supported_assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * SupportedAssetsApi - functional programming interface
 * @export
 */
export const SupportedAssetsApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = SupportedAssetsApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * Returns all asset types supported by Fireblocks.
         * @summary List all asset types supported by Fireblocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupportedAssets(): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupportedAssets();
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * SupportedAssetsApi - object-oriented interface
 * @export
 * @class SupportedAssetsApi
 * @extends {BaseAPI}
 */
export class SupportedAssetsApi extends BaseAPI {
    /**
     * Returns all asset types supported by Fireblocks.
     * @summary List all asset types supported by Fireblocks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportedAssetsApi
     */
    public getSupportedAssets() {
        return SupportedAssetsApiFp(this.httpClient).getSupportedAssets();
    }
}





    /**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels a transaction by ID.
         * @summary Cancel a transaction
         * @param {string} txId The ID of the transaction to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransaction: async (txId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('cancelTransaction', 'txId', txId)
            const localVarPath = `/transactions/{txId}/cancel`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Creates a new transaction.
         * @summary Create a new transaction
         * @param {TransactionRequest} [transactionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction: async (transactionRequest?: TransactionRequest, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = transactionRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Drops a stuck ETH transaction and creates a replacement transaction.
         * @summary Drop ETH transaction by ID
         * @param {string} txId The ID of the transaction
         * @param {DropTransactionRequest} [dropTransactionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropTransaction: async (txId: string, dropTransactionRequest?: DropTransactionRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('dropTransaction', 'txId', txId)
            const localVarPath = `/transactions/{txId}/drop`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = dropTransactionRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Gets the estimated required fee for an asset. For UTXO based assets, the response will contain the suggested fee per byte, for ETH/ETC based assets, the suggested gas price, and for XRP/XLM, the transaction fee.
         * @summary Estimate the required fee for an asset
         * @param {string} assetId The asset for which to estimate the fee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateNetworkFee: async (assetId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('estimateNetworkFee', 'assetId', assetId)
            const localVarPath = `/estimate_network_fee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (assetId !== undefined) {
                localVarQueryParameter['assetId'] = assetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Estimates the transaction fee for a transaction request. * Note: Supports all Fireblocks assets except ZCash (ZEC).
         * @summary Estimate transaction fee
         * @param {TransactionRequest} [transactionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateTransactionFee: async (transactionRequest?: TransactionRequest, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/transactions/estimate_fee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = transactionRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Freezes a transaction by ID.
         * @summary Freeze a transaction
         * @param {string} txId The ID of the transaction to freeze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        freezeTransaction: async (txId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('freezeTransaction', 'txId', txId)
            const localVarPath = `/transactions/{txId}/freeze`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns transaction by external transaction ID.
         * @summary Find a specific transaction by external transaction ID
         * @param {string} externalTxId The external ID of the transaction to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByExternalId: async (externalTxId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'externalTxId' is not null or undefined
            assertParamExists('getTransactionByExternalId', 'externalTxId', externalTxId)
            const localVarPath = `/transactions/external_tx_id/{externalTxId}/`
                .replace(`{${"externalTxId"}}`, encodeURIComponent(String(externalTxId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns a transaction by ID.
         * @summary Find a specific transaction by Fireblocks transaction ID
         * @param {string} txId The ID of the transaction to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById: async (txId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('getTransactionById', 'txId', txId)
            const localVarPath = `/transactions/{txId}`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Lists the transaction history for your workspace.
         * @summary List transaction history
         * @param {string} [before] Unix timestamp in milliseconds. Returns only transactions created before the specified date
         * @param {string} [after] Unix timestamp in milliseconds. Returns only transactions created after the specified date
         * @param {string} [status] You can filter by one of the statuses.
         * @param {'createdAt' | 'lastUpdated'} [orderBy] The field to order the results by
         * @param {'ASC' | 'DESC'} [sort] The direction to order the results by
         * @param {number} [limit] Limits the number of results. If not provided, a limit of 200 will be used. The maximum allowed limit is 500
         * @param {'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'UNKNOWN' | 'GAS_STATION' | 'OEC_PARTNER' | 'END_USER_WALLET'} [sourceType] The source type of the transaction
         * @param {string} [sourceId] The source ID of the transaction
         * @param {'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'ONE_TIME_ADDRESS' | 'OEC_PARTNER' | 'END_USER_WALLET'} [destType] The destination type of the transaction
         * @param {string} [destId] The destination ID of the transaction
         * @param {string} [assets] A list of assets to filter by, seperated by commas
         * @param {string} [txHash] Returns only results with a specified txHash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: async (before?: string, after?: string, status?: string, orderBy?: 'createdAt' | 'lastUpdated', sort?: 'ASC' | 'DESC', limit?: number, sourceType?: 'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'UNKNOWN' | 'GAS_STATION' | 'OEC_PARTNER' | 'END_USER_WALLET', sourceId?: string, destType?: 'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'ONE_TIME_ADDRESS' | 'OEC_PARTNER' | 'END_USER_WALLET', destId?: string, assets?: string, txHash?: string, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sourceType !== undefined) {
                localVarQueryParameter['sourceType'] = sourceType;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (destType !== undefined) {
                localVarQueryParameter['destType'] = destType;
            }

            if (destId !== undefined) {
                localVarQueryParameter['destId'] = destId;
            }

            if (assets !== undefined) {
                localVarQueryParameter['assets'] = assets;
            }

            if (txHash !== undefined) {
                localVarQueryParameter['txHash'] = txHash;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Overrides the required number of confirmations for transaction completion by transaction ID.
         * @summary Set confirmation threshold by transaction ID
         * @param {string} txId The ID of the transaction
         * @param {SetConfirmationsThresholdRequest} [setConfirmationsThresholdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfirmationThresholdForTransaction: async (txId: string, setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('setConfirmationThresholdForTransaction', 'txId', txId)
            const localVarPath = `/transactions/{txId}/set_confirmation_threshold`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = setConfirmationsThresholdRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Overrides the required number of confirmations for transaction completion by transaction hash.
         * @summary Set confirmation threshold by transaction hash
         * @param {string} txHash The TxHash
         * @param {SetConfirmationsThresholdRequest} [setConfirmationsThresholdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfirmationThresholdForTransactionByHash: async (txHash: string, setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'txHash' is not null or undefined
            assertParamExists('setConfirmationThresholdForTransactionByHash', 'txHash', txHash)
            const localVarPath = `/txHash/{txHash}/set_confirmation_threshold`
                .replace(`{${"txHash"}}`, encodeURIComponent(String(txHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = setConfirmationsThresholdRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Unfreezes a transaction by ID and makes the transaction available again.
         * @summary Unfreeze a transaction
         * @param {string} txId The ID of the transaction to unfreeze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfreezeTransaction: async (txId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('unfreezeTransaction', 'txId', txId)
            const localVarPath = `/transactions/{txId}/unfreeze`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Checks if an address is valid (for XRP, DOT, XLM, and EOS).
         * @summary Validate destination address
         * @param {string} assetId The asset of the address
         * @param {string} address The address to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAddress: async (assetId: string, address: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('validateAddress', 'assetId', assetId)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('validateAddress', 'address', address)
            const localVarPath = `/transactions/validate_address/{assetId}/{address}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * Cancels a transaction by ID.
         * @summary Cancel a transaction
         * @param {string} txId The ID of the transaction to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTransaction(txId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTransaction(txId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Creates a new transaction.
         * @summary Create a new transaction
         * @param {TransactionRequest} [transactionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransaction(transactionRequest?: TransactionRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransaction(transactionRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Drops a stuck ETH transaction and creates a replacement transaction.
         * @summary Drop ETH transaction by ID
         * @param {string} txId The ID of the transaction
         * @param {DropTransactionRequest} [dropTransactionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dropTransaction(txId: string, dropTransactionRequest?: DropTransactionRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DropTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dropTransaction(txId, dropTransactionRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Gets the estimated required fee for an asset. For UTXO based assets, the response will contain the suggested fee per byte, for ETH/ETC based assets, the suggested gas price, and for XRP/XLM, the transaction fee.
         * @summary Estimate the required fee for an asset
         * @param {string} assetId The asset for which to estimate the fee
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateNetworkFee(assetId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimatedNetworkFeeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.estimateNetworkFee(assetId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Estimates the transaction fee for a transaction request. * Note: Supports all Fireblocks assets except ZCash (ZEC).
         * @summary Estimate transaction fee
         * @param {TransactionRequest} [transactionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateTransactionFee(transactionRequest?: TransactionRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimatedTransactionFeeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.estimateTransactionFee(transactionRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Freezes a transaction by ID.
         * @summary Freeze a transaction
         * @param {string} txId The ID of the transaction to freeze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async freezeTransaction(txId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FreezeTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.freezeTransaction(txId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns transaction by external transaction ID.
         * @summary Find a specific transaction by external transaction ID
         * @param {string} externalTxId The external ID of the transaction to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionByExternalId(externalTxId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionByExternalId(externalTxId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns a transaction by ID.
         * @summary Find a specific transaction by Fireblocks transaction ID
         * @param {string} txId The ID of the transaction to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionById(txId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionById(txId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Lists the transaction history for your workspace.
         * @summary List transaction history
         * @param {string} [before] Unix timestamp in milliseconds. Returns only transactions created before the specified date
         * @param {string} [after] Unix timestamp in milliseconds. Returns only transactions created after the specified date
         * @param {string} [status] You can filter by one of the statuses.
         * @param {'createdAt' | 'lastUpdated'} [orderBy] The field to order the results by
         * @param {'ASC' | 'DESC'} [sort] The direction to order the results by
         * @param {number} [limit] Limits the number of results. If not provided, a limit of 200 will be used. The maximum allowed limit is 500
         * @param {'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'UNKNOWN' | 'GAS_STATION' | 'OEC_PARTNER' | 'END_USER_WALLET'} [sourceType] The source type of the transaction
         * @param {string} [sourceId] The source ID of the transaction
         * @param {'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'ONE_TIME_ADDRESS' | 'OEC_PARTNER' | 'END_USER_WALLET'} [destType] The destination type of the transaction
         * @param {string} [destId] The destination ID of the transaction
         * @param {string} [assets] A list of assets to filter by, seperated by commas
         * @param {string} [txHash] Returns only results with a specified txHash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactions(before?: string, after?: string, status?: string, orderBy?: 'createdAt' | 'lastUpdated', sort?: 'ASC' | 'DESC', limit?: number, sourceType?: 'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'UNKNOWN' | 'GAS_STATION' | 'OEC_PARTNER' | 'END_USER_WALLET', sourceId?: string, destType?: 'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'ONE_TIME_ADDRESS' | 'OEC_PARTNER' | 'END_USER_WALLET', destId?: string, assets?: string, txHash?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(before, after, status, orderBy, sort, limit, sourceType, sourceId, destType, destId, assets, txHash, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Overrides the required number of confirmations for transaction completion by transaction ID.
         * @summary Set confirmation threshold by transaction ID
         * @param {string} txId The ID of the transaction
         * @param {SetConfirmationsThresholdRequest} [setConfirmationsThresholdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setConfirmationThresholdForTransaction(txId: string, setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetConfirmationsThresholdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setConfirmationThresholdForTransaction(txId, setConfirmationsThresholdRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Overrides the required number of confirmations for transaction completion by transaction hash.
         * @summary Set confirmation threshold by transaction hash
         * @param {string} txHash The TxHash
         * @param {SetConfirmationsThresholdRequest} [setConfirmationsThresholdRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setConfirmationThresholdForTransactionByHash(txHash: string, setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetConfirmationsThresholdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setConfirmationThresholdForTransactionByHash(txHash, setConfirmationsThresholdRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Unfreezes a transaction by ID and makes the transaction available again.
         * @summary Unfreeze a transaction
         * @param {string} txId The ID of the transaction to unfreeze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfreezeTransaction(txId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnfreezeTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfreezeTransaction(txId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Checks if an address is valid (for XRP, DOT, XLM, and EOS).
         * @summary Validate destination address
         * @param {string} assetId The asset of the address
         * @param {string} address The address to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateAddress(assetId: string, address: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateAddress(assetId, address, );
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for cancelTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiCancelTransactionRequest
 */
export interface TransactionsApiCancelTransactionRequest {
    /**
     * The ID of the transaction to cancel
     * @type {string}
     * @memberof TransactionsApiCancelTransaction
     */
    readonly txId: string
}

/**
 * Request parameters for createTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiCreateTransactionRequest
 */
export interface TransactionsApiCreateTransactionRequest {
    /**
     * 
     * @type {TransactionRequest}
     * @memberof TransactionsApiCreateTransaction
     */
    readonly transactionRequest?: TransactionRequest
}

/**
 * Request parameters for dropTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiDropTransactionRequest
 */
export interface TransactionsApiDropTransactionRequest {
    /**
     * The ID of the transaction
     * @type {string}
     * @memberof TransactionsApiDropTransaction
     */
    readonly txId: string

    /**
     * 
     * @type {DropTransactionRequest}
     * @memberof TransactionsApiDropTransaction
     */
    readonly dropTransactionRequest?: DropTransactionRequest
}

/**
 * Request parameters for estimateNetworkFee operation in TransactionsApi.
 * @export
 * @interface TransactionsApiEstimateNetworkFeeRequest
 */
export interface TransactionsApiEstimateNetworkFeeRequest {
    /**
     * The asset for which to estimate the fee
     * @type {string}
     * @memberof TransactionsApiEstimateNetworkFee
     */
    readonly assetId: string
}

/**
 * Request parameters for estimateTransactionFee operation in TransactionsApi.
 * @export
 * @interface TransactionsApiEstimateTransactionFeeRequest
 */
export interface TransactionsApiEstimateTransactionFeeRequest {
    /**
     * 
     * @type {TransactionRequest}
     * @memberof TransactionsApiEstimateTransactionFee
     */
    readonly transactionRequest?: TransactionRequest
}

/**
 * Request parameters for freezeTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiFreezeTransactionRequest
 */
export interface TransactionsApiFreezeTransactionRequest {
    /**
     * The ID of the transaction to freeze
     * @type {string}
     * @memberof TransactionsApiFreezeTransaction
     */
    readonly txId: string
}

/**
 * Request parameters for getTransactionByExternalId operation in TransactionsApi.
 * @export
 * @interface TransactionsApiGetTransactionByExternalIdRequest
 */
export interface TransactionsApiGetTransactionByExternalIdRequest {
    /**
     * The external ID of the transaction to return
     * @type {string}
     * @memberof TransactionsApiGetTransactionByExternalId
     */
    readonly externalTxId: string
}

/**
 * Request parameters for getTransactionById operation in TransactionsApi.
 * @export
 * @interface TransactionsApiGetTransactionByIdRequest
 */
export interface TransactionsApiGetTransactionByIdRequest {
    /**
     * The ID of the transaction to return
     * @type {string}
     * @memberof TransactionsApiGetTransactionById
     */
    readonly txId: string
}

/**
 * Request parameters for getTransactions operation in TransactionsApi.
 * @export
 * @interface TransactionsApiGetTransactionsRequest
 */
export interface TransactionsApiGetTransactionsRequest {
    /**
     * Unix timestamp in milliseconds. Returns only transactions created before the specified date
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly before?: string

    /**
     * Unix timestamp in milliseconds. Returns only transactions created after the specified date
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly after?: string

    /**
     * You can filter by one of the statuses.
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly status?: string

    /**
     * The field to order the results by
     * @type {'createdAt' | 'lastUpdated'}
     * @memberof TransactionsApiGetTransactions
     */
    readonly orderBy?: 'createdAt' | 'lastUpdated'

    /**
     * The direction to order the results by
     * @type {'ASC' | 'DESC'}
     * @memberof TransactionsApiGetTransactions
     */
    readonly sort?: 'ASC' | 'DESC'

    /**
     * Limits the number of results. If not provided, a limit of 200 will be used. The maximum allowed limit is 500
     * @type {number}
     * @memberof TransactionsApiGetTransactions
     */
    readonly limit?: number

    /**
     * The source type of the transaction
     * @type {'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'UNKNOWN' | 'GAS_STATION' | 'OEC_PARTNER' | 'END_USER_WALLET'}
     * @memberof TransactionsApiGetTransactions
     */
    readonly sourceType?: 'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'UNKNOWN' | 'GAS_STATION' | 'OEC_PARTNER' | 'END_USER_WALLET'

    /**
     * The source ID of the transaction
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly sourceId?: string

    /**
     * The destination type of the transaction
     * @type {'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'ONE_TIME_ADDRESS' | 'OEC_PARTNER' | 'END_USER_WALLET'}
     * @memberof TransactionsApiGetTransactions
     */
    readonly destType?: 'VAULT_ACCOUNT' | 'EXCHANGE_ACCOUNT' | 'INTERNAL_WALLET' | 'EXTERNAL_WALLET' | 'FIAT_ACCOUNT' | 'NETWORK_CONNECTION' | 'COMPOUND' | 'ONE_TIME_ADDRESS' | 'OEC_PARTNER' | 'END_USER_WALLET'

    /**
     * The destination ID of the transaction
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly destId?: string

    /**
     * A list of assets to filter by, seperated by commas
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly assets?: string

    /**
     * Returns only results with a specified txHash
     * @type {string}
     * @memberof TransactionsApiGetTransactions
     */
    readonly txHash?: string
}

/**
 * Request parameters for setConfirmationThresholdForTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiSetConfirmationThresholdForTransactionRequest
 */
export interface TransactionsApiSetConfirmationThresholdForTransactionRequest {
    /**
     * The ID of the transaction
     * @type {string}
     * @memberof TransactionsApiSetConfirmationThresholdForTransaction
     */
    readonly txId: string

    /**
     * 
     * @type {SetConfirmationsThresholdRequest}
     * @memberof TransactionsApiSetConfirmationThresholdForTransaction
     */
    readonly setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest
}

/**
 * Request parameters for setConfirmationThresholdForTransactionByHash operation in TransactionsApi.
 * @export
 * @interface TransactionsApiSetConfirmationThresholdForTransactionByHashRequest
 */
export interface TransactionsApiSetConfirmationThresholdForTransactionByHashRequest {
    /**
     * The TxHash
     * @type {string}
     * @memberof TransactionsApiSetConfirmationThresholdForTransactionByHash
     */
    readonly txHash: string

    /**
     * 
     * @type {SetConfirmationsThresholdRequest}
     * @memberof TransactionsApiSetConfirmationThresholdForTransactionByHash
     */
    readonly setConfirmationsThresholdRequest?: SetConfirmationsThresholdRequest
}

/**
 * Request parameters for unfreezeTransaction operation in TransactionsApi.
 * @export
 * @interface TransactionsApiUnfreezeTransactionRequest
 */
export interface TransactionsApiUnfreezeTransactionRequest {
    /**
     * The ID of the transaction to unfreeze
     * @type {string}
     * @memberof TransactionsApiUnfreezeTransaction
     */
    readonly txId: string
}

/**
 * Request parameters for validateAddress operation in TransactionsApi.
 * @export
 * @interface TransactionsApiValidateAddressRequest
 */
export interface TransactionsApiValidateAddressRequest {
    /**
     * The asset of the address
     * @type {string}
     * @memberof TransactionsApiValidateAddress
     */
    readonly assetId: string

    /**
     * The address to validate
     * @type {string}
     * @memberof TransactionsApiValidateAddress
     */
    readonly address: string
}

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Cancels a transaction by ID.
     * @summary Cancel a transaction
     * @param {TransactionsApiCancelTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public cancelTransaction(requestParameters: TransactionsApiCancelTransactionRequest, ) {
        return TransactionsApiFp(this.httpClient).cancelTransaction(requestParameters.txId, );
    }

    /**
     * Creates a new transaction.
     * @summary Create a new transaction
     * @param {TransactionsApiCreateTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createTransaction(requestParameters: TransactionsApiCreateTransactionRequest = {}, ) {
        return TransactionsApiFp(this.httpClient).createTransaction(requestParameters.transactionRequest, );
    }

    /**
     * Drops a stuck ETH transaction and creates a replacement transaction.
     * @summary Drop ETH transaction by ID
     * @param {TransactionsApiDropTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public dropTransaction(requestParameters: TransactionsApiDropTransactionRequest, ) {
        return TransactionsApiFp(this.httpClient).dropTransaction(requestParameters.txId, requestParameters.dropTransactionRequest, );
    }

    /**
     * Gets the estimated required fee for an asset. For UTXO based assets, the response will contain the suggested fee per byte, for ETH/ETC based assets, the suggested gas price, and for XRP/XLM, the transaction fee.
     * @summary Estimate the required fee for an asset
     * @param {TransactionsApiEstimateNetworkFeeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public estimateNetworkFee(requestParameters: TransactionsApiEstimateNetworkFeeRequest, ) {
        return TransactionsApiFp(this.httpClient).estimateNetworkFee(requestParameters.assetId, );
    }

    /**
     * Estimates the transaction fee for a transaction request. * Note: Supports all Fireblocks assets except ZCash (ZEC).
     * @summary Estimate transaction fee
     * @param {TransactionsApiEstimateTransactionFeeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public estimateTransactionFee(requestParameters: TransactionsApiEstimateTransactionFeeRequest = {}, ) {
        return TransactionsApiFp(this.httpClient).estimateTransactionFee(requestParameters.transactionRequest, );
    }

    /**
     * Freezes a transaction by ID.
     * @summary Freeze a transaction
     * @param {TransactionsApiFreezeTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public freezeTransaction(requestParameters: TransactionsApiFreezeTransactionRequest, ) {
        return TransactionsApiFp(this.httpClient).freezeTransaction(requestParameters.txId, );
    }

    /**
     * Returns transaction by external transaction ID.
     * @summary Find a specific transaction by external transaction ID
     * @param {TransactionsApiGetTransactionByExternalIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionByExternalId(requestParameters: TransactionsApiGetTransactionByExternalIdRequest, ) {
        return TransactionsApiFp(this.httpClient).getTransactionByExternalId(requestParameters.externalTxId, );
    }

    /**
     * Returns a transaction by ID.
     * @summary Find a specific transaction by Fireblocks transaction ID
     * @param {TransactionsApiGetTransactionByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionById(requestParameters: TransactionsApiGetTransactionByIdRequest, ) {
        return TransactionsApiFp(this.httpClient).getTransactionById(requestParameters.txId, );
    }

    /**
     * Lists the transaction history for your workspace.
     * @summary List transaction history
     * @param {TransactionsApiGetTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactions(requestParameters: TransactionsApiGetTransactionsRequest = {}, ) {
        return TransactionsApiFp(this.httpClient).getTransactions(requestParameters.before, requestParameters.after, requestParameters.status, requestParameters.orderBy, requestParameters.sort, requestParameters.limit, requestParameters.sourceType, requestParameters.sourceId, requestParameters.destType, requestParameters.destId, requestParameters.assets, requestParameters.txHash, );
    }

    /**
     * Overrides the required number of confirmations for transaction completion by transaction ID.
     * @summary Set confirmation threshold by transaction ID
     * @param {TransactionsApiSetConfirmationThresholdForTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public setConfirmationThresholdForTransaction(requestParameters: TransactionsApiSetConfirmationThresholdForTransactionRequest, ) {
        return TransactionsApiFp(this.httpClient).setConfirmationThresholdForTransaction(requestParameters.txId, requestParameters.setConfirmationsThresholdRequest, );
    }

    /**
     * Overrides the required number of confirmations for transaction completion by transaction hash.
     * @summary Set confirmation threshold by transaction hash
     * @param {TransactionsApiSetConfirmationThresholdForTransactionByHashRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public setConfirmationThresholdForTransactionByHash(requestParameters: TransactionsApiSetConfirmationThresholdForTransactionByHashRequest, ) {
        return TransactionsApiFp(this.httpClient).setConfirmationThresholdForTransactionByHash(requestParameters.txHash, requestParameters.setConfirmationsThresholdRequest, );
    }

    /**
     * Unfreezes a transaction by ID and makes the transaction available again.
     * @summary Unfreeze a transaction
     * @param {TransactionsApiUnfreezeTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public unfreezeTransaction(requestParameters: TransactionsApiUnfreezeTransactionRequest, ) {
        return TransactionsApiFp(this.httpClient).unfreezeTransaction(requestParameters.txId, );
    }

    /**
     * Checks if an address is valid (for XRP, DOT, XLM, and EOS).
     * @summary Validate destination address
     * @param {TransactionsApiValidateAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public validateAddress(requestParameters: TransactionsApiValidateAddressRequest, ) {
        return TransactionsApiFp(this.httpClient).validateAddress(requestParameters.assetId, requestParameters.address, );
    }
}





    /**
 * TravelRuleBetaApi - axios parameter creator
 * @export
 */
export const TravelRuleBetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get VASP Details.  Returns information about a VASP that has the specified DID.  **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren\'t yet generally available.  To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
         * @summary Get VASP details
         * @param {string} did 
         * @param {string} [fields] CSV of fields to return (all, \&quot;blank\&quot; or see list of all field names below)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVASPByDID: async (did: string, fields?: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'did' is not null or undefined
            assertParamExists('getVASPByDID', 'did', did)
            const localVarPath = `/screening/travel_rule/vasp/{did}`
                .replace(`{${"did"}}`, encodeURIComponent(String(did)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Get All VASPs.  Returns a list of VASPs. VASPs can be searched and sorted and results are paginated.  **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren\'t yet generally available.  To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
         * @summary Get All VASPs
         * @param {string} [order] Field to order by
         * @param {number} [perPage] Records per page
         * @param {number} [page] Page number
         * @param {string} [fields] CSV of fields to return (all, \&quot;blank\&quot; or see list of all field names below)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVASPs: async (order?: string, perPage?: number, page?: number, fields?: string, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/screening/travel_rule/vasp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Update VASP Details.  Updates a VASP with the provided parameters. Use this endpoint to add your public jsonDIDkey generated by Notabene.  **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren\'t yet generally available.  To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
         * @summary Add jsonDidKey to VASP details
         * @param {TravelRuleUpdateVASPDetails} travelRuleUpdateVASPDetails 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        travelRuleApiControllerUpdateVasp: async (travelRuleUpdateVASPDetails: TravelRuleUpdateVASPDetails, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'travelRuleUpdateVASPDetails' is not null or undefined
            assertParamExists('travelRuleApiControllerUpdateVasp', 'travelRuleUpdateVASPDetails', travelRuleUpdateVASPDetails)
            const localVarPath = `/screeening/travel_rule/vasp/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'PUT'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = travelRuleUpdateVASPDetails as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Validate Full Travel Rule transactions.  Checks for all required information on the originator and beneficiary VASPs.  **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren\'t yet generally available.  To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
         * @summary Validate Full Travel Rule Transaction
         * @param {TravelRuleValidateFullTransactionRequest} travelRuleValidateFullTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateFullTravelRuleTransaction: async (travelRuleValidateFullTransactionRequest: TravelRuleValidateFullTransactionRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'travelRuleValidateFullTransactionRequest' is not null or undefined
            assertParamExists('validateFullTravelRuleTransaction', 'travelRuleValidateFullTransactionRequest', travelRuleValidateFullTransactionRequest)
            const localVarPath = `/screening/travel_rule/transaction/validate/full`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = travelRuleValidateFullTransactionRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Validate Travel Rule transactions.  Checks what beneficiary VASP details are required by your jurisdiction and the beneficiary\'s jurisdiction.  **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren\'t yet generally available.  To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
         * @summary Validate Travel Rule Transaction
         * @param {TravelRuleValidateTransactionRequest} travelRuleValidateTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateTravelRuleTransaction: async (travelRuleValidateTransactionRequest: TravelRuleValidateTransactionRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'travelRuleValidateTransactionRequest' is not null or undefined
            assertParamExists('validateTravelRuleTransaction', 'travelRuleValidateTransactionRequest', travelRuleValidateTransactionRequest)
            const localVarPath = `/screening/travel_rule/transaction/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = travelRuleValidateTransactionRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * TravelRuleBetaApi - functional programming interface
 * @export
 */
export const TravelRuleBetaApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = TravelRuleBetaApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * Get VASP Details.  Returns information about a VASP that has the specified DID.  **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren\'t yet generally available.  To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
         * @summary Get VASP details
         * @param {string} did 
         * @param {string} [fields] CSV of fields to return (all, \&quot;blank\&quot; or see list of all field names below)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVASPByDID(did: string, fields?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TravelRuleVASP>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVASPByDID(did, fields, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Get All VASPs.  Returns a list of VASPs. VASPs can be searched and sorted and results are paginated.  **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren\'t yet generally available.  To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
         * @summary Get All VASPs
         * @param {string} [order] Field to order by
         * @param {number} [perPage] Records per page
         * @param {number} [page] Page number
         * @param {string} [fields] CSV of fields to return (all, \&quot;blank\&quot; or see list of all field names below)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVASPs(order?: string, perPage?: number, page?: number, fields?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TravelRuleGetAllVASPsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVASPs(order, perPage, page, fields, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Update VASP Details.  Updates a VASP with the provided parameters. Use this endpoint to add your public jsonDIDkey generated by Notabene.  **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren\'t yet generally available.  To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
         * @summary Add jsonDidKey to VASP details
         * @param {TravelRuleUpdateVASPDetails} travelRuleUpdateVASPDetails 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async travelRuleApiControllerUpdateVasp(travelRuleUpdateVASPDetails: TravelRuleUpdateVASPDetails, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TravelRuleUpdateVASPDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.travelRuleApiControllerUpdateVasp(travelRuleUpdateVASPDetails, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Validate Full Travel Rule transactions.  Checks for all required information on the originator and beneficiary VASPs.  **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren\'t yet generally available.  To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
         * @summary Validate Full Travel Rule Transaction
         * @param {TravelRuleValidateFullTransactionRequest} travelRuleValidateFullTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateFullTravelRuleTransaction(travelRuleValidateFullTransactionRequest: TravelRuleValidateFullTransactionRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TravelRuleValidateTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateFullTravelRuleTransaction(travelRuleValidateFullTransactionRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Validate Travel Rule transactions.  Checks what beneficiary VASP details are required by your jurisdiction and the beneficiary\'s jurisdiction.  **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren\'t yet generally available.  To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
         * @summary Validate Travel Rule Transaction
         * @param {TravelRuleValidateTransactionRequest} travelRuleValidateTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateTravelRuleTransaction(travelRuleValidateTransactionRequest: TravelRuleValidateTransactionRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TravelRuleValidateTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateTravelRuleTransaction(travelRuleValidateTransactionRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for getVASPByDID operation in TravelRuleBetaApi.
 * @export
 * @interface TravelRuleBetaApiGetVASPByDIDRequest
 */
export interface TravelRuleBetaApiGetVASPByDIDRequest {
    /**
     * 
     * @type {string}
     * @memberof TravelRuleBetaApiGetVASPByDID
     */
    readonly did: string

    /**
     * CSV of fields to return (all, \&quot;blank\&quot; or see list of all field names below)
     * @type {string}
     * @memberof TravelRuleBetaApiGetVASPByDID
     */
    readonly fields?: string
}

/**
 * Request parameters for getVASPs operation in TravelRuleBetaApi.
 * @export
 * @interface TravelRuleBetaApiGetVASPsRequest
 */
export interface TravelRuleBetaApiGetVASPsRequest {
    /**
     * Field to order by
     * @type {string}
     * @memberof TravelRuleBetaApiGetVASPs
     */
    readonly order?: string

    /**
     * Records per page
     * @type {number}
     * @memberof TravelRuleBetaApiGetVASPs
     */
    readonly perPage?: number

    /**
     * Page number
     * @type {number}
     * @memberof TravelRuleBetaApiGetVASPs
     */
    readonly page?: number

    /**
     * CSV of fields to return (all, \&quot;blank\&quot; or see list of all field names below)
     * @type {string}
     * @memberof TravelRuleBetaApiGetVASPs
     */
    readonly fields?: string
}

/**
 * Request parameters for travelRuleApiControllerUpdateVasp operation in TravelRuleBetaApi.
 * @export
 * @interface TravelRuleBetaApiTravelRuleApiControllerUpdateVaspRequest
 */
export interface TravelRuleBetaApiTravelRuleApiControllerUpdateVaspRequest {
    /**
     * 
     * @type {TravelRuleUpdateVASPDetails}
     * @memberof TravelRuleBetaApiTravelRuleApiControllerUpdateVasp
     */
    readonly travelRuleUpdateVASPDetails: TravelRuleUpdateVASPDetails
}

/**
 * Request parameters for validateFullTravelRuleTransaction operation in TravelRuleBetaApi.
 * @export
 * @interface TravelRuleBetaApiValidateFullTravelRuleTransactionRequest
 */
export interface TravelRuleBetaApiValidateFullTravelRuleTransactionRequest {
    /**
     * 
     * @type {TravelRuleValidateFullTransactionRequest}
     * @memberof TravelRuleBetaApiValidateFullTravelRuleTransaction
     */
    readonly travelRuleValidateFullTransactionRequest: TravelRuleValidateFullTransactionRequest
}

/**
 * Request parameters for validateTravelRuleTransaction operation in TravelRuleBetaApi.
 * @export
 * @interface TravelRuleBetaApiValidateTravelRuleTransactionRequest
 */
export interface TravelRuleBetaApiValidateTravelRuleTransactionRequest {
    /**
     * 
     * @type {TravelRuleValidateTransactionRequest}
     * @memberof TravelRuleBetaApiValidateTravelRuleTransaction
     */
    readonly travelRuleValidateTransactionRequest: TravelRuleValidateTransactionRequest
}

/**
 * TravelRuleBetaApi - object-oriented interface
 * @export
 * @class TravelRuleBetaApi
 * @extends {BaseAPI}
 */
export class TravelRuleBetaApi extends BaseAPI {
    /**
     * Get VASP Details.  Returns information about a VASP that has the specified DID.  **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren\'t yet generally available.  To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
     * @summary Get VASP details
     * @param {TravelRuleBetaApiGetVASPByDIDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelRuleBetaApi
     */
    public getVASPByDID(requestParameters: TravelRuleBetaApiGetVASPByDIDRequest, ) {
        return TravelRuleBetaApiFp(this.httpClient).getVASPByDID(requestParameters.did, requestParameters.fields, );
    }

    /**
     * Get All VASPs.  Returns a list of VASPs. VASPs can be searched and sorted and results are paginated.  **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren\'t yet generally available.  To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
     * @summary Get All VASPs
     * @param {TravelRuleBetaApiGetVASPsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelRuleBetaApi
     */
    public getVASPs(requestParameters: TravelRuleBetaApiGetVASPsRequest = {}, ) {
        return TravelRuleBetaApiFp(this.httpClient).getVASPs(requestParameters.order, requestParameters.perPage, requestParameters.page, requestParameters.fields, );
    }

    /**
     * Update VASP Details.  Updates a VASP with the provided parameters. Use this endpoint to add your public jsonDIDkey generated by Notabene.  **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren\'t yet generally available.  To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
     * @summary Add jsonDidKey to VASP details
     * @param {TravelRuleBetaApiTravelRuleApiControllerUpdateVaspRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelRuleBetaApi
     */
    public travelRuleApiControllerUpdateVasp(requestParameters: TravelRuleBetaApiTravelRuleApiControllerUpdateVaspRequest, ) {
        return TravelRuleBetaApiFp(this.httpClient).travelRuleApiControllerUpdateVasp(requestParameters.travelRuleUpdateVASPDetails, );
    }

    /**
     * Validate Full Travel Rule transactions.  Checks for all required information on the originator and beneficiary VASPs.  **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren\'t yet generally available.  To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
     * @summary Validate Full Travel Rule Transaction
     * @param {TravelRuleBetaApiValidateFullTravelRuleTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelRuleBetaApi
     */
    public validateFullTravelRuleTransaction(requestParameters: TravelRuleBetaApiValidateFullTravelRuleTransactionRequest, ) {
        return TravelRuleBetaApiFp(this.httpClient).validateFullTravelRuleTransaction(requestParameters.travelRuleValidateFullTransactionRequest, );
    }

    /**
     * Validate Travel Rule transactions.  Checks what beneficiary VASP details are required by your jurisdiction and the beneficiary\'s jurisdiction.  **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren\'t yet generally available.  To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
     * @summary Validate Travel Rule Transaction
     * @param {TravelRuleBetaApiValidateTravelRuleTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelRuleBetaApi
     */
    public validateTravelRuleTransaction(requestParameters: TravelRuleBetaApiValidateTravelRuleTransactionRequest, ) {
        return TravelRuleBetaApiFp(this.httpClient).validateTravelRuleTransaction(requestParameters.travelRuleValidateTransactionRequest, );
    }
}





    /**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all users for the workspace.  Please note that this endpoint is available only for API keys with Admin permissions. 
         * @summary List users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (): Promise<AxiosRequestConfig> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * List all users for the workspace.  Please note that this endpoint is available only for API keys with Admin permissions. 
         * @summary List users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers();
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * List all users for the workspace.  Please note that this endpoint is available only for API keys with Admin permissions. 
     * @summary List users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers() {
        return UsersApiFp(this.httpClient).getUsers();
    }
}





    /**
 * VaultsApi - axios parameter creator
 * @export
 */
export const VaultsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiates activation for a wallet in a vault account.
         * @summary Activate a wallet in a vault account
         * @param {string} vaultAccountId The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAssetForVaultAccount: async (vaultAccountId: string, assetId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('activateAssetForVaultAccount', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('activateAssetForVaultAccount', 'assetId', assetId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/activate`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Converts an existing segwit address to the legacy format.
         * @summary Convert a segwit address to legacy format
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The segwit address to translate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLegacyAddressForVaultAccountAsset: async (vaultAccountId: string, assetId: string, addressId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('createLegacyAddressForVaultAccountAsset', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('createLegacyAddressForVaultAccountAsset', 'assetId', assetId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('createLegacyAddressForVaultAccountAsset', 'addressId', addressId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/create_legacy`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Creates a new vault account with the requested name.
         * @summary Create a new vault account
         * @param {CreateVaultAccountRequest} createVaultAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccount: async (createVaultAccountRequest: CreateVaultAccountRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'createVaultAccountRequest' is not null or undefined
            assertParamExists('createVaultAccount', 'createVaultAccountRequest', createVaultAccountRequest)
            const localVarPath = `/vault/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = createVaultAccountRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Creates a wallet for a specific asset in a vault account.
         * @summary Create a new wallet
         * @param {string} vaultAccountId The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {CreateVaultAccountAssetRequest} [createVaultAccountAssetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccountAsset: async (vaultAccountId: string, assetId: string, createVaultAccountAssetRequest?: CreateVaultAccountAssetRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('createVaultAccountAsset', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('createVaultAccountAsset', 'assetId', assetId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = createVaultAccountAssetRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Creates a new deposit address for an asset of a vault account.
         * @summary Create new asset deposit address
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {CreateVaultAccountAssetAddressRequest} [createVaultAccountAssetAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccountAssetAddress: async (vaultAccountId: string, assetId: string, createVaultAccountAssetAddressRequest?: CreateVaultAccountAssetAddressRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('createVaultAccountAssetAddress', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('createVaultAccountAssetAddress', 'assetId', assetId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/addresses`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = createVaultAccountAssetAddressRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Gets all asset wallets at all of the vault accounts in your workspace. An asset wallet is an asset at a vault account. This method allows fast traversal of all account balances. **Note:**   - This API endpoint is in limited availability and available for selected customers. If you would like to get early access to this endpoint, please reach out to [Fireblocks Support](https://support.fireblocks.io/hc/en-us/requests/new?ticket_form_id=36000337220)   - This API call is subject to [rate limits](https://developers.fireblocks.com/reference/rate-limiting). 
         * @summary List asset wallets (Paginated)
         * @param {number} [totalAmountLargerThan] When specified, only asset wallets with total balance larger than this amount are returned.
         * @param {string} [assetId] When specified, only asset wallets cross vault accounts that have this asset ID are returned.
         * @param {string} [before] Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page.
         * @param {string} [after] Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page.
         * @param {number} [limit] The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetWallets: async (totalAmountLargerThan?: number, assetId?: string, before?: string, after?: string, limit?: number, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/vault/asset_wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (totalAmountLargerThan !== undefined) {
                localVarQueryParameter['totalAmountLargerThan'] = totalAmountLargerThan;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['assetId'] = assetId;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.
         * @summary Get the maximum spendable amount in a single transaction.
         * @param {string} vaultAccountId The ID of the vault account, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {boolean} [manualSignging] False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxSpendableAmount: async (vaultAccountId: string, assetId: string, manualSignging?: boolean, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('getMaxSpendableAmount', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getMaxSpendableAmount', 'assetId', assetId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/max_spendable_amount`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (manualSignging !== undefined) {
                localVarQueryParameter['manualSignging'] = manualSignging;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.
         * @summary List vault acounts (Paginated)
         * @param {string} [namePrefix] 
         * @param {string} [nameSuffix] 
         * @param {number} [minAmountThreshold] 
         * @param {string} [assetId] 
         * @param {number} [maxBip44AddressIndexUsed] 
         * @param {number} [maxBip44ChangeAddressIndexUsed] 
         * @param {'ASC' | 'DESC'} [orderBy] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPagedVaultAccounts: async (namePrefix?: string, nameSuffix?: string, minAmountThreshold?: number, assetId?: string, maxBip44AddressIndexUsed?: number, maxBip44ChangeAddressIndexUsed?: number, orderBy?: 'ASC' | 'DESC', before?: string, after?: string, limit?: number, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/vault/accounts_paged`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namePrefix !== undefined) {
                localVarQueryParameter['namePrefix'] = namePrefix;
            }

            if (nameSuffix !== undefined) {
                localVarQueryParameter['nameSuffix'] = nameSuffix;
            }

            if (minAmountThreshold !== undefined) {
                localVarQueryParameter['minAmountThreshold'] = minAmountThreshold;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['assetId'] = assetId;
            }

            if (maxBip44AddressIndexUsed !== undefined) {
                localVarQueryParameter['maxBip44AddressIndexUsed'] = maxBip44AddressIndexUsed;
            }

            if (maxBip44ChangeAddressIndexUsed !== undefined) {
                localVarQueryParameter['maxBip44ChangeAddressIndexUsed'] = maxBip44ChangeAddressIndexUsed;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Gets the public key information based on derivation path and signing algorithm.
         * @summary Get the public key information
         * @param {string} derivationPath 
         * @param {string} algorithm 
         * @param {boolean} [compressed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyInfo: async (derivationPath: string, algorithm: string, compressed?: boolean, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'derivationPath' is not null or undefined
            assertParamExists('getPublicKeyInfo', 'derivationPath', derivationPath)
            // verify required parameter 'algorithm' is not null or undefined
            assertParamExists('getPublicKeyInfo', 'algorithm', algorithm)
            const localVarPath = `/vault/public_key_info/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (derivationPath !== undefined) {
                localVarQueryParameter['derivationPath'] = derivationPath;
            }

            if (algorithm !== undefined) {
                localVarQueryParameter['algorithm'] = algorithm;
            }

            if (compressed !== undefined) {
                localVarQueryParameter['compressed'] = compressed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Gets the public key information for the vault account.
         * @summary Get the public key for a vault account
         * @param {string} vaultAccountId 
         * @param {string} assetId 
         * @param {number} change 
         * @param {number} addressIndex 
         * @param {boolean} [compressed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyInfoForAddress: async (vaultAccountId: string, assetId: string, change: number, addressIndex: number, compressed?: boolean, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('getPublicKeyInfoForAddress', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getPublicKeyInfoForAddress', 'assetId', assetId)
            // verify required parameter 'change' is not null or undefined
            assertParamExists('getPublicKeyInfoForAddress', 'change', change)
            // verify required parameter 'addressIndex' is not null or undefined
            assertParamExists('getPublicKeyInfoForAddress', 'addressIndex', addressIndex)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/{change}/{addressIndex}/public_key_info`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"change"}}`, encodeURIComponent(String(change)))
                .replace(`{${"addressIndex"}}`, encodeURIComponent(String(addressIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (compressed !== undefined) {
                localVarQueryParameter['compressed'] = compressed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns a wallet for a specific asset of a vault account.
         * @summary Get the asset balance for a vault account
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccountAsset: async (vaultAccountId: string, assetId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('getVaultAccountAsset', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getVaultAccountAsset', 'assetId', assetId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Lists all addresses for specific asset of vault account.
         * @summary Get asset addresses
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccountAssetAddresses: async (vaultAccountId: string, assetId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('getVaultAccountAssetAddresses', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getVaultAccountAssetAddresses', 'assetId', assetId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/addresses`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns unspent inputs information of an asset in a vault account.
         * @summary Get UTXO unspent inputs information
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccountAssetUnspentInputs: async (vaultAccountId: string, assetId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('getVaultAccountAssetUnspentInputs', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getVaultAccountAssetUnspentInputs', 'assetId', assetId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/unspent_inputs`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Returns the requested vault account.
         * @summary Find a vault account by ID
         * @param {string} vaultAccountId The ID of the vault account to return type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccountById: async (vaultAccountId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('getVaultAccountById', 'vaultAccountId', vaultAccountId)
            const localVarPath = `/vault/accounts/{vaultAccountId}`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Gets all vault accounts in your workspace.
         * @summary List vault accounts
         * @param {string} [namePrefix] 
         * @param {string} [nameSuffix] 
         * @param {number} [minAmountThreshold] 
         * @param {string} [assetId] 
         * @param {number} [maxBip44AddressIndexUsed] 
         * @param {number} [maxBip44ChangeAddressIndexUsed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccounts: async (namePrefix?: string, nameSuffix?: string, minAmountThreshold?: number, assetId?: string, maxBip44AddressIndexUsed?: number, maxBip44ChangeAddressIndexUsed?: number, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/vault/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namePrefix !== undefined) {
                localVarQueryParameter['namePrefix'] = namePrefix;
            }

            if (nameSuffix !== undefined) {
                localVarQueryParameter['nameSuffix'] = nameSuffix;
            }

            if (minAmountThreshold !== undefined) {
                localVarQueryParameter['minAmountThreshold'] = minAmountThreshold;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['assetId'] = assetId;
            }

            if (maxBip44AddressIndexUsed !== undefined) {
                localVarQueryParameter['maxBip44AddressIndexUsed'] = maxBip44AddressIndexUsed;
            }

            if (maxBip44ChangeAddressIndexUsed !== undefined) {
                localVarQueryParameter['maxBip44ChangeAddressIndexUsed'] = maxBip44ChangeAddressIndexUsed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Gets the vault balance summary for an asset.
         * @summary Get vault balance by asset
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAssetById: async (assetId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getVaultAssetById', 'assetId', assetId)
            const localVarPath = `/vault/assets/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Gets the assets amount summary for all accounts or filtered accounts.
         * @summary Get asset balance for chosen assets
         * @param {string} [accountNamePrefix] 
         * @param {string} [accountNameSuffix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAssets: async (accountNamePrefix?: string, accountNameSuffix?: string, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/vault/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountNamePrefix !== undefined) {
                localVarQueryParameter['accountNamePrefix'] = accountNamePrefix;
            }

            if (accountNameSuffix !== undefined) {
                localVarQueryParameter['accountNameSuffix'] = accountNameSuffix;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Hides the requested vault account from the web console view.
         * @summary Hide a vault account in the console
         * @param {string} vaultAccountId The vault account to hide
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideVaultAccount: async (vaultAccountId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('hideVaultAccount', 'vaultAccountId', vaultAccountId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/hide`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Sets the autofueling property of the vault account to enabled or disabled.
         * @summary Turn autofueling on or off
         * @param {string} vaultAccountId The vault account ID
         * @param {SetAutoFuelForVaultAccountRequest} setAutoFuelForVaultAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAutoFuelForVaultAccount: async (vaultAccountId: string, setAutoFuelForVaultAccountRequest: SetAutoFuelForVaultAccountRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('setAutoFuelForVaultAccount', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'setAutoFuelForVaultAccountRequest' is not null or undefined
            assertParamExists('setAutoFuelForVaultAccount', 'setAutoFuelForVaultAccountRequest', setAutoFuelForVaultAccountRequest)
            const localVarPath = `/vault/accounts/{vaultAccountId}/set_auto_fuel`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = setAutoFuelForVaultAccountRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Assigns an AML/KYT customer reference ID for the vault account.
         * @summary Set an AML/KYT customer reference ID for a vault account
         * @param {string} vaultAccountId The vault account ID
         * @param {SetCustomerRefIdForVaultAccountRequest} setCustomerRefIdForVaultAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomerRefIdForVaultAccount: async (vaultAccountId: string, setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('setCustomerRefIdForVaultAccount', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'setCustomerRefIdForVaultAccountRequest' is not null or undefined
            assertParamExists('setCustomerRefIdForVaultAccount', 'setCustomerRefIdForVaultAccountRequest', setCustomerRefIdForVaultAccountRequest)
            const localVarPath = `/vault/accounts/{vaultAccountId}/set_customer_ref_id`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = setCustomerRefIdForVaultAccountRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Sets an AML/KYT customer reference ID for a specific address.
         * @summary Assign AML customer reference ID
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
         * @param {SetCustomerRefIdForVaultAccountRequest} setCustomerRefIdForVaultAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomerRefIdForVaultAccountAssetAddress: async (vaultAccountId: string, assetId: string, addressId: string, setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('setCustomerRefIdForVaultAccountAssetAddress', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('setCustomerRefIdForVaultAccountAssetAddress', 'assetId', assetId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('setCustomerRefIdForVaultAccountAssetAddress', 'addressId', addressId)
            // verify required parameter 'setCustomerRefIdForVaultAccountRequest' is not null or undefined
            assertParamExists('setCustomerRefIdForVaultAccountAssetAddress', 'setCustomerRefIdForVaultAccountRequest', setCustomerRefIdForVaultAccountRequest)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/set_customer_ref_id`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = setCustomerRefIdForVaultAccountRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Makes a hidden vault account visible in web console view.
         * @summary Unhide a vault account in the console
         * @param {string} vaultAccountId The vault account to unhide
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unhideVaultAccount: async (vaultAccountId: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('unhideVaultAccount', 'vaultAccountId', vaultAccountId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/unhide`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Renames the requested vault account.
         * @summary Rename a vault account
         * @param {string} vaultAccountId The ID of the vault account to edit
         * @param {UpdateVaultAccountRequest} updateVaultAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccount: async (vaultAccountId: string, updateVaultAccountRequest: UpdateVaultAccountRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('updateVaultAccount', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'updateVaultAccountRequest' is not null or undefined
            assertParamExists('updateVaultAccount', 'updateVaultAccountRequest', updateVaultAccountRequest)
            const localVarPath = `/vault/accounts/{vaultAccountId}`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'PUT'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = updateVaultAccountRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Updates the description of an existing address of an asset in a vault account.
         * @summary Update address description
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
         * @param {UpdateVaultAccountAssetAddressRequest} [updateVaultAccountAssetAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccountAssetAddress: async (vaultAccountId: string, assetId: string, addressId: string, updateVaultAccountAssetAddressRequest?: UpdateVaultAccountAssetAddressRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('updateVaultAccountAssetAddress', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('updateVaultAccountAssetAddress', 'assetId', assetId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('updateVaultAccountAssetAddress', 'addressId', addressId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'PUT'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = updateVaultAccountAssetAddressRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Updates the balance of a specific asset in a vault account.
         * @summary Refresh asset balance data
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccountAssetBalance: async (vaultAccountId: string, assetId: string, body?: object, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'vaultAccountId' is not null or undefined
            assertParamExists('updateVaultAccountAssetBalance', 'vaultAccountId', vaultAccountId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('updateVaultAccountAssetBalance', 'assetId', assetId)
            const localVarPath = `/vault/accounts/{vaultAccountId}/{assetId}/balance`
                .replace(`{${"vaultAccountId"}}`, encodeURIComponent(String(vaultAccountId)))
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = body as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * VaultsApi - functional programming interface
 * @export
 */
export const VaultsApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = VaultsApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * Initiates activation for a wallet in a vault account.
         * @summary Activate a wallet in a vault account
         * @param {string} vaultAccountId The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateAssetForVaultAccount(vaultAccountId: string, assetId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVaultAssetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateAssetForVaultAccount(vaultAccountId, assetId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Converts an existing segwit address to the legacy format.
         * @summary Convert a segwit address to legacy format
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The segwit address to translate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLegacyAddressForVaultAccountAsset(vaultAccountId: string, assetId: string, addressId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLegacyAddressForVaultAccountAsset(vaultAccountId, assetId, addressId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Creates a new vault account with the requested name.
         * @summary Create a new vault account
         * @param {CreateVaultAccountRequest} createVaultAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVaultAccount(createVaultAccountRequest: CreateVaultAccountRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVaultAccount(createVaultAccountRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Creates a wallet for a specific asset in a vault account.
         * @summary Create a new wallet
         * @param {string} vaultAccountId The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {CreateVaultAccountAssetRequest} [createVaultAccountAssetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVaultAccountAsset(vaultAccountId: string, assetId: string, createVaultAccountAssetRequest?: CreateVaultAccountAssetRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVaultAssetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVaultAccountAsset(vaultAccountId, assetId, createVaultAccountAssetRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Creates a new deposit address for an asset of a vault account.
         * @summary Create new asset deposit address
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {CreateVaultAccountAssetAddressRequest} [createVaultAccountAssetAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVaultAccountAssetAddress(vaultAccountId: string, assetId: string, createVaultAccountAssetAddressRequest?: CreateVaultAccountAssetAddressRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVaultAccountAssetAddress(vaultAccountId, assetId, createVaultAccountAssetAddressRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Gets all asset wallets at all of the vault accounts in your workspace. An asset wallet is an asset at a vault account. This method allows fast traversal of all account balances. **Note:**   - This API endpoint is in limited availability and available for selected customers. If you would like to get early access to this endpoint, please reach out to [Fireblocks Support](https://support.fireblocks.io/hc/en-us/requests/new?ticket_form_id=36000337220)   - This API call is subject to [rate limits](https://developers.fireblocks.com/reference/rate-limiting). 
         * @summary List asset wallets (Paginated)
         * @param {number} [totalAmountLargerThan] When specified, only asset wallets with total balance larger than this amount are returned.
         * @param {string} [assetId] When specified, only asset wallets cross vault accounts that have this asset ID are returned.
         * @param {string} [before] Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page.
         * @param {string} [after] Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page.
         * @param {number} [limit] The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetWallets(totalAmountLargerThan?: number, assetId?: string, before?: string, after?: string, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAssetWalletResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetWallets(totalAmountLargerThan, assetId, before, after, limit, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.
         * @summary Get the maximum spendable amount in a single transaction.
         * @param {string} vaultAccountId The ID of the vault account, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {boolean} [manualSignging] False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaxSpendableAmount(vaultAccountId: string, assetId: string, manualSignging?: boolean, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaxSpendableAmount(vaultAccountId, assetId, manualSignging, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.
         * @summary List vault acounts (Paginated)
         * @param {string} [namePrefix] 
         * @param {string} [nameSuffix] 
         * @param {number} [minAmountThreshold] 
         * @param {string} [assetId] 
         * @param {number} [maxBip44AddressIndexUsed] 
         * @param {number} [maxBip44ChangeAddressIndexUsed] 
         * @param {'ASC' | 'DESC'} [orderBy] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPagedVaultAccounts(namePrefix?: string, nameSuffix?: string, minAmountThreshold?: number, assetId?: string, maxBip44AddressIndexUsed?: number, maxBip44ChangeAddressIndexUsed?: number, orderBy?: 'ASC' | 'DESC', before?: string, after?: string, limit?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultAccountsPagedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPagedVaultAccounts(namePrefix, nameSuffix, minAmountThreshold, assetId, maxBip44AddressIndexUsed, maxBip44ChangeAddressIndexUsed, orderBy, before, after, limit, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Gets the public key information based on derivation path and signing algorithm.
         * @summary Get the public key information
         * @param {string} derivationPath 
         * @param {string} algorithm 
         * @param {boolean} [compressed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeyInfo(derivationPath: string, algorithm: string, compressed?: boolean, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeyInfo(derivationPath, algorithm, compressed, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Gets the public key information for the vault account.
         * @summary Get the public key for a vault account
         * @param {string} vaultAccountId 
         * @param {string} assetId 
         * @param {number} change 
         * @param {number} addressIndex 
         * @param {boolean} [compressed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeyInfoForAddress(vaultAccountId: string, assetId: string, change: number, addressIndex: number, compressed?: boolean, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeyInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeyInfoForAddress(vaultAccountId, assetId, change, addressIndex, compressed, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns a wallet for a specific asset of a vault account.
         * @summary Get the asset balance for a vault account
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVaultAccountAsset(vaultAccountId: string, assetId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVaultAccountAsset(vaultAccountId, assetId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Lists all addresses for specific asset of vault account.
         * @summary Get asset addresses
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVaultAccountAssetAddresses(vaultAccountId: string, assetId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VaultWalletAddress>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVaultAccountAssetAddresses(vaultAccountId, assetId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns unspent inputs information of an asset in a vault account.
         * @summary Get UTXO unspent inputs information
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVaultAccountAssetUnspentInputs(vaultAccountId: string, assetId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UnspentInputsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVaultAccountAssetUnspentInputs(vaultAccountId, assetId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Returns the requested vault account.
         * @summary Find a vault account by ID
         * @param {string} vaultAccountId The ID of the vault account to return type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVaultAccountById(vaultAccountId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVaultAccountById(vaultAccountId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Gets all vault accounts in your workspace.
         * @summary List vault accounts
         * @param {string} [namePrefix] 
         * @param {string} [nameSuffix] 
         * @param {number} [minAmountThreshold] 
         * @param {string} [assetId] 
         * @param {number} [maxBip44AddressIndexUsed] 
         * @param {number} [maxBip44ChangeAddressIndexUsed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVaultAccounts(namePrefix?: string, nameSuffix?: string, minAmountThreshold?: number, assetId?: string, maxBip44AddressIndexUsed?: number, maxBip44ChangeAddressIndexUsed?: number, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VaultAccount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVaultAccounts(namePrefix, nameSuffix, minAmountThreshold, assetId, maxBip44AddressIndexUsed, maxBip44ChangeAddressIndexUsed, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Gets the vault balance summary for an asset.
         * @summary Get vault balance by asset
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVaultAssetById(assetId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVaultAssetById(assetId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Gets the assets amount summary for all accounts or filtered accounts.
         * @summary Get asset balance for chosen assets
         * @param {string} [accountNamePrefix] 
         * @param {string} [accountNameSuffix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVaultAssets(accountNamePrefix?: string, accountNameSuffix?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VaultAsset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVaultAssets(accountNamePrefix, accountNameSuffix, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Hides the requested vault account from the web console view.
         * @summary Hide a vault account in the console
         * @param {string} vaultAccountId The vault account to hide
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hideVaultAccount(vaultAccountId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hideVaultAccount(vaultAccountId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Sets the autofueling property of the vault account to enabled or disabled.
         * @summary Turn autofueling on or off
         * @param {string} vaultAccountId The vault account ID
         * @param {SetAutoFuelForVaultAccountRequest} setAutoFuelForVaultAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAutoFuelForVaultAccount(vaultAccountId: string, setAutoFuelForVaultAccountRequest: SetAutoFuelForVaultAccountRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAutoFuelForVaultAccount(vaultAccountId, setAutoFuelForVaultAccountRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Assigns an AML/KYT customer reference ID for the vault account.
         * @summary Set an AML/KYT customer reference ID for a vault account
         * @param {string} vaultAccountId The vault account ID
         * @param {SetCustomerRefIdForVaultAccountRequest} setCustomerRefIdForVaultAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCustomerRefIdForVaultAccount(vaultAccountId: string, setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCustomerRefIdForVaultAccount(vaultAccountId, setCustomerRefIdForVaultAccountRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Sets an AML/KYT customer reference ID for a specific address.
         * @summary Assign AML customer reference ID
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
         * @param {SetCustomerRefIdForVaultAccountRequest} setCustomerRefIdForVaultAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCustomerRefIdForVaultAccountAssetAddress(vaultAccountId: string, assetId: string, addressId: string, setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCustomerRefIdForVaultAccountAssetAddress(vaultAccountId, assetId, addressId, setCustomerRefIdForVaultAccountRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Makes a hidden vault account visible in web console view.
         * @summary Unhide a vault account in the console
         * @param {string} vaultAccountId The vault account to unhide
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unhideVaultAccount(vaultAccountId: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unhideVaultAccount(vaultAccountId, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Renames the requested vault account.
         * @summary Rename a vault account
         * @param {string} vaultAccountId The ID of the vault account to edit
         * @param {UpdateVaultAccountRequest} updateVaultAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVaultAccount(vaultAccountId: string, updateVaultAccountRequest: UpdateVaultAccountRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVaultAccount(vaultAccountId, updateVaultAccountRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Updates the description of an existing address of an asset in a vault account.
         * @summary Update address description
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
         * @param {UpdateVaultAccountAssetAddressRequest} [updateVaultAccountAssetAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVaultAccountAssetAddress(vaultAccountId: string, assetId: string, addressId: string, updateVaultAccountAssetAddressRequest?: UpdateVaultAccountAssetAddressRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVaultAccountAssetAddress(vaultAccountId, assetId, addressId, updateVaultAccountAssetAddressRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Updates the balance of a specific asset in a vault account.
         * @summary Refresh asset balance data
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVaultAccountAssetBalance(vaultAccountId: string, assetId: string, body?: object, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVaultAccountAssetBalance(vaultAccountId, assetId, body, );
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for activateAssetForVaultAccount operation in VaultsApi.
 * @export
 * @interface VaultsApiActivateAssetForVaultAccountRequest
 */
export interface VaultsApiActivateAssetForVaultAccountRequest {
    /**
     * The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
     * @type {string}
     * @memberof VaultsApiActivateAssetForVaultAccount
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiActivateAssetForVaultAccount
     */
    readonly assetId: string
}

/**
 * Request parameters for createLegacyAddressForVaultAccountAsset operation in VaultsApi.
 * @export
 * @interface VaultsApiCreateLegacyAddressForVaultAccountAssetRequest
 */
export interface VaultsApiCreateLegacyAddressForVaultAccountAssetRequest {
    /**
     * The ID of the vault account
     * @type {string}
     * @memberof VaultsApiCreateLegacyAddressForVaultAccountAsset
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiCreateLegacyAddressForVaultAccountAsset
     */
    readonly assetId: string

    /**
     * The segwit address to translate
     * @type {string}
     * @memberof VaultsApiCreateLegacyAddressForVaultAccountAsset
     */
    readonly addressId: string
}

/**
 * Request parameters for createVaultAccount operation in VaultsApi.
 * @export
 * @interface VaultsApiCreateVaultAccountRequest
 */
export interface VaultsApiCreateVaultAccountRequest {
    /**
     * 
     * @type {CreateVaultAccountRequest}
     * @memberof VaultsApiCreateVaultAccount
     */
    readonly createVaultAccountRequest: CreateVaultAccountRequest
}

/**
 * Request parameters for createVaultAccountAsset operation in VaultsApi.
 * @export
 * @interface VaultsApiCreateVaultAccountAssetRequest
 */
export interface VaultsApiCreateVaultAccountAssetRequest {
    /**
     * The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
     * @type {string}
     * @memberof VaultsApiCreateVaultAccountAsset
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiCreateVaultAccountAsset
     */
    readonly assetId: string

    /**
     * 
     * @type {CreateVaultAccountAssetRequest}
     * @memberof VaultsApiCreateVaultAccountAsset
     */
    readonly createVaultAccountAssetRequest?: CreateVaultAccountAssetRequest
}

/**
 * Request parameters for createVaultAccountAssetAddress operation in VaultsApi.
 * @export
 * @interface VaultsApiCreateVaultAccountAssetAddressRequest
 */
export interface VaultsApiCreateVaultAccountAssetAddressRequest {
    /**
     * The ID of the vault account to return
     * @type {string}
     * @memberof VaultsApiCreateVaultAccountAssetAddress
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiCreateVaultAccountAssetAddress
     */
    readonly assetId: string

    /**
     * 
     * @type {CreateVaultAccountAssetAddressRequest}
     * @memberof VaultsApiCreateVaultAccountAssetAddress
     */
    readonly createVaultAccountAssetAddressRequest?: CreateVaultAccountAssetAddressRequest
}

/**
 * Request parameters for getAssetWallets operation in VaultsApi.
 * @export
 * @interface VaultsApiGetAssetWalletsRequest
 */
export interface VaultsApiGetAssetWalletsRequest {
    /**
     * When specified, only asset wallets with total balance larger than this amount are returned.
     * @type {number}
     * @memberof VaultsApiGetAssetWallets
     */
    readonly totalAmountLargerThan?: number

    /**
     * When specified, only asset wallets cross vault accounts that have this asset ID are returned.
     * @type {string}
     * @memberof VaultsApiGetAssetWallets
     */
    readonly assetId?: string

    /**
     * Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page.
     * @type {string}
     * @memberof VaultsApiGetAssetWallets
     */
    readonly before?: string

    /**
     * Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page.
     * @type {string}
     * @memberof VaultsApiGetAssetWallets
     */
    readonly after?: string

    /**
     * The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000.
     * @type {number}
     * @memberof VaultsApiGetAssetWallets
     */
    readonly limit?: number
}

/**
 * Request parameters for getMaxSpendableAmount operation in VaultsApi.
 * @export
 * @interface VaultsApiGetMaxSpendableAmountRequest
 */
export interface VaultsApiGetMaxSpendableAmountRequest {
    /**
     * The ID of the vault account, or \&#39;default\&#39; for the default vault account
     * @type {string}
     * @memberof VaultsApiGetMaxSpendableAmount
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiGetMaxSpendableAmount
     */
    readonly assetId: string

    /**
     * False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device.
     * @type {boolean}
     * @memberof VaultsApiGetMaxSpendableAmount
     */
    readonly manualSignging?: boolean
}

/**
 * Request parameters for getPagedVaultAccounts operation in VaultsApi.
 * @export
 * @interface VaultsApiGetPagedVaultAccountsRequest
 */
export interface VaultsApiGetPagedVaultAccountsRequest {
    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly namePrefix?: string

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly nameSuffix?: string

    /**
     * 
     * @type {number}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly minAmountThreshold?: number

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly assetId?: string

    /**
     * 
     * @type {number}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly maxBip44AddressIndexUsed?: number

    /**
     * 
     * @type {number}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly maxBip44ChangeAddressIndexUsed?: number

    /**
     * 
     * @type {'ASC' | 'DESC'}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly orderBy?: 'ASC' | 'DESC'

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly after?: string

    /**
     * 
     * @type {number}
     * @memberof VaultsApiGetPagedVaultAccounts
     */
    readonly limit?: number
}

/**
 * Request parameters for getPublicKeyInfo operation in VaultsApi.
 * @export
 * @interface VaultsApiGetPublicKeyInfoRequest
 */
export interface VaultsApiGetPublicKeyInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPublicKeyInfo
     */
    readonly derivationPath: string

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPublicKeyInfo
     */
    readonly algorithm: string

    /**
     * 
     * @type {boolean}
     * @memberof VaultsApiGetPublicKeyInfo
     */
    readonly compressed?: boolean
}

/**
 * Request parameters for getPublicKeyInfoForAddress operation in VaultsApi.
 * @export
 * @interface VaultsApiGetPublicKeyInfoForAddressRequest
 */
export interface VaultsApiGetPublicKeyInfoForAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPublicKeyInfoForAddress
     */
    readonly vaultAccountId: string

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetPublicKeyInfoForAddress
     */
    readonly assetId: string

    /**
     * 
     * @type {number}
     * @memberof VaultsApiGetPublicKeyInfoForAddress
     */
    readonly change: number

    /**
     * 
     * @type {number}
     * @memberof VaultsApiGetPublicKeyInfoForAddress
     */
    readonly addressIndex: number

    /**
     * 
     * @type {boolean}
     * @memberof VaultsApiGetPublicKeyInfoForAddress
     */
    readonly compressed?: boolean
}

/**
 * Request parameters for getVaultAccountAsset operation in VaultsApi.
 * @export
 * @interface VaultsApiGetVaultAccountAssetRequest
 */
export interface VaultsApiGetVaultAccountAssetRequest {
    /**
     * The ID of the vault account to return
     * @type {string}
     * @memberof VaultsApiGetVaultAccountAsset
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiGetVaultAccountAsset
     */
    readonly assetId: string
}

/**
 * Request parameters for getVaultAccountAssetAddresses operation in VaultsApi.
 * @export
 * @interface VaultsApiGetVaultAccountAssetAddressesRequest
 */
export interface VaultsApiGetVaultAccountAssetAddressesRequest {
    /**
     * The ID of the vault account to return
     * @type {string}
     * @memberof VaultsApiGetVaultAccountAssetAddresses
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiGetVaultAccountAssetAddresses
     */
    readonly assetId: string
}

/**
 * Request parameters for getVaultAccountAssetUnspentInputs operation in VaultsApi.
 * @export
 * @interface VaultsApiGetVaultAccountAssetUnspentInputsRequest
 */
export interface VaultsApiGetVaultAccountAssetUnspentInputsRequest {
    /**
     * The ID of the vault account
     * @type {string}
     * @memberof VaultsApiGetVaultAccountAssetUnspentInputs
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiGetVaultAccountAssetUnspentInputs
     */
    readonly assetId: string
}

/**
 * Request parameters for getVaultAccountById operation in VaultsApi.
 * @export
 * @interface VaultsApiGetVaultAccountByIdRequest
 */
export interface VaultsApiGetVaultAccountByIdRequest {
    /**
     * The ID of the vault account to return type: string
     * @type {string}
     * @memberof VaultsApiGetVaultAccountById
     */
    readonly vaultAccountId: string
}

/**
 * Request parameters for getVaultAccounts operation in VaultsApi.
 * @export
 * @interface VaultsApiGetVaultAccountsRequest
 */
export interface VaultsApiGetVaultAccountsRequest {
    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetVaultAccounts
     */
    readonly namePrefix?: string

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetVaultAccounts
     */
    readonly nameSuffix?: string

    /**
     * 
     * @type {number}
     * @memberof VaultsApiGetVaultAccounts
     */
    readonly minAmountThreshold?: number

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetVaultAccounts
     */
    readonly assetId?: string

    /**
     * 
     * @type {number}
     * @memberof VaultsApiGetVaultAccounts
     */
    readonly maxBip44AddressIndexUsed?: number

    /**
     * 
     * @type {number}
     * @memberof VaultsApiGetVaultAccounts
     */
    readonly maxBip44ChangeAddressIndexUsed?: number
}

/**
 * Request parameters for getVaultAssetById operation in VaultsApi.
 * @export
 * @interface VaultsApiGetVaultAssetByIdRequest
 */
export interface VaultsApiGetVaultAssetByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetVaultAssetById
     */
    readonly assetId: string
}

/**
 * Request parameters for getVaultAssets operation in VaultsApi.
 * @export
 * @interface VaultsApiGetVaultAssetsRequest
 */
export interface VaultsApiGetVaultAssetsRequest {
    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetVaultAssets
     */
    readonly accountNamePrefix?: string

    /**
     * 
     * @type {string}
     * @memberof VaultsApiGetVaultAssets
     */
    readonly accountNameSuffix?: string
}

/**
 * Request parameters for hideVaultAccount operation in VaultsApi.
 * @export
 * @interface VaultsApiHideVaultAccountRequest
 */
export interface VaultsApiHideVaultAccountRequest {
    /**
     * The vault account to hide
     * @type {string}
     * @memberof VaultsApiHideVaultAccount
     */
    readonly vaultAccountId: string
}

/**
 * Request parameters for setAutoFuelForVaultAccount operation in VaultsApi.
 * @export
 * @interface VaultsApiSetAutoFuelForVaultAccountRequest
 */
export interface VaultsApiSetAutoFuelForVaultAccountRequest {
    /**
     * The vault account ID
     * @type {string}
     * @memberof VaultsApiSetAutoFuelForVaultAccount
     */
    readonly vaultAccountId: string

    /**
     * 
     * @type {SetAutoFuelForVaultAccountRequest}
     * @memberof VaultsApiSetAutoFuelForVaultAccount
     */
    readonly setAutoFuelForVaultAccountRequest: SetAutoFuelForVaultAccountRequest
}

/**
 * Request parameters for setCustomerRefIdForVaultAccount operation in VaultsApi.
 * @export
 * @interface VaultsApiSetCustomerRefIdForVaultAccountRequest
 */
export interface VaultsApiSetCustomerRefIdForVaultAccountRequest {
    /**
     * The vault account ID
     * @type {string}
     * @memberof VaultsApiSetCustomerRefIdForVaultAccount
     */
    readonly vaultAccountId: string

    /**
     * 
     * @type {SetCustomerRefIdForVaultAccountRequest}
     * @memberof VaultsApiSetCustomerRefIdForVaultAccount
     */
    readonly setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest
}

/**
 * Request parameters for setCustomerRefIdForVaultAccountAssetAddress operation in VaultsApi.
 * @export
 * @interface VaultsApiSetCustomerRefIdForVaultAccountAssetAddressRequest
 */
export interface VaultsApiSetCustomerRefIdForVaultAccountAssetAddressRequest {
    /**
     * The ID of the vault account
     * @type {string}
     * @memberof VaultsApiSetCustomerRefIdForVaultAccountAssetAddress
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiSetCustomerRefIdForVaultAccountAssetAddress
     */
    readonly assetId: string

    /**
     * The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
     * @type {string}
     * @memberof VaultsApiSetCustomerRefIdForVaultAccountAssetAddress
     */
    readonly addressId: string

    /**
     * 
     * @type {SetCustomerRefIdForVaultAccountRequest}
     * @memberof VaultsApiSetCustomerRefIdForVaultAccountAssetAddress
     */
    readonly setCustomerRefIdForVaultAccountRequest: SetCustomerRefIdForVaultAccountRequest
}

/**
 * Request parameters for unhideVaultAccount operation in VaultsApi.
 * @export
 * @interface VaultsApiUnhideVaultAccountRequest
 */
export interface VaultsApiUnhideVaultAccountRequest {
    /**
     * The vault account to unhide
     * @type {string}
     * @memberof VaultsApiUnhideVaultAccount
     */
    readonly vaultAccountId: string
}

/**
 * Request parameters for updateVaultAccount operation in VaultsApi.
 * @export
 * @interface VaultsApiUpdateVaultAccountRequest
 */
export interface VaultsApiUpdateVaultAccountRequest {
    /**
     * The ID of the vault account to edit
     * @type {string}
     * @memberof VaultsApiUpdateVaultAccount
     */
    readonly vaultAccountId: string

    /**
     * 
     * @type {UpdateVaultAccountRequest}
     * @memberof VaultsApiUpdateVaultAccount
     */
    readonly updateVaultAccountRequest: UpdateVaultAccountRequest
}

/**
 * Request parameters for updateVaultAccountAssetAddress operation in VaultsApi.
 * @export
 * @interface VaultsApiUpdateVaultAccountAssetAddressRequest
 */
export interface VaultsApiUpdateVaultAccountAssetAddressRequest {
    /**
     * The ID of the vault account
     * @type {string}
     * @memberof VaultsApiUpdateVaultAccountAssetAddress
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiUpdateVaultAccountAssetAddress
     */
    readonly assetId: string

    /**
     * The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
     * @type {string}
     * @memberof VaultsApiUpdateVaultAccountAssetAddress
     */
    readonly addressId: string

    /**
     * 
     * @type {UpdateVaultAccountAssetAddressRequest}
     * @memberof VaultsApiUpdateVaultAccountAssetAddress
     */
    readonly updateVaultAccountAssetAddressRequest?: UpdateVaultAccountAssetAddressRequest
}

/**
 * Request parameters for updateVaultAccountAssetBalance operation in VaultsApi.
 * @export
 * @interface VaultsApiUpdateVaultAccountAssetBalanceRequest
 */
export interface VaultsApiUpdateVaultAccountAssetBalanceRequest {
    /**
     * The ID of the vault account to return
     * @type {string}
     * @memberof VaultsApiUpdateVaultAccountAssetBalance
     */
    readonly vaultAccountId: string

    /**
     * The ID of the asset
     * @type {string}
     * @memberof VaultsApiUpdateVaultAccountAssetBalance
     */
    readonly assetId: string

    /**
     * 
     * @type {object}
     * @memberof VaultsApiUpdateVaultAccountAssetBalance
     */
    readonly body?: object
}

/**
 * VaultsApi - object-oriented interface
 * @export
 * @class VaultsApi
 * @extends {BaseAPI}
 */
export class VaultsApi extends BaseAPI {
    /**
     * Initiates activation for a wallet in a vault account.
     * @summary Activate a wallet in a vault account
     * @param {VaultsApiActivateAssetForVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public activateAssetForVaultAccount(requestParameters: VaultsApiActivateAssetForVaultAccountRequest, ) {
        return VaultsApiFp(this.httpClient).activateAssetForVaultAccount(requestParameters.vaultAccountId, requestParameters.assetId, );
    }

    /**
     * Converts an existing segwit address to the legacy format.
     * @summary Convert a segwit address to legacy format
     * @param {VaultsApiCreateLegacyAddressForVaultAccountAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public createLegacyAddressForVaultAccountAsset(requestParameters: VaultsApiCreateLegacyAddressForVaultAccountAssetRequest, ) {
        return VaultsApiFp(this.httpClient).createLegacyAddressForVaultAccountAsset(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.addressId, );
    }

    /**
     * Creates a new vault account with the requested name.
     * @summary Create a new vault account
     * @param {VaultsApiCreateVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public createVaultAccount(requestParameters: VaultsApiCreateVaultAccountRequest, ) {
        return VaultsApiFp(this.httpClient).createVaultAccount(requestParameters.createVaultAccountRequest, );
    }

    /**
     * Creates a wallet for a specific asset in a vault account.
     * @summary Create a new wallet
     * @param {VaultsApiCreateVaultAccountAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public createVaultAccountAsset(requestParameters: VaultsApiCreateVaultAccountAssetRequest, ) {
        return VaultsApiFp(this.httpClient).createVaultAccountAsset(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.createVaultAccountAssetRequest, );
    }

    /**
     * Creates a new deposit address for an asset of a vault account.
     * @summary Create new asset deposit address
     * @param {VaultsApiCreateVaultAccountAssetAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public createVaultAccountAssetAddress(requestParameters: VaultsApiCreateVaultAccountAssetAddressRequest, ) {
        return VaultsApiFp(this.httpClient).createVaultAccountAssetAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.createVaultAccountAssetAddressRequest, );
    }

    /**
     * Gets all asset wallets at all of the vault accounts in your workspace. An asset wallet is an asset at a vault account. This method allows fast traversal of all account balances. **Note:**   - This API endpoint is in limited availability and available for selected customers. If you would like to get early access to this endpoint, please reach out to [Fireblocks Support](https://support.fireblocks.io/hc/en-us/requests/new?ticket_form_id=36000337220)   - This API call is subject to [rate limits](https://developers.fireblocks.com/reference/rate-limiting). 
     * @summary List asset wallets (Paginated)
     * @param {VaultsApiGetAssetWalletsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getAssetWallets(requestParameters: VaultsApiGetAssetWalletsRequest = {}, ) {
        return VaultsApiFp(this.httpClient).getAssetWallets(requestParameters.totalAmountLargerThan, requestParameters.assetId, requestParameters.before, requestParameters.after, requestParameters.limit, );
    }

    /**
     * Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.
     * @summary Get the maximum spendable amount in a single transaction.
     * @param {VaultsApiGetMaxSpendableAmountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getMaxSpendableAmount(requestParameters: VaultsApiGetMaxSpendableAmountRequest, ) {
        return VaultsApiFp(this.httpClient).getMaxSpendableAmount(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.manualSignging, );
    }

    /**
     * Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.
     * @summary List vault acounts (Paginated)
     * @param {VaultsApiGetPagedVaultAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getPagedVaultAccounts(requestParameters: VaultsApiGetPagedVaultAccountsRequest = {}, ) {
        return VaultsApiFp(this.httpClient).getPagedVaultAccounts(requestParameters.namePrefix, requestParameters.nameSuffix, requestParameters.minAmountThreshold, requestParameters.assetId, requestParameters.maxBip44AddressIndexUsed, requestParameters.maxBip44ChangeAddressIndexUsed, requestParameters.orderBy, requestParameters.before, requestParameters.after, requestParameters.limit, );
    }

    /**
     * Gets the public key information based on derivation path and signing algorithm.
     * @summary Get the public key information
     * @param {VaultsApiGetPublicKeyInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getPublicKeyInfo(requestParameters: VaultsApiGetPublicKeyInfoRequest, ) {
        return VaultsApiFp(this.httpClient).getPublicKeyInfo(requestParameters.derivationPath, requestParameters.algorithm, requestParameters.compressed, );
    }

    /**
     * Gets the public key information for the vault account.
     * @summary Get the public key for a vault account
     * @param {VaultsApiGetPublicKeyInfoForAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getPublicKeyInfoForAddress(requestParameters: VaultsApiGetPublicKeyInfoForAddressRequest, ) {
        return VaultsApiFp(this.httpClient).getPublicKeyInfoForAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.change, requestParameters.addressIndex, requestParameters.compressed, );
    }

    /**
     * Returns a wallet for a specific asset of a vault account.
     * @summary Get the asset balance for a vault account
     * @param {VaultsApiGetVaultAccountAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getVaultAccountAsset(requestParameters: VaultsApiGetVaultAccountAssetRequest, ) {
        return VaultsApiFp(this.httpClient).getVaultAccountAsset(requestParameters.vaultAccountId, requestParameters.assetId, );
    }

    /**
     * Lists all addresses for specific asset of vault account.
     * @summary Get asset addresses
     * @param {VaultsApiGetVaultAccountAssetAddressesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getVaultAccountAssetAddresses(requestParameters: VaultsApiGetVaultAccountAssetAddressesRequest, ) {
        return VaultsApiFp(this.httpClient).getVaultAccountAssetAddresses(requestParameters.vaultAccountId, requestParameters.assetId, );
    }

    /**
     * Returns unspent inputs information of an asset in a vault account.
     * @summary Get UTXO unspent inputs information
     * @param {VaultsApiGetVaultAccountAssetUnspentInputsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getVaultAccountAssetUnspentInputs(requestParameters: VaultsApiGetVaultAccountAssetUnspentInputsRequest, ) {
        return VaultsApiFp(this.httpClient).getVaultAccountAssetUnspentInputs(requestParameters.vaultAccountId, requestParameters.assetId, );
    }

    /**
     * Returns the requested vault account.
     * @summary Find a vault account by ID
     * @param {VaultsApiGetVaultAccountByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getVaultAccountById(requestParameters: VaultsApiGetVaultAccountByIdRequest, ) {
        return VaultsApiFp(this.httpClient).getVaultAccountById(requestParameters.vaultAccountId, );
    }

    /**
     * Gets all vault accounts in your workspace.
     * @summary List vault accounts
     * @param {VaultsApiGetVaultAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getVaultAccounts(requestParameters: VaultsApiGetVaultAccountsRequest = {}, ) {
        return VaultsApiFp(this.httpClient).getVaultAccounts(requestParameters.namePrefix, requestParameters.nameSuffix, requestParameters.minAmountThreshold, requestParameters.assetId, requestParameters.maxBip44AddressIndexUsed, requestParameters.maxBip44ChangeAddressIndexUsed, );
    }

    /**
     * Gets the vault balance summary for an asset.
     * @summary Get vault balance by asset
     * @param {VaultsApiGetVaultAssetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getVaultAssetById(requestParameters: VaultsApiGetVaultAssetByIdRequest, ) {
        return VaultsApiFp(this.httpClient).getVaultAssetById(requestParameters.assetId, );
    }

    /**
     * Gets the assets amount summary for all accounts or filtered accounts.
     * @summary Get asset balance for chosen assets
     * @param {VaultsApiGetVaultAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public getVaultAssets(requestParameters: VaultsApiGetVaultAssetsRequest = {}, ) {
        return VaultsApiFp(this.httpClient).getVaultAssets(requestParameters.accountNamePrefix, requestParameters.accountNameSuffix, );
    }

    /**
     * Hides the requested vault account from the web console view.
     * @summary Hide a vault account in the console
     * @param {VaultsApiHideVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public hideVaultAccount(requestParameters: VaultsApiHideVaultAccountRequest, ) {
        return VaultsApiFp(this.httpClient).hideVaultAccount(requestParameters.vaultAccountId, );
    }

    /**
     * Sets the autofueling property of the vault account to enabled or disabled.
     * @summary Turn autofueling on or off
     * @param {VaultsApiSetAutoFuelForVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public setAutoFuelForVaultAccount(requestParameters: VaultsApiSetAutoFuelForVaultAccountRequest, ) {
        return VaultsApiFp(this.httpClient).setAutoFuelForVaultAccount(requestParameters.vaultAccountId, requestParameters.setAutoFuelForVaultAccountRequest, );
    }

    /**
     * Assigns an AML/KYT customer reference ID for the vault account.
     * @summary Set an AML/KYT customer reference ID for a vault account
     * @param {VaultsApiSetCustomerRefIdForVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public setCustomerRefIdForVaultAccount(requestParameters: VaultsApiSetCustomerRefIdForVaultAccountRequest, ) {
        return VaultsApiFp(this.httpClient).setCustomerRefIdForVaultAccount(requestParameters.vaultAccountId, requestParameters.setCustomerRefIdForVaultAccountRequest, );
    }

    /**
     * Sets an AML/KYT customer reference ID for a specific address.
     * @summary Assign AML customer reference ID
     * @param {VaultsApiSetCustomerRefIdForVaultAccountAssetAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public setCustomerRefIdForVaultAccountAssetAddress(requestParameters: VaultsApiSetCustomerRefIdForVaultAccountAssetAddressRequest, ) {
        return VaultsApiFp(this.httpClient).setCustomerRefIdForVaultAccountAssetAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.addressId, requestParameters.setCustomerRefIdForVaultAccountRequest, );
    }

    /**
     * Makes a hidden vault account visible in web console view.
     * @summary Unhide a vault account in the console
     * @param {VaultsApiUnhideVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public unhideVaultAccount(requestParameters: VaultsApiUnhideVaultAccountRequest, ) {
        return VaultsApiFp(this.httpClient).unhideVaultAccount(requestParameters.vaultAccountId, );
    }

    /**
     * Renames the requested vault account.
     * @summary Rename a vault account
     * @param {VaultsApiUpdateVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public updateVaultAccount(requestParameters: VaultsApiUpdateVaultAccountRequest, ) {
        return VaultsApiFp(this.httpClient).updateVaultAccount(requestParameters.vaultAccountId, requestParameters.updateVaultAccountRequest, );
    }

    /**
     * Updates the description of an existing address of an asset in a vault account.
     * @summary Update address description
     * @param {VaultsApiUpdateVaultAccountAssetAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public updateVaultAccountAssetAddress(requestParameters: VaultsApiUpdateVaultAccountAssetAddressRequest, ) {
        return VaultsApiFp(this.httpClient).updateVaultAccountAssetAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.addressId, requestParameters.updateVaultAccountAssetAddressRequest, );
    }

    /**
     * Updates the balance of a specific asset in a vault account.
     * @summary Refresh asset balance data
     * @param {VaultsApiUpdateVaultAccountAssetBalanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public updateVaultAccountAssetBalance(requestParameters: VaultsApiUpdateVaultAccountAssetBalanceRequest, ) {
        return VaultsApiFp(this.httpClient).updateVaultAccountAssetBalance(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.body, );
    }
}





    /**
 * Web3ConnectionsApi - axios parameter creator
 * @export
 */
export const Web3ConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiate a new Web3 connection.  * Note: After this succeeds, make a request to `PUT /v1/connections/wc/{id}` (below) to approve or reject the new Web3 connection.
         * @summary Create a new Web3 connection.
         * @param {CreateConnectionRequest} createConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWCConnection: async (createConnectionRequest: CreateConnectionRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'createConnectionRequest' is not null or undefined
            assertParamExists('createWCConnection', 'createConnectionRequest', createConnectionRequest)
            const localVarPath = `/connections/wc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = createConnectionRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Remove a Web3 connection
         * @summary Remove an existing Web3 connection.
         * @param {string} id The ID of the existing Web3 connection to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWCConnection: async (id: string, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWCConnection', 'id', id)
            const localVarPath = `/connections/wc/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'DELETE'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Get open Web3 connections.
         * @summary List all open Web3 connections.
         * @param {'ASC' | 'DESC'} [order] List order; ascending or descending.
         * @param {GetConnectionsFilterParameter} [filter] Parsed filter object
         * @param {'id' | 'userId' | 'vaultAccountId' | 'createdAt' | 'feeLevel' | 'appUrl' | 'appName'} [sort] Property to sort Web3 connections by.
         * @param {number} [pageSize] Amount of results to return in the next page.
         * @param {string} [next] Cursor to the next page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnections: async (order?: 'ASC' | 'DESC', filter?: GetConnectionsFilterParameter, sort?: 'id' | 'userId' | 'vaultAccountId' | 'createdAt' | 'feeLevel' | 'appUrl' | 'appName', pageSize?: number, next?: string, ): Promise<AxiosRequestConfig> => {
            const localVarPath = `/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'GET'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Submit a response to *approve* or *reject* an initiated Web3 connection. * Note: This call is used to complete your `POST /v1/connections/wc/` request.  After this succeeds, your new Web3 connection is created and functioning.
         * @summary Respond to a pending Web3 connection request.
         * @param {string} id The ID of the initiated Web3 connection to approve.
         * @param {RespondToConnectionRequest} respondToConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWCConnection: async (id: string, respondToConnectionRequest: RespondToConnectionRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateWCConnection', 'id', id)
            // verify required parameter 'respondToConnectionRequest' is not null or undefined
            assertParamExists('updateWCConnection', 'respondToConnectionRequest', respondToConnectionRequest)
            const localVarPath = `/connections/wc/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'PUT'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = respondToConnectionRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * Web3ConnectionsApi - functional programming interface
 * @export
 */
export const Web3ConnectionsApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = Web3ConnectionsApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * Initiate a new Web3 connection.  * Note: After this succeeds, make a request to `PUT /v1/connections/wc/{id}` (below) to approve or reject the new Web3 connection.
         * @summary Create a new Web3 connection.
         * @param {CreateConnectionRequest} createConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWCConnection(createConnectionRequest: CreateConnectionRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWCConnection(createConnectionRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Remove a Web3 connection
         * @summary Remove an existing Web3 connection.
         * @param {string} id The ID of the existing Web3 connection to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWCConnection(id: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWCConnection(id, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Get open Web3 connections.
         * @summary List all open Web3 connections.
         * @param {'ASC' | 'DESC'} [order] List order; ascending or descending.
         * @param {GetConnectionsFilterParameter} [filter] Parsed filter object
         * @param {'id' | 'userId' | 'vaultAccountId' | 'createdAt' | 'feeLevel' | 'appUrl' | 'appName'} [sort] Property to sort Web3 connections by.
         * @param {number} [pageSize] Amount of results to return in the next page.
         * @param {string} [next] Cursor to the next page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnections(order?: 'ASC' | 'DESC', filter?: GetConnectionsFilterParameter, sort?: 'id' | 'userId' | 'vaultAccountId' | 'createdAt' | 'feeLevel' | 'appUrl' | 'appName', pageSize?: number, next?: string, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetConnectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnections(order, filter, sort, pageSize, next, );
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Submit a response to *approve* or *reject* an initiated Web3 connection. * Note: This call is used to complete your `POST /v1/connections/wc/` request.  After this succeeds, your new Web3 connection is created and functioning.
         * @summary Respond to a pending Web3 connection request.
         * @param {string} id The ID of the initiated Web3 connection to approve.
         * @param {RespondToConnectionRequest} respondToConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWCConnection(id: string, respondToConnectionRequest: RespondToConnectionRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWCConnection(id, respondToConnectionRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for createWCConnection operation in Web3ConnectionsApi.
 * @export
 * @interface Web3ConnectionsApiCreateWCConnectionRequest
 */
export interface Web3ConnectionsApiCreateWCConnectionRequest {
    /**
     * 
     * @type {CreateConnectionRequest}
     * @memberof Web3ConnectionsApiCreateWCConnection
     */
    readonly createConnectionRequest: CreateConnectionRequest
}

/**
 * Request parameters for deleteWCConnection operation in Web3ConnectionsApi.
 * @export
 * @interface Web3ConnectionsApiDeleteWCConnectionRequest
 */
export interface Web3ConnectionsApiDeleteWCConnectionRequest {
    /**
     * The ID of the existing Web3 connection to remove.
     * @type {string}
     * @memberof Web3ConnectionsApiDeleteWCConnection
     */
    readonly id: string
}

/**
 * Request parameters for getConnections operation in Web3ConnectionsApi.
 * @export
 * @interface Web3ConnectionsApiGetConnectionsRequest
 */
export interface Web3ConnectionsApiGetConnectionsRequest {
    /**
     * List order; ascending or descending.
     * @type {'ASC' | 'DESC'}
     * @memberof Web3ConnectionsApiGetConnections
     */
    readonly order?: 'ASC' | 'DESC'

    /**
     * Parsed filter object
     * @type {GetConnectionsFilterParameter}
     * @memberof Web3ConnectionsApiGetConnections
     */
    readonly filter?: GetConnectionsFilterParameter

    /**
     * Property to sort Web3 connections by.
     * @type {'id' | 'userId' | 'vaultAccountId' | 'createdAt' | 'feeLevel' | 'appUrl' | 'appName'}
     * @memberof Web3ConnectionsApiGetConnections
     */
    readonly sort?: 'id' | 'userId' | 'vaultAccountId' | 'createdAt' | 'feeLevel' | 'appUrl' | 'appName'

    /**
     * Amount of results to return in the next page.
     * @type {number}
     * @memberof Web3ConnectionsApiGetConnections
     */
    readonly pageSize?: number

    /**
     * Cursor to the next page
     * @type {string}
     * @memberof Web3ConnectionsApiGetConnections
     */
    readonly next?: string
}

/**
 * Request parameters for updateWCConnection operation in Web3ConnectionsApi.
 * @export
 * @interface Web3ConnectionsApiUpdateWCConnectionRequest
 */
export interface Web3ConnectionsApiUpdateWCConnectionRequest {
    /**
     * The ID of the initiated Web3 connection to approve.
     * @type {string}
     * @memberof Web3ConnectionsApiUpdateWCConnection
     */
    readonly id: string

    /**
     * 
     * @type {RespondToConnectionRequest}
     * @memberof Web3ConnectionsApiUpdateWCConnection
     */
    readonly respondToConnectionRequest: RespondToConnectionRequest
}

/**
 * Web3ConnectionsApi - object-oriented interface
 * @export
 * @class Web3ConnectionsApi
 * @extends {BaseAPI}
 */
export class Web3ConnectionsApi extends BaseAPI {
    /**
     * Initiate a new Web3 connection.  * Note: After this succeeds, make a request to `PUT /v1/connections/wc/{id}` (below) to approve or reject the new Web3 connection.
     * @summary Create a new Web3 connection.
     * @param {Web3ConnectionsApiCreateWCConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Web3ConnectionsApi
     */
    public createWCConnection(requestParameters: Web3ConnectionsApiCreateWCConnectionRequest, ) {
        return Web3ConnectionsApiFp(this.httpClient).createWCConnection(requestParameters.createConnectionRequest, );
    }

    /**
     * Remove a Web3 connection
     * @summary Remove an existing Web3 connection.
     * @param {Web3ConnectionsApiDeleteWCConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Web3ConnectionsApi
     */
    public deleteWCConnection(requestParameters: Web3ConnectionsApiDeleteWCConnectionRequest, ) {
        return Web3ConnectionsApiFp(this.httpClient).deleteWCConnection(requestParameters.id, );
    }

    /**
     * Get open Web3 connections.
     * @summary List all open Web3 connections.
     * @param {Web3ConnectionsApiGetConnectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Web3ConnectionsApi
     */
    public getConnections(requestParameters: Web3ConnectionsApiGetConnectionsRequest = {}, ) {
        return Web3ConnectionsApiFp(this.httpClient).getConnections(requestParameters.order, requestParameters.filter, requestParameters.sort, requestParameters.pageSize, requestParameters.next, );
    }

    /**
     * Submit a response to *approve* or *reject* an initiated Web3 connection. * Note: This call is used to complete your `POST /v1/connections/wc/` request.  After this succeeds, your new Web3 connection is created and functioning.
     * @summary Respond to a pending Web3 connection request.
     * @param {Web3ConnectionsApiUpdateWCConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Web3ConnectionsApi
     */
    public updateWCConnection(requestParameters: Web3ConnectionsApiUpdateWCConnectionRequest, ) {
        return Web3ConnectionsApiFp(this.httpClient).updateWCConnection(requestParameters.id, requestParameters.respondToConnectionRequest, );
    }
}





    /**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resends all failed webhook notifications.
         * @summary Resend failed webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhooks: async (): Promise<AxiosRequestConfig> => {
            const localVarPath = `/webhooks/resend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
        /**
         * Resends failed webhook notifications for a transaction by ID.
         * @summary Resend failed webhooks for a transaction by ID
         * @param {string} txId The ID of the transaction for webhooks
         * @param {ResendWebhooksForTransactionRequest} resendWebhooksForTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhooksForTransaction: async (txId: string, resendWebhooksForTransactionRequest: ResendWebhooksForTransactionRequest, ): Promise<AxiosRequestConfig> => {
            // verify required parameter 'txId' is not null or undefined
            assertParamExists('resendWebhooksForTransaction', 'txId', txId)
            // verify required parameter 'resendWebhooksForTransactionRequest' is not null or undefined
            assertParamExists('resendWebhooksForTransaction', 'resendWebhooksForTransactionRequest', resendWebhooksForTransactionRequest)
            const localVarPath = `/webhooks/resend/{txId}`
                .replace(`{${"txId"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(configuration.basePath + localVarPath);

            const localVarRequestOptions:AxiosRequestConfig = { method: 'POST'};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            localVarRequestOptions.headers = {...localVarHeaderParameter, };
            localVarRequestOptions.data = resendWebhooksForTransactionRequest as any;

            return {
                url: localVarUrlObj.toString(),
                ...localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(httpClient: HttpClient) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(httpClient.configuration)
    return {
        /**
         * Resends all failed webhook notifications.
         * @summary Resend failed webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendWebhooks(): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResendWebhooksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendWebhooks();
            return httpClient.request(localVarAxiosArgs);
        },
        /**
         * Resends failed webhook notifications for a transaction by ID.
         * @summary Resend failed webhooks for a transaction by ID
         * @param {string} txId The ID of the transaction for webhooks
         * @param {ResendWebhooksForTransactionRequest} resendWebhooksForTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendWebhooksForTransaction(txId: string, resendWebhooksForTransactionRequest: ResendWebhooksForTransactionRequest, ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendWebhooksForTransaction(txId, resendWebhooksForTransactionRequest, );
            return httpClient.request(localVarAxiosArgs);
        },
    }
};

/**
 * Request parameters for resendWebhooksForTransaction operation in WebhooksApi.
 * @export
 * @interface WebhooksApiResendWebhooksForTransactionRequest
 */
export interface WebhooksApiResendWebhooksForTransactionRequest {
    /**
     * The ID of the transaction for webhooks
     * @type {string}
     * @memberof WebhooksApiResendWebhooksForTransaction
     */
    readonly txId: string

    /**
     * 
     * @type {ResendWebhooksForTransactionRequest}
     * @memberof WebhooksApiResendWebhooksForTransaction
     */
    readonly resendWebhooksForTransactionRequest: ResendWebhooksForTransactionRequest
}

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Resends all failed webhook notifications.
     * @summary Resend failed webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public resendWebhooks() {
        return WebhooksApiFp(this.httpClient).resendWebhooks();
    }

    /**
     * Resends failed webhook notifications for a transaction by ID.
     * @summary Resend failed webhooks for a transaction by ID
     * @param {WebhooksApiResendWebhooksForTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public resendWebhooksForTransaction(requestParameters: WebhooksApiResendWebhooksForTransactionRequest, ) {
        return WebhooksApiFp(this.httpClient).resendWebhooksForTransaction(requestParameters.txId, requestParameters.resendWebhooksForTransactionRequest, );
    }
}


